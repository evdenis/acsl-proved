
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Jessie_voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

module Root_unsigned_intP_safe

  use why3.Bool.Bool 
  
end

module Root_unsigned_intP_unsafe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_safe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_unsafe

  use why3.Bool.Bool 
  
end

module Root_int_xP_safe

  use why3.Bool.Bool 
  
end

module Root_int_xP_unsafe

  use why3.Bool.Bool 
  
end

theory Logic_factorial_ind

  use int.Int 
  
  use why3.Bool.Bool 
  
  inductive factorial_ind int int
  =
  |
  nil:
  (factorial_ind (0) (1))
  |
  step_inc:
  (forall i_16 : int.
   (forall f_0_0 : int.
    ((factorial_ind (Int.(-) i_16 (1)) f_0_0) ->
     (factorial_ind i_16 (Int.( *) f_0_0 i_16)))))
  
end

theory Lemma_increasing

  use import Logic_factorial_ind 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  lemma Increasing
  #"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 12 7 120#
  "expl:Lemma increasing" :
  (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 12 7 120#
  (forall i1 : int.
   (forall i2 : int.
    (forall f1 : int.
     (forall f2 : int.
      ((((>=) i2 i1) /\ ((factorial_ind i1 f1) /\ (factorial_ind i2 f2))) ->
       ((>=) f2 f1)))))))
  
end

theory Lemma_factorial_ind_20

  use import Logic_factorial_ind 
  
  use why3.Bool.Bool 
  
  lemma Factorial_ind_20
  #"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 10 7 45#
  "expl:Lemma factorial_ind_20" :
  (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 10 7 45#
  (factorial_ind (20) (2432902008176640000)))
  
end

module Function_spec_abs2_safety

  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let spec_abs2 #"/home/work/workspace/education/acsl-exam/./abs.c" 21 4 20#
  "expl:Function spec_abs2, safety" =
  fun (a_15 : Int32.t) 
   requires {
   (#"/home/work/workspace/education/acsl-exam/./abs.c" 5 13 28#
   ((<) (Int.(-_) (2147483648)) (Int32.to_int a_15))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let abs = ref (Safe_int32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 25 7 12#
     (Safe_int32.(<)  a_15
      (#"whole_program.jc" 110 26 38# "expl:Integer cast"
      (Safe_int32.of_int (0))) ))
     then
      (abs :=
       (let _jessie_79 = (Safe_int32.(-_)  a_15 ) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 26 6 14#
       "expl:Pointer index bounds" true) }); _jessie_79 end))
     else
      (abs :=
       (let _jessie_78 = a_15 in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 28 6 13#
       "expl:Pointer index bounds" true) }); _jessie_78 end)));
      begin
      (return :=
       (let _jessie_80 = !abs in
       begin
       (assert {
       (#"whole_program.jc" 115 7 17# "expl:Pointer index bounds" true) });
        _jessie_80 end)); (raise Return) end end); absurd  end with Return ->
    !return end)
  
end

module Function_spec_abs2_behaviors

  use Unsafe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let spec_abs2_ensures_default
  #"/home/work/workspace/education/acsl-exam/./abs.c" 21 4 20#
  "expl:Function spec_abs2, default behavior" =
  fun (a_15 : Int32.t) 
   requires {
   (#"/home/work/workspace/education/acsl-exam/./abs.c" 5 13 28#
   ((<) (Int.(-_) (2147483648)) (Int32.to_int a_15))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 7 12 24#
     "expl:Ensures clause"
     (Int32.(>=) result (#"whole_program.jc" 83 30 42# "expl:Integer cast"
     (Int32.of_int (0)))))) }  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (check {
    (#"whole_program.jc" 95 10 123# "expl:Behavior disjointness check"
    (not
    ((Int32.(=) a_15 (#"whole_program.jc" 95 45 57# "expl:Integer cast"
     (Int32.of_int (0))))
    /\
    (Int32.(<) a_15 (#"whole_program.jc" 96 45 57# "expl:Integer cast"
    (Int32.of_int (0))))))) });
     (check {
     (#"whole_program.jc" 98 10 123# "expl:Behavior disjointness check"
     (not
     ((Int32.(>) a_15 (#"whole_program.jc" 98 44 56# "expl:Integer cast"
      (Int32.of_int (0))))
     /\
     (Int32.(=) a_15 (#"whole_program.jc" 99 46 58# "expl:Integer cast"
     (Int32.of_int (0))))))) });
     (check {
     (#"whole_program.jc" 101 10 122# "expl:Behavior disjointness check"
     (not
     ((Int32.(>) a_15 (#"whole_program.jc" 101 44 56# "expl:Integer cast"
      (Int32.of_int (0))))
     /\
     (Int32.(<) a_15 (#"whole_program.jc" 102 45 57# "expl:Integer cast"
     (Int32.of_int (0))))))) });
     (check {
     (#"whole_program.jc" 104 10 179# "expl:Behavior completeness check"
     ((Int32.(<) a_15 (#"whole_program.jc" 104 41 53# "expl:Integer cast"
      (Int32.of_int (0))))
     \/
     ((Int32.(=) a_15 (#"whole_program.jc" 105 44 56# "expl:Integer cast"
      (Int32.of_int (0))))
     \/
     (Int32.(>) a_15 (#"whole_program.jc" 106 44 56# "expl:Integer cast"
     (Int32.of_int (0))))))) });
     (let abs = ref (Unsafe_int32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 25 7 12#
     (Unsafe_int32.(<)  a_15
      (#"whole_program.jc" 110 26 38# "expl:Integer cast"
      (Unsafe_int32.of_int (0))) )) then (abs := (Unsafe_int32.(-_)  a_15 ))
     else (abs := a_15)); begin (return := !abs); (raise Return) end end);
     absurd  end with Return -> !return end)
  
  let spec_abs2_ensures_negative
  #"/home/work/workspace/education/acsl-exam/./abs.c" 21 4 20#
  "expl:Function spec_abs2, behavior negative" =
  fun (a_15 : Int32.t) 
   requires {
   ((Int32.(<) a_15 (#"whole_program.jc" 92 18 30# "expl:Integer cast"
    (Int32.of_int (0))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./abs.c" 5 13 28#
   ((<) (Int.(-_) (2147483648)) (Int32.to_int a_15)))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 17 15 28#
     "expl:Ensures clause"
     ((=) (Int32.to_int result) (Int.(-_) (Int32.to_int a_15))))) }  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let abs = ref (Unsafe_int32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 25 7 12#
     (Unsafe_int32.(<)  a_15
      (#"whole_program.jc" 110 26 38# "expl:Integer cast"
      (Unsafe_int32.of_int (0))) )) then (abs := (Unsafe_int32.(-_)  a_15 ))
     else (abs := a_15)); begin (return := !abs); (raise Return) end end);
     absurd  end with Return -> !return end)
  
  let spec_abs2_ensures_positive
  #"/home/work/workspace/education/acsl-exam/./abs.c" 21 4 20#
  "expl:Function spec_abs2, behavior positive" =
  fun (a_15 : Int32.t) 
   requires {
   ((Int32.(>) a_15 (#"whole_program.jc" 85 18 30# "expl:Integer cast"
    (Int32.of_int (0))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./abs.c" 5 13 28#
   ((<) (Int.(-_) (2147483648)) (Int32.to_int a_15)))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 10 15 27#
     "expl:Ensures clause" (Int32.(=) result a_15))) }  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let abs = ref (Unsafe_int32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 25 7 12#
     (Unsafe_int32.(<)  a_15
      (#"whole_program.jc" 110 26 38# "expl:Integer cast"
      (Unsafe_int32.of_int (0))) )) then (abs := (Unsafe_int32.(-_)  a_15 ))
     else (abs := a_15)); begin (return := !abs); (raise Return) end end);
     absurd  end with Return -> !return end)
  
  let spec_abs2_ensures_zero
  #"/home/work/workspace/education/acsl-exam/./abs.c" 21 4 20#
  "expl:Function spec_abs2, behavior zero" =
  fun (a_15 : Int32.t) 
   requires {
   ((Int32.(=) a_15 (#"whole_program.jc" 88 19 31# "expl:Integer cast"
    (Int32.of_int (0))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./abs.c" 5 13 28#
   ((<) (Int.(-_) (2147483648)) (Int32.to_int a_15)))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 13 15 27#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 13 15 27#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./abs.c" 13 15 27#
      "expl:Ensures clause"
      (Int32.(=) result (#"whole_program.jc" 89 39 51# "expl:Integer cast"
      (Int32.of_int (0)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 14 15 27#
     "expl:Ensures clause" (Int32.(=) result a_15)))))) }  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let abs = ref (Unsafe_int32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 25 7 12#
     (Unsafe_int32.(<)  a_15
      (#"whole_program.jc" 110 26 38# "expl:Integer cast"
      (Unsafe_int32.of_int (0))) )) then (abs := (Unsafe_int32.(-_)  a_15 ))
     else (abs := a_15)); begin (return := !abs); (raise Return) end end);
     absurd  end with Return -> !return end)
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Function_spec_abs1_safety

  use Safe_int64_of_Safe_int32 
  
  use Safe_int64 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let spec_abs1
  #"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 19 5 21#
  "expl:Function spec_abs1, safety" =
  fun (a_14 : Int32.t) 
   requires { (true) } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_int64.any_  () ) in
   try
    begin
    (); (); (); ();
     (let abs_0 = ref (Safe_int64.any_  () ) in
     begin
     (abs_0 :=
      (let _jessie_93 =
      (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 23 9 10#
      "expl:Integer cast" (Safe_int64_of_Safe_int32.cast  a_14 )) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 23 3 10#
      "expl:Pointer index bounds" true) }); _jessie_93 end));
      (if
      (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 24 7 12#
      (Safe_int32.(<)  a_14
       (#"whole_program.jc" 150 27 39# "expl:Integer cast"
       (Safe_int32.of_int (0))) ))
      then
       (abs_0 :=
        (let _jessie_94 = (Safe_int64.(-_)  !abs_0 ) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 25 6 16#
        "expl:Pointer index bounds" true) }); _jessie_94 end)) else ());
      begin
      (return :=
       (let _jessie_95 = !abs_0 in
       begin
       (assert {
       (#"whole_program.jc" 154 7 19# "expl:Pointer index bounds" true) });
        _jessie_95 end)); (raise Return) end end); absurd  end with Return ->
    !return end)
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Function_spec_abs1_behaviors

  use Unsafe_int64_of_Unsafe_int32 
  
  use Unsafe_int64 
  
  use Unsafe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use Int64_of_Int32 
  
  use enum.Int64 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let spec_abs1_ensures_default
  #"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 19 5 21#
  "expl:Function spec_abs1, default behavior" =
  fun (a_14 : Int32.t) 
   requires { (true) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 5 12 24#
     "expl:Ensures clause" ((>=) (Int64.to_int result) (0)))) }  ->
   'Init:
   (let return = ref (Unsafe_int64.any_  () ) in
   try
    begin
    (check {
    (#"whole_program.jc" 134 10 123# "expl:Behavior disjointness check"
    (not
    ((Int32.(=) a_14 (#"whole_program.jc" 134 45 57# "expl:Integer cast"
     (Int32.of_int (0))))
    /\
    (Int32.(<) a_14 (#"whole_program.jc" 135 45 57# "expl:Integer cast"
    (Int32.of_int (0))))))) });
     (check {
     (#"whole_program.jc" 137 10 123# "expl:Behavior disjointness check"
     (not
     ((Int32.(>) a_14 (#"whole_program.jc" 137 44 56# "expl:Integer cast"
      (Int32.of_int (0))))
     /\
     (Int32.(=) a_14 (#"whole_program.jc" 138 46 58# "expl:Integer cast"
     (Int32.of_int (0))))))) });
     (check {
     (#"whole_program.jc" 140 10 122# "expl:Behavior disjointness check"
     (not
     ((Int32.(>) a_14 (#"whole_program.jc" 140 44 56# "expl:Integer cast"
      (Int32.of_int (0))))
     /\
     (Int32.(<) a_14 (#"whole_program.jc" 141 45 57# "expl:Integer cast"
     (Int32.of_int (0))))))) });
     (check {
     (#"whole_program.jc" 143 10 179# "expl:Behavior completeness check"
     ((Int32.(<) a_14 (#"whole_program.jc" 143 41 53# "expl:Integer cast"
      (Int32.of_int (0))))
     \/
     ((Int32.(=) a_14 (#"whole_program.jc" 144 44 56# "expl:Integer cast"
      (Int32.of_int (0))))
     \/
     (Int32.(>) a_14 (#"whole_program.jc" 145 44 56# "expl:Integer cast"
     (Int32.of_int (0))))))) });
     (let abs_0 = ref (Unsafe_int64.any_  () ) in
     begin
     (abs_0 :=
      (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 23 9 10#
      "expl:Integer cast" (Unsafe_int64_of_Unsafe_int32.cast  a_14 )));
      (if
      (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 24 7 12#
      (Unsafe_int32.(<)  a_14
       (#"whole_program.jc" 150 27 39# "expl:Integer cast"
       (Unsafe_int32.of_int (0))) ))
      then (abs_0 := (Unsafe_int64.(-_)  !abs_0 )) else ());
      begin (return := !abs_0); (raise Return) end end); absurd  end with
    Return -> !return end)
  
  let spec_abs1_ensures_negative
  #"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 19 5 21#
  "expl:Function spec_abs1, behavior negative" =
  fun (a_14 : Int32.t) 
   requires {
   (Int32.(<) a_14 (#"whole_program.jc" 131 18 30# "expl:Integer cast"
   (Int32.of_int (0)))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 15 15 28#
     "expl:Ensures clause"
     ((=) (Int64.to_int result) (Int.(-_) (Int32.to_int a_14))))) }  ->
   'Init:
   (let return = ref (Unsafe_int64.any_  () ) in
   try
    begin
    (); (); (); ();
     (let abs_0 = ref (Unsafe_int64.any_  () ) in
     begin
     (abs_0 :=
      (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 23 9 10#
      "expl:Integer cast" (Unsafe_int64_of_Unsafe_int32.cast  a_14 )));
      (if
      (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 24 7 12#
      (Unsafe_int32.(<)  a_14
       (#"whole_program.jc" 150 27 39# "expl:Integer cast"
       (Unsafe_int32.of_int (0))) ))
      then (abs_0 := (Unsafe_int64.(-_)  !abs_0 )) else ());
      begin (return := !abs_0); (raise Return) end end); absurd  end with
    Return -> !return end)
  
  let spec_abs1_ensures_positive
  #"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 19 5 21#
  "expl:Function spec_abs1, behavior positive" =
  fun (a_14 : Int32.t) 
   requires {
   (Int32.(>) a_14 (#"whole_program.jc" 124 18 30# "expl:Integer cast"
   (Int32.of_int (0)))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 8 15 27#
     "expl:Ensures clause"
     (Int64.(=) result (#"whole_program.jc" 125 31 55# "expl:Integer cast"
     (Int64_of_Int32.cast a_14))))) }  ->
   'Init:
   (let return = ref (Unsafe_int64.any_  () ) in
   try
    begin
    (); (); (); ();
     (let abs_0 = ref (Unsafe_int64.any_  () ) in
     begin
     (abs_0 :=
      (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 23 9 10#
      "expl:Integer cast" (Unsafe_int64_of_Unsafe_int32.cast  a_14 )));
      (if
      (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 24 7 12#
      (Unsafe_int32.(<)  a_14
       (#"whole_program.jc" 150 27 39# "expl:Integer cast"
       (Unsafe_int32.of_int (0))) ))
      then (abs_0 := (Unsafe_int64.(-_)  !abs_0 )) else ());
      begin (return := !abs_0); (raise Return) end end); absurd  end with
    Return -> !return end)
  
  let spec_abs1_ensures_zero
  #"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 19 5 21#
  "expl:Function spec_abs1, behavior zero" =
  fun (a_14 : Int32.t) 
   requires {
   (Int32.(=) a_14 (#"whole_program.jc" 127 19 31# "expl:Integer cast"
   (Int32.of_int (0)))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 11 15 27#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 11 15 27#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 11 15 27#
      "expl:Ensures clause" ((=) (Int64.to_int result) (0)))
     /\
     (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 12 15 27#
     "expl:Ensures clause"
     (Int64.(=) result (#"whole_program.jc" 129 42 66# "expl:Integer cast"
     (Int64_of_Int32.cast a_14)))))))) }  ->
   'Init:
   (let return = ref (Unsafe_int64.any_  () ) in
   try
    begin
    (); (); (); ();
     (let abs_0 = ref (Unsafe_int64.any_  () ) in
     begin
     (abs_0 :=
      (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 23 9 10#
      "expl:Integer cast" (Unsafe_int64_of_Unsafe_int32.cast  a_14 )));
      (if
      (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 24 7 12#
      (Unsafe_int32.(<)  a_14
       (#"whole_program.jc" 150 27 39# "expl:Integer cast"
       (Unsafe_int32.of_int (0))) ))
      then (abs_0 := (Unsafe_int64.(-_)  !abs_0 )) else ());
      begin (return := !abs_0); (raise Return) end end); absurd  end with
    Return -> !return end)
  
end

theory Axiomatic_ASum

  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function asum (pointer voidP) int (memory voidP Int32.t) :
  int
  
  axiom Asum_init
  #"/home/work/workspace/education/acsl-exam/./array_average.c" 5 7 60#
  "expl:Axiom asum_init" :
  (forall intP_intM_a_2_at_L : (memory voidP Int32.t).
   (#"/home/work/workspace/education/acsl-exam/./array_average.c" 5 7 60#
   (forall a_0_1 : (pointer voidP).
    (forall b_0_1 : int.
     (((<=) b_0_1 (0)) -> ((=) (asum a_0_1 b_0_1 intP_intM_a_2_at_L) (0)))))))
  
  axiom Asum_step_dec
  #"/home/work/workspace/education/acsl-exam/./array_average.c" 8 7 67#
  "expl:Axiom asum_step_dec" :
  (forall intP_intM_a_2_at_L : (memory voidP Int32.t).
   (#"/home/work/workspace/education/acsl-exam/./array_average.c" 8 7 67#
   (forall a_1_0 : (pointer voidP).
    (forall b_1_0 : int.
     ((=) (asum a_1_0 b_1_0 intP_intM_a_2_at_L)
     (Int.(+) (asum a_1_0 (Int.(-) b_1_0 (1)) intP_intM_a_2_at_L)
     (Int32.to_int (select intP_intM_a_2_at_L (shift a_1_0 b_1_0)))))))))
  
end

theory Struct_voidP

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP)) = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_intP

  use import Struct_voidP 
  
  use import core.Jessie_voidp_tag_id 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function intP_tag  : (tag_id voidP)
  
  axiom IntP_parenttag_voidP :
  (parenttag intP_tag voidP_tag)
  
  axiom IntP_is_final :
  (forall voidP_tag_table : (tag_table voidP).
   (forall p : (pointer voidP).
    ((instanceof voidP_tag_table p intP_tag) ->
     ((=) (typeof voidP_tag_table p) intP_tag))))
  
  predicate frame_tag_struct_intP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_intP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_intP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_intP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_intP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_intP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_intP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_intP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) intP_tag)
  
  predicate typeof_struct_intP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) intP_tag))))
  
  predicate instanceof_singleton_struct_intP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p intP_tag)
  
  predicate instanceof_struct_intP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) intP_tag))))
  
  predicate right_valid_struct_intP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_intP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_intP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_intP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
  axiom IntP_int : ((=) (int_of_tag intP_tag) (4))
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Goto__LAND_exc unit
  
  exception Goto__LAND_1_exc unit
  
  exception Goto__LAND_2_exc unit
  
  exception Goto__LAND_3_exc unit
  
  exception Goto__LAND_4_exc unit
  
  exception Goto__LOR_exc unit
  
  exception Goto__LOR_0_exc unit
  
  exception Goto___Cont_exc unit
  
  exception Goto_while_0_break_exc unit
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Function_array_average_safety

  use import Struct_intP 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_ASum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let array_average
  #"/home/work/workspace/education/acsl-exam/./array_average.c" 22 4 36#
  "expl:Function array_average, safety" =
  fun
   (a_0 : (pointer voidP)) (size_0 : Int32.t) (voidP_a_3_alloc_table :
   (alloc_table voidP)) (voidP_a_3_tag_table : (tag_table voidP))
   (intP_intM_a_3 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_3_alloc_table a_0) ->
     (((=) (typeof voidP_a_3_tag_table a_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_3_alloc_table a_0) i) /\
       ((<) i (offset_max voidP_a_3_alloc_table a_0))) ->
       ((=) (typeof voidP_a_3_tag_table (shift a_0 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 176 12 965#
   ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 16 13 21#
    (Int32.(>) size_0 (#"whole_program.jc" 176 31 43# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 176 12 965#
   ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 17 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_0) (1))) then
     (((<=) (offset_min voidP_a_3_alloc_table a_0) (0)) /\
     (((>=) (offset_max voidP_a_3_alloc_table a_0)
      (Int.(-) (Int32.to_int size_0) (1)))
     /\
     (forall __framac_tmp1 : int.
      ((((<=) (0) __framac_tmp1) /\
       ((<=) __framac_tmp1 (Int.(-) (Int32.to_int size_0) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 176 12 965#
   ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 18 13 43#
    ((<=) (Int.(-_) (2147483648))
    (asum a_0 (Int.(-) (Int32.to_int size_0) (1)) intP_intM_a_3)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./array_average.c" 18 28 57#
   ((<=) (asum a_0 (Int.(-) (Int32.to_int size_0) (1)) intP_intM_a_3)
   (2147483647)))))))))) } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_int32.any_  () ) in
   try
    begin
    (let i_3 = ref (Safe_int32.any_  () ) in
    (let sum_0_0 = ref (Safe_int32.any_  () ) in
    (let __retres = ref (Safe_int32.any_  () ) in
    try
     begin
     (sum_0_0 :=
      (let _jessie_105 =
      (#"whole_program.jc" 204 24 36# "expl:Integer cast"
      (Safe_int32.of_int (0))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./array_average.c" 25 3 6#
      "expl:Pointer index bounds" true) }); _jessie_105 end));
      begin
      (i_3 :=
       (let _jessie_102 =
       (#"whole_program.jc" 205 22 34# "expl:Integer cast"
       (Safe_int32.of_int (0))) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./array_average.c" 31 7 12#
       "expl:Pointer index bounds" true) }); _jessie_102 end));
       'Loop_2:
       loop
       invariant { (#"whole_program.jc" 207 6 869# true) }
         variant {
           (#"/home/work/workspace/education/acsl-exam/./array_average.c" 29 20 28#
           (Int.(-) (Int32.to_int size_0) (Int32.to_int !i_3))) }
        begin
        any unit
        requires { true } reads { a_0, size_0 }
        ensures {
          ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 28 22 41#
           ((=) (Int32.to_int !sum_0_0)
           (asum a_0 (Int.(-) (Int32.to_int !i_3) (1)) intP_intM_a_3)))
          /\
          (#"/home/work/workspace/education/acsl-exam/./array_average.c" 27 22 36#
          (#"/home/work/workspace/education/acsl-exam/./array_average.c" 27 22 36#
          ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 27 22 28#
           (Int32.(<=) (#"whole_program.jc" 209 38 50# "expl:Integer cast"
           (Int32.of_int (0))) !i_3))
          /\
          (#"/home/work/workspace/education/acsl-exam/./array_average.c" 27 27 36#
          (Int32.(<=) !i_3 size_0)))))) } ;
         try
          begin
          begin
          (if
          (#"/home/work/workspace/education/acsl-exam/./array_average.c" 31 14 22#
          (Safe_int32.(<)  !i_3 size_0 )) then ()
          else (raise (Goto_while_0_break_exc ())));
           begin
           (sum_0_0 :=
            (let _jessie_103 =
            (Safe_int32.(+)  !sum_0_0
             (#"/home/work/workspace/education/acsl-exam/./array_average.c" 32 13 17#
             "expl:Pointer dereference"
             (acc_offset_typesafe  voidP_a_3_alloc_table intP_intM_a_3 a_0
              (Safe_int32.to_int  !i_3 ) )) ) in
            begin
            (assert {
            (#"/home/work/workspace/education/acsl-exam/./array_average.c" 32 6 17#
            "expl:Pointer index bounds" true) }); _jessie_103 end));
            (i_3 :=
             (let _jessie_104 =
             (Safe_int32.(+)  !i_3
              (#"whole_program.jc" 223 54 66# "expl:Integer cast"
              (Safe_int32.of_int (1))) ) in
             begin
             (assert {
             (#"/home/work/workspace/education/acsl-exam/./array_average.c" 31 24 27#
             "expl:Pointer index bounds" true) }); _jessie_104 end)) end end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
      end end with Goto_while_0_break_exc _jessie_1 ->
     'While_0_break:
     'While_0_break:
     begin
     ();
      begin
      (__retres :=
       (let _jessie_106 =
       (#"/home/work/workspace/education/acsl-exam/./array_average.c" 35 10 20#
       "expl:Division by zero" (Safe_int32.(/)  !sum_0_0 size_0 )) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./array_average.c" 35 3 21#
       "expl:Pointer index bounds" true) }); _jessie_106 end));
       begin
       (return :=
        (let _jessie_107 = !__retres in
        begin
        (assert {
        (#"whole_program.jc" 229 7 22# "expl:Pointer index bounds" true) });
         _jessie_107 end)); (raise Return) end end end end))); absurd  end
    with Return -> !return end)
  
end

module Function_array_average_behaviors

  use Unsafe_int32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use import Axiomatic_ASum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let array_average_ensures_default
  #"/home/work/workspace/education/acsl-exam/./array_average.c" 22 4 36#
  "expl:Function array_average, default behavior" =
  fun
   (a_0 : (pointer voidP)) (size_0 : Int32.t) (voidP_a_3_alloc_table :
   (alloc_table voidP)) (voidP_a_3_tag_table : (tag_table voidP))
   (intP_intM_a_3 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_3_alloc_table a_0) ->
     (((=) (typeof voidP_a_3_tag_table a_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_3_alloc_table a_0) i) /\
       ((<) i (offset_max voidP_a_3_alloc_table a_0))) ->
       ((=) (typeof voidP_a_3_tag_table (shift a_0 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 176 12 965#
   ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 16 13 21#
    (Int32.(>) size_0 (#"whole_program.jc" 176 31 43# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 176 12 965#
   ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 17 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_0) (1))) then
     (((<=) (offset_min voidP_a_3_alloc_table a_0) (0)) /\
     (((>=) (offset_max voidP_a_3_alloc_table a_0)
      (Int.(-) (Int32.to_int size_0) (1)))
     /\
     (forall __framac_tmp1 : int.
      ((((<=) (0) __framac_tmp1) /\
       ((<=) __framac_tmp1 (Int.(-) (Int32.to_int size_0) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 176 12 965#
   ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 18 13 43#
    ((<=) (Int.(-_) (2147483648))
    (asum a_0 (Int.(-) (Int32.to_int size_0) (1)) intP_intM_a_3)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./array_average.c" 18 28 57#
   ((<=) (asum a_0 (Int.(-) (Int32.to_int size_0) (1)) intP_intM_a_3)
   (2147483647)))))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./array_average.c" 20 12 47#
     "expl:Ensures clause"
     ((=) (Int32.to_int result)
     (ComputerDivision.div
     (asum a_0 (Int.(-) (Int32.to_int size_0) (1)) intP_intM_a_3)
     (Int32.to_int size_0))))) } diverges  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (let i_3 = ref (Unsafe_int32.any_  () ) in
    (let sum_0_0 = ref (Unsafe_int32.any_  () ) in
    (let __retres = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (sum_0_0 :=
      (#"whole_program.jc" 204 24 36# "expl:Integer cast"
      (Unsafe_int32.of_int (0))));
      begin
      (i_3 :=
       (#"whole_program.jc" 205 22 34# "expl:Integer cast"
       (Unsafe_int32.of_int (0))));
       'Loop_1:
       loop
       invariant
         { ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 27 22 36#
            (#"/home/work/workspace/education/acsl-exam/./array_average.c" 27 22 36#
            ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 27 22 28#
             (Int32.(<=) (#"whole_program.jc" 209 38 50# "expl:Integer cast"
             (Int32.of_int (0))) !i_3))
            /\
            (#"/home/work/workspace/education/acsl-exam/./array_average.c" 27 27 36#
            (Int32.(<=) !i_3 size_0)))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./array_average.c" 28 22 41#
           ((=) (Int32.to_int !sum_0_0)
           (asum a_0 (Int.(-) (Int32.to_int !i_3) (1)) intP_intM_a_3)))) } 
         
        begin
        any unit requires { true } ensures { true } ;
         try
          begin
          begin
          (if
          (#"/home/work/workspace/education/acsl-exam/./array_average.c" 31 14 22#
          (Unsafe_int32.(<)  !i_3 size_0 )) then ()
          else (raise (Goto_while_0_break_exc ())));
           begin
           (sum_0_0 :=
            (Unsafe_int32.(+)  !sum_0_0
             (acc  intP_intM_a_3 (shift_  a_0 (Unsafe_int32.to_int  !i_3 ) )
              ) ));
            (i_3 :=
             (Unsafe_int32.(+)  !i_3
              (#"whole_program.jc" 223 54 66# "expl:Integer cast"
              (Unsafe_int32.of_int (1))) )) end end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
      end end with Goto_while_0_break_exc _jessie_1 ->
     'While_0_break:
     'While_0_break:
     begin
     ();
      begin
      (__retres := (Unsafe_int32.(/)  !sum_0_0 size_0 ));
       begin (return := !__retres); (raise Return) end end end end))); 
     absurd  end with Return -> !return end)
  
end

theory Root_unsigned_intP

  use why3.Bool.Bool 
  
  type unsigned_intP 
  
end

theory Axiomatic_Array_Sum

  use enum.Uint32 
  
  use import Root_unsigned_intP 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function array_sum (pointer unsigned_intP) int (memory unsigned_intP
  Uint32.t) : int
  
  axiom Array_sum_init
  #"/home/work/workspace/education/acsl-exam/./array_sum.c" 5 7 70#
  "expl:Axiom array_sum_init" :
  (forall unsigned_intP_unsigned_intM_a_2_4_at_L : (memory unsigned_intP
   Uint32.t).
   (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 5 7 70#
   (forall a_3_0 : (pointer unsigned_intP).
    (forall b_3_0 : int.
     (((<=) b_3_0 (0)) ->
      ((=) (array_sum a_3_0 b_3_0 unsigned_intP_unsigned_intM_a_2_4_at_L)
      (0)))))))
  
  axiom Array_sum_step_dec
  #"/home/work/workspace/education/acsl-exam/./array_sum.c" 8 7 82#
  "expl:Axiom array_sum_step_dec" :
  (forall unsigned_intP_unsigned_intM_a_2_4_at_L : (memory unsigned_intP
   Uint32.t).
   (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 8 7 82#
   (forall a_4_0 : (pointer unsigned_intP).
    (forall b_4_0 : int.
     ((=) (array_sum a_4_0 b_4_0 unsigned_intP_unsigned_intM_a_2_4_at_L)
     (Int.(+)
     (array_sum a_4_0 (Int.(-) b_4_0 (1))
     unsigned_intP_unsigned_intM_a_2_4_at_L)
     (Uint32.to_int
     (select unsigned_intP_unsigned_intM_a_2_4_at_L (shift a_4_0 b_4_0)))))))))
  
  lemma Array_sum_lower_bound
  #"/home/work/workspace/education/acsl-exam/./array_sum.c" 11 7 59#
  "expl:Lemma array_sum_lower_bound" :
  (forall unsigned_intP_unsigned_intM_a_2_4_at_L : (memory unsigned_intP
   Uint32.t).
   (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 11 7 59#
   (forall a_5_0 : (pointer unsigned_intP).
    (forall b_5 : int.
     ((>=) (array_sum a_5_0 b_5 unsigned_intP_unsigned_intM_a_2_4_at_L) (0))))))
  
  lemma Array_sum_increases
  #"/home/work/workspace/education/acsl-exam/./array_sum.c" 14 7 92#
  "expl:Lemma array_sum_increases" :
  (forall unsigned_intP_unsigned_intM_a_2_4_at_L : (memory unsigned_intP
   Uint32.t).
   (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 14 7 92#
   (forall a_6_0 : (pointer unsigned_intP).
    (forall i_1_0 : int.
     (forall b_6 : int.
      ((((<=) (0) i_1_0) /\ ((<=) i_1_0 b_6)) ->
       ((<=) (array_sum a_6_0 i_1_0 unsigned_intP_unsigned_intM_a_2_4_at_L)
       (array_sum a_6_0 b_6 unsigned_intP_unsigned_intM_a_2_4_at_L))))))))
  
end

theory Struct_unsigned_intP

  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function unsigned_intP_tag  : (tag_id
  unsigned_intP)
  
  axiom Unsigned_intP_parenttag_bottom :
  (parenttag unsigned_intP_tag bottom_tag)
  
  axiom Unsigned_intP_is_final :
  (forall unsigned_intP_tag_table : (tag_table unsigned_intP).
   (forall p : (pointer unsigned_intP).
    ((instanceof unsigned_intP_tag_table p unsigned_intP_tag) ->
     ((=) (typeof unsigned_intP_tag_table p) unsigned_intP_tag))))
  
  predicate frame_tag_struct_unsigned_intP (p : (pointer unsigned_intP))
  (old_unsigned_intP_tag_table : (tag_table unsigned_intP))
  (unsigned_intP_tag_table : (tag_table unsigned_intP))
  =
     ((tag_extends old_unsigned_intP_tag_table unsigned_intP_tag_table) /\
     (alloc_tag_block old_unsigned_intP_tag_table unsigned_intP_tag_table p))
  
  predicate frame_free_struct_unsigned_intP (p : (pointer unsigned_intP))
  (old_unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  =
     ((free_extends old_unsigned_intP_alloc_table unsigned_intP_alloc_table)
     /\
     (free_block old_unsigned_intP_alloc_table unsigned_intP_alloc_table p))
  
  predicate frame_alloc_struct_unsigned_intP (p : (pointer unsigned_intP)) (n
  : int) (old_unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  =
     ((alloc_extends old_unsigned_intP_alloc_table unsigned_intP_alloc_table)
     /\
     (alloc_block old_unsigned_intP_alloc_table unsigned_intP_alloc_table p
     n))
  
  predicate fresh_tag_struct_unsigned_intP (p : (pointer unsigned_intP))
  (unsigned_intP_tag_table : (tag_table unsigned_intP))
  = (tag_fresh unsigned_intP_tag_table p)
  
  predicate fresh_alloc_struct_unsigned_intP (p : (pointer unsigned_intP))
  (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  = (alloc_fresh unsigned_intP_alloc_table p)
  
  predicate container_of_singleton_struct_unsigned_intP (p : (pointer
  unsigned_intP)) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  = true
  
  predicate container_of_struct_unsigned_intP (p : (pointer unsigned_intP))
  (l : int) (r : int) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  = true
  
  predicate typeof_singleton_struct_unsigned_intP (p : (pointer
  unsigned_intP)) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  = ((=) (typeof unsigned_intP_tag_table p) unsigned_intP_tag)
  
  predicate typeof_struct_unsigned_intP (p : (pointer unsigned_intP)) (l :
  int) (r : int) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  =
     (((=) (typeof unsigned_intP_tag_table p) unsigned_intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof unsigned_intP_tag_table (shift p i)) unsigned_intP_tag))))
  
  predicate instanceof_singleton_struct_unsigned_intP (p : (pointer
  unsigned_intP)) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  = (instanceof unsigned_intP_tag_table p unsigned_intP_tag)
  
  predicate instanceof_struct_unsigned_intP (p : (pointer unsigned_intP)) (l
  : int) (r : int) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  =
     ((instanceof unsigned_intP_tag_table p unsigned_intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof unsigned_intP_tag_table (shift p i) unsigned_intP_tag))))
  
  predicate right_valid_struct_unsigned_intP (p : (pointer unsigned_intP)) (b
  : int) (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  = ((>=) (offset_max unsigned_intP_alloc_table p) b)
  
  predicate left_valid_struct_unsigned_intP (p : (pointer unsigned_intP)) (a
  : int) (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  = ((<=) (offset_min unsigned_intP_alloc_table p) a)
  
  predicate valid_struct_unsigned_intP (p : (pointer unsigned_intP)) (a :
  int) (b : int) (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  =
     (((<=) (offset_min unsigned_intP_alloc_table p) a) /\
     ((>=) (offset_max unsigned_intP_alloc_table p) b))
  
  predicate strict_valid_struct_unsigned_intP (p : (pointer unsigned_intP))
  (a : int) (b : int) (unsigned_intP_alloc_table : (alloc_table
  unsigned_intP))
  =
     (((=) (offset_min unsigned_intP_alloc_table p) a) /\
     ((=) (offset_max unsigned_intP_alloc_table p) b))
  
  axiom Unsigned_intP_int : ((=) (int_of_tag unsigned_intP_tag) (7))
  
end

module Function_array_sum_0_safety

  use enum.Uint32 
  
  use import Struct_unsigned_intP 
  
  use Safe_uint32 
  
  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_offset_safe 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_Array_Sum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let array_sum_0
  #"/home/work/workspace/education/acsl-exam/./array_sum.c" 25 9 44#
  "expl:Function array_sum, safety" =
  fun
   (a_0_0 : (pointer unsigned_intP)) (n_1 : Uint32.t)
   (unsigned_intP_a_0_5_alloc_table : (alloc_table unsigned_intP))
   (unsigned_intP_a_0_5_tag_table : (tag_table unsigned_intP))
   (unsigned_intP_unsigned_intM_a_0_5 : (memory unsigned_intP Uint32.t)) 
   requires {
   (((allocated unsigned_intP_a_0_5_alloc_table a_0_0) ->
     (((=) (typeof unsigned_intP_a_0_5_tag_table a_0_0) unsigned_intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min unsigned_intP_a_0_5_alloc_table a_0_0) i) /\
       ((<) i (offset_max unsigned_intP_a_0_5_alloc_table a_0_0))) ->
       ((=) (typeof unsigned_intP_a_0_5_tag_table (shift a_0_0 i))
       unsigned_intP_tag)))))
   /\
   (#"whole_program.jc" 264 12 695#
   ((#"/home/work/workspace/education/acsl-exam/./array_sum.c" 20 13 31#
    (if ((<=) (0) (Int.(-) (Uint32.to_int n_1) (1))) then
     (((<=) (offset_min unsigned_intP_a_0_5_alloc_table a_0_0) (0)) /\
     (((>=) (offset_max unsigned_intP_a_0_5_alloc_table a_0_0)
      (Int.(-) (Uint32.to_int n_1) (1)))
     /\
     (forall __framac_tmp2 : int.
      ((((<=) (0) __framac_tmp2) /\
       ((<=) __framac_tmp2 (Int.(-) (Uint32.to_int n_1) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 21 13 36#
   ((<)
   (array_sum a_0_0 (Uint32.to_int n_1) unsigned_intP_unsigned_intM_a_0_5)
   (32767)))))) } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_uint32.any_  () ) in
   try
    begin
    (let i_4 = ref (Safe_uint32.any_  () ) in
    (let sum_0_0_0 = ref (Safe_uint32.any_  () ) in
    try
     begin
     (sum_0_0_0 :=
      (let _jessie_116 =
      (#"whole_program.jc" 285 26 39# "expl:Integer cast"
      (Safe_uint32.of_int (0))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 28 3 11#
      "expl:Pointer index bounds" true) }); _jessie_116 end));
      begin
      (i_4 :=
       (let _jessie_113 =
       (#"whole_program.jc" 286 22 35# "expl:Integer cast"
       (Safe_uint32.of_int (0))) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 35 7 12#
       "expl:Pointer index bounds" true) }); _jessie_113 end));
       'Loop_4:
       loop
       invariant { (#"whole_program.jc" 288 6 895# true) }
         variant {
           (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 33 20 25#
           (Int.(-) (Uint32.to_int n_1) (Uint32.to_int !i_4))) }
        begin
        any unit
        requires { true } reads { a_0_0, n_1 }
        ensures {
          ((#"/home/work/workspace/education/acsl-exam/./array_sum.c" 31 22 46#
           ((=) (Uint32.to_int !sum_0_0_0)
           (array_sum a_0_0 (Int.(-) (Uint32.to_int !i_4) (1))
           unsigned_intP_unsigned_intM_a_0_5)))
          /\
          (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 30 22 33#
          (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 30 22 33#
          ((#"/home/work/workspace/education/acsl-exam/./array_sum.c" 30 22 28#
           ((<=) (0) (Uint32.to_int !i_4)))
          /\
          (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 30 27 33#
          (Uint32.(<=) !i_4 n_1)))))) } ;
         try
          begin
          begin
          (if
          (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 35 14 19#
          (Safe_uint32.(<)  !i_4 n_1 )) then ()
          else (raise (Goto_while_0_break_exc ())));
           begin
           (sum_0_0_0 :=
            (let _jessie_114 =
            (Safe_uint32.(+)  !sum_0_0_0
             (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 36 13 17#
             "expl:Pointer dereference"
             (acc_offset_typesafe  unsigned_intP_a_0_5_alloc_table
              unsigned_intP_unsigned_intM_a_0_5 a_0_0
              (Safe_uint32.to_int  !i_4 ) )) ) in
            begin
            (assert {
            (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 36 6 17#
            "expl:Pointer index bounds" true) }); _jessie_114 end));
            (i_4 :=
             (let _jessie_115 =
             (Safe_uint32.(+)  !i_4
              (#"whole_program.jc" 304 54 67# "expl:Integer cast"
              (Safe_uint32.of_int (1))) ) in
             begin
             (assert {
             (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 35 21 24#
             "expl:Pointer index bounds" true) }); _jessie_115 end)) end end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_6 -> () end end end; (raise (Goto_while_0_break_exc ()))
      end end with Goto_while_0_break_exc _jessie_4 ->
     'While_0_break:
     'While_0_break:
     begin
     ();
      begin
      (return :=
       (let _jessie_117 = !sum_0_0_0 in
       begin
       (assert {
       (#"whole_program.jc" 309 7 21# "expl:Pointer index bounds" true) });
        _jessie_117 end)); (raise Return) end end end)); absurd  end with
    Return -> !return end)
  
end

module Function_array_sum_0_behaviors

  use Unsafe_uint32 
  
  use enum.Uint32 
  
  use import Struct_unsigned_intP 
  
  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_Array_Sum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let array_sum_ensures_default
  #"/home/work/workspace/education/acsl-exam/./array_sum.c" 25 9 44#
  "expl:Function array_sum, default behavior" =
  fun
   (a_0_0 : (pointer unsigned_intP)) (n_1 : Uint32.t)
   (unsigned_intP_a_0_5_alloc_table : (alloc_table unsigned_intP))
   (unsigned_intP_a_0_5_tag_table : (tag_table unsigned_intP))
   (unsigned_intP_unsigned_intM_a_0_5 : (memory unsigned_intP Uint32.t)) 
   requires {
   (((allocated unsigned_intP_a_0_5_alloc_table a_0_0) ->
     (((=) (typeof unsigned_intP_a_0_5_tag_table a_0_0) unsigned_intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min unsigned_intP_a_0_5_alloc_table a_0_0) i) /\
       ((<) i (offset_max unsigned_intP_a_0_5_alloc_table a_0_0))) ->
       ((=) (typeof unsigned_intP_a_0_5_tag_table (shift a_0_0 i))
       unsigned_intP_tag)))))
   /\
   (#"whole_program.jc" 264 12 695#
   ((#"/home/work/workspace/education/acsl-exam/./array_sum.c" 20 13 31#
    (if ((<=) (0) (Int.(-) (Uint32.to_int n_1) (1))) then
     (((<=) (offset_min unsigned_intP_a_0_5_alloc_table a_0_0) (0)) /\
     (((>=) (offset_max unsigned_intP_a_0_5_alloc_table a_0_0)
      (Int.(-) (Uint32.to_int n_1) (1)))
     /\
     (forall __framac_tmp2 : int.
      ((((<=) (0) __framac_tmp2) /\
       ((<=) __framac_tmp2 (Int.(-) (Uint32.to_int n_1) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 21 13 36#
   ((<)
   (array_sum a_0_0 (Uint32.to_int n_1) unsigned_intP_unsigned_intM_a_0_5)
   (32767)))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 23 12 40#
     "expl:Ensures clause"
     ((=) (Uint32.to_int result)
     (array_sum a_0_0 (Int.(-) (Uint32.to_int n_1) (1))
     unsigned_intP_unsigned_intM_a_0_5)))) } diverges  ->
   'Init:
   (let return = ref (Unsafe_uint32.any_  () ) in
   try
    begin
    (let i_4 = ref (Unsafe_uint32.any_  () ) in
    (let sum_0_0_0 = ref (Unsafe_uint32.any_  () ) in
    try
     begin
     (sum_0_0_0 :=
      (#"whole_program.jc" 285 26 39# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))));
      begin
      (i_4 :=
       (#"whole_program.jc" 286 22 35# "expl:Integer cast"
       (Unsafe_uint32.of_int (0))));
       'Loop_3:
       loop
       invariant
         { ((#"/home/work/workspace/education/acsl-exam/./array_sum.c" 30 22 33#
            (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 30 22 33#
            ((#"/home/work/workspace/education/acsl-exam/./array_sum.c" 30 22 28#
             ((<=) (0) (Uint32.to_int !i_4)))
            /\
            (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 30 27 33#
            (Uint32.(<=) !i_4 n_1)))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 31 22 46#
           ((=) (Uint32.to_int !sum_0_0_0)
           (array_sum a_0_0 (Int.(-) (Uint32.to_int !i_4) (1))
           unsigned_intP_unsigned_intM_a_0_5)))) } 
        begin
        any unit requires { true } ensures { true } ;
         try
          begin
          begin
          (if
          (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 35 14 19#
          (Unsafe_uint32.(<)  !i_4 n_1 )) then ()
          else (raise (Goto_while_0_break_exc ())));
           begin
           (sum_0_0_0 :=
            (Unsafe_uint32.(+)  !sum_0_0_0
             (acc  unsigned_intP_unsigned_intM_a_0_5
              (shift_  a_0_0 (Unsafe_uint32.to_int  !i_4 ) ) ) ));
            (i_4 :=
             (Unsafe_uint32.(+)  !i_4
              (#"whole_program.jc" 304 54 67# "expl:Integer cast"
              (Unsafe_uint32.of_int (1))) )) end end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_6 -> () end end end; (raise (Goto_while_0_break_exc ()))
      end end with Goto_while_0_break_exc _jessie_4 ->
     'While_0_break:
     'While_0_break:
     begin (); begin (return := !sum_0_0_0); (raise Return) end end end));
     absurd  end with Return -> !return end)
  
end

module Function_arrays_average_safety

  use import Struct_intP 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_offset_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let arrays_average
  #"/home/work/workspace/education/acsl-exam/./arrays_average.c" 12 5 61#
  "expl:Function arrays_average, safety" =
  fun
   (result_0 : (pointer voidP)) (a_1 : (pointer voidP)) (b_0 : (pointer
   voidP)) (size_1 : Int32.t) (intP_intM_result_6 : ref (memory voidP
   Int32.t)) (voidP_result_6_alloc_table : (alloc_table voidP))
   (voidP_a_1_7_alloc_table : (alloc_table voidP)) (voidP_b_8_alloc_table :
   (alloc_table voidP)) (voidP_b_8_tag_table : (tag_table voidP))
   (voidP_a_1_7_tag_table : (tag_table voidP)) (voidP_result_6_tag_table :
   (tag_table voidP)) (intP_intM_a_1_7 : (memory voidP Int32.t))
   (intP_intM_b_8 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_b_8_alloc_table b_0) ->
     (((=) (typeof voidP_b_8_tag_table b_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_b_8_alloc_table b_0) i) /\
       ((<) i (offset_max voidP_b_8_alloc_table b_0))) ->
       ((=) (typeof voidP_b_8_tag_table (shift b_0 i)) intP_tag)))))
   /\
   (((allocated voidP_a_1_7_alloc_table a_1) ->
     (((=) (typeof voidP_a_1_7_tag_table a_1) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_1_7_alloc_table a_1) i) /\
       ((<) i (offset_max voidP_a_1_7_alloc_table a_1))) ->
       ((=) (typeof voidP_a_1_7_tag_table (shift a_1 i)) intP_tag)))))
   /\
   (((allocated voidP_result_6_alloc_table result_0) ->
     (((=) (typeof voidP_result_6_tag_table result_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_result_6_alloc_table result_0) i) /\
       ((<) i (offset_max voidP_result_6_alloc_table result_0))) ->
       ((=) (typeof voidP_result_6_tag_table (shift result_0 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 314 12 2620#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 4 13 22#
    (Int32.(>=) size_1 (#"whole_program.jc" 314 33 45# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 314 12 2620#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 5 13 39#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_1) (1))) then
     (((<=) (offset_min voidP_result_6_alloc_table result_0) (0)) /\
     (((>=) (offset_max voidP_result_6_alloc_table result_0)
      (Int.(-) (Int32.to_int size_1) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Int32.to_int size_1) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 314 12 2620#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 6 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_1) (1))) then
     (((<=) (offset_min voidP_a_1_7_alloc_table a_1) (0)) /\
     (((>=) (offset_max voidP_a_1_7_alloc_table a_1)
      (Int.(-) (Int32.to_int size_1) (1)))
     /\
     (forall __framac_tmp4 : int.
      ((((<=) (0) __framac_tmp4) /\
       ((<=) __framac_tmp4 (Int.(-) (Int32.to_int size_1) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 314 12 2620#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 7 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_1) (1))) then
     (((<=) (offset_min voidP_b_8_alloc_table b_0) (0)) /\
     (((>=) (offset_max voidP_b_8_alloc_table b_0)
      (Int.(-) (Int32.to_int size_1) (1)))
     /\
     (forall __framac_tmp5 : int.
      ((((<=) (0) __framac_tmp5) /\
       ((<=) __framac_tmp5 (Int.(-) (Int32.to_int size_1) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 8 13 90#
   (forall i_2_0 : int.
    ((((<=) (0) i_2_0) /\ ((<) i_2_0 (Int32.to_int size_1))) ->
     (((<=) (Int.(-_) (2147483648))
      (Int.(+) (Int32.to_int (select intP_intM_a_1_7 (shift a_1 i_2_0)))
      (Int32.to_int (select intP_intM_b_8 (shift b_0 i_2_0)))))
     /\
     ((<=)
     (Int.(+) (Int32.to_int (select intP_intM_a_1_7 (shift a_1 i_2_0)))
     (Int32.to_int (select intP_intM_b_8 (shift b_0 i_2_0)))) (2147483647)))))))))))))))))
   } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let i_5 = ref (Safe_int32.any_  () ) in
    try
     begin
     (i_5 :=
      (let _jessie_125 =
      (#"whole_program.jc" 364 22 34# "expl:Integer cast"
      (Safe_int32.of_int (0))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 19 7 12#
      "expl:Pointer index bounds" true) }); _jessie_125 end));
      'Loop_6:
      loop
      invariant { (#"whole_program.jc" 366 6 1860# true) }
        variant {
          (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 17 20 28#
          (Int.(-) (Int32.to_int size_1) (Int32.to_int !i_5))) }
       begin
       any unit
       requires { true } reads { a_1, b_0, intP_intM_result_6, result_0,
       size_1 }
       ensures {
         ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 16 22 86#
          (forall j_0 : int.
           ((((<=) (0) j_0) /\ ((<) j_0 (Int32.to_int !i_5))) ->
            ((=)
            (Int32.to_int (select !intP_intM_result_6 (shift result_0 j_0)))
            (ComputerDivision.div
            (Int.(+) (Int32.to_int (select intP_intM_a_1_7 (shift a_1 j_0)))
            (Int32.to_int (select intP_intM_b_8 (shift b_0 j_0)))) (2))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 15 22 36#
         (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 15 22 36#
         ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 15 22 28#
          (Int32.(<=) (#"whole_program.jc" 368 38 50# "expl:Integer cast"
          (Int32.of_int (0))) !i_5))
         /\
         (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 15 27 36#
         (Int32.(<=) !i_5 size_1)))))) } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 19 14 22#
         (Safe_int32.(<)  !i_5 size_1 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          begin
          (let _jessie_127 =
          (let _jessie_126 =
          (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 20 18 35#
          "expl:Division by zero"
          (Safe_int32.(/) 
           (Safe_int32.(+) 
            (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 20 19 23#
            "expl:Pointer dereference"
            (acc_offset_typesafe  voidP_a_1_7_alloc_table intP_intM_a_1_7 a_1
             (Safe_int32.to_int  !i_5 ) ))
            (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 20 26 30#
            "expl:Pointer dereference"
            (acc_offset_typesafe  voidP_b_8_alloc_table intP_intM_b_8 b_0
             (Safe_int32.to_int  !i_5 ) )) )
           (#"whole_program.jc" 394 66 78# "expl:Integer cast"
           (Safe_int32.of_int (2))) )) in
          begin
          (assert {
          (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 20 6 35#
          "expl:Pointer index bounds" true) }); _jessie_126 end) in
          (let _jessie_128 = result_0 in
          (let _jessie_129 = (Safe_int32.to_int  !i_5 ) in
          (let _jessie_130 = (shift_typesafe  _jessie_128 _jessie_129 ) in
          (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 20 6 35#
          "expl:Pointer dereference"
          (upd_offset_typesafe  voidP_result_6_alloc_table intP_intM_result_6
           _jessie_128 _jessie_129 _jessie_127 ))))));
           (i_5 :=
            (let _jessie_131 =
            (Safe_int32.(+)  !i_5
             (#"whole_program.jc" 395 56 68# "expl:Integer cast"
             (Safe_int32.of_int (1))) ) in
            begin
            (assert {
            (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 19 24 27#
            "expl:Pointer index bounds" true) }); _jessie_131 end)) end end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc _jessie_9
         -> () end end end; (raise (Goto_while_0_break_exc ())) end with
     Goto_while_0_break_exc _jessie_7 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_arrays_average_behaviors

  use Unsafe_int32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let arrays_average_ensures_default
  #"/home/work/workspace/education/acsl-exam/./arrays_average.c" 12 5 61#
  "expl:Function arrays_average, default behavior" =
  fun
   (result_0 : (pointer voidP)) (a_1 : (pointer voidP)) (b_0 : (pointer
   voidP)) (size_1 : Int32.t) (intP_intM_result_6 : ref (memory voidP
   Int32.t)) (voidP_result_6_alloc_table : (alloc_table voidP))
   (voidP_a_1_7_alloc_table : (alloc_table voidP)) (voidP_b_8_alloc_table :
   (alloc_table voidP)) (voidP_b_8_tag_table : (tag_table voidP))
   (voidP_a_1_7_tag_table : (tag_table voidP)) (voidP_result_6_tag_table :
   (tag_table voidP)) (intP_intM_a_1_7 : (memory voidP Int32.t))
   (intP_intM_b_8 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_b_8_alloc_table b_0) ->
     (((=) (typeof voidP_b_8_tag_table b_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_b_8_alloc_table b_0) i) /\
       ((<) i (offset_max voidP_b_8_alloc_table b_0))) ->
       ((=) (typeof voidP_b_8_tag_table (shift b_0 i)) intP_tag)))))
   /\
   (((allocated voidP_a_1_7_alloc_table a_1) ->
     (((=) (typeof voidP_a_1_7_tag_table a_1) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_1_7_alloc_table a_1) i) /\
       ((<) i (offset_max voidP_a_1_7_alloc_table a_1))) ->
       ((=) (typeof voidP_a_1_7_tag_table (shift a_1 i)) intP_tag)))))
   /\
   (((allocated voidP_result_6_alloc_table result_0) ->
     (((=) (typeof voidP_result_6_tag_table result_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_result_6_alloc_table result_0) i) /\
       ((<) i (offset_max voidP_result_6_alloc_table result_0))) ->
       ((=) (typeof voidP_result_6_tag_table (shift result_0 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 314 12 2620#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 4 13 22#
    (Int32.(>=) size_1 (#"whole_program.jc" 314 33 45# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 314 12 2620#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 5 13 39#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_1) (1))) then
     (((<=) (offset_min voidP_result_6_alloc_table result_0) (0)) /\
     (((>=) (offset_max voidP_result_6_alloc_table result_0)
      (Int.(-) (Int32.to_int size_1) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Int32.to_int size_1) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 314 12 2620#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 6 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_1) (1))) then
     (((<=) (offset_min voidP_a_1_7_alloc_table a_1) (0)) /\
     (((>=) (offset_max voidP_a_1_7_alloc_table a_1)
      (Int.(-) (Int32.to_int size_1) (1)))
     /\
     (forall __framac_tmp4 : int.
      ((((<=) (0) __framac_tmp4) /\
       ((<=) __framac_tmp4 (Int.(-) (Int32.to_int size_1) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 314 12 2620#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 7 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_1) (1))) then
     (((<=) (offset_min voidP_b_8_alloc_table b_0) (0)) /\
     (((>=) (offset_max voidP_b_8_alloc_table b_0)
      (Int.(-) (Int32.to_int size_1) (1)))
     /\
     (forall __framac_tmp5 : int.
      ((((<=) (0) __framac_tmp5) /\
       ((<=) __framac_tmp5 (Int.(-) (Int32.to_int size_1) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 8 13 90#
   (forall i_2_0 : int.
    ((((<=) (0) i_2_0) /\ ((<) i_2_0 (Int32.to_int size_1))) ->
     (((<=) (Int.(-_) (2147483648))
      (Int.(+) (Int32.to_int (select intP_intM_a_1_7 (shift a_1 i_2_0)))
      (Int32.to_int (select intP_intM_b_8 (shift b_0 i_2_0)))))
     /\
     ((<=)
     (Int.(+) (Int32.to_int (select intP_intM_a_1_7 (shift a_1 i_2_0)))
     (Int32.to_int (select intP_intM_b_8 (shift b_0 i_2_0)))) (2147483647)))))))))))))))))
   }
   ensures {
     ("expl:Postcondition"
     ((#"whole_program.jc" 354 10 56# "expl:Assigns clause"
      (not_assigns voidP_result_6_alloc_table voidP_result_6_alloc_table (old
      !intP_intM_result_6) !intP_intM_result_6
      (pset_range (pset_singleton result_0) (0)
      (Int.(-) (Int32.to_int size_1) (1)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 10 12 79#
     "expl:Ensures clause"
     (forall i_3_0 : int.
      ((((<=) (0) i_3_0) /\ ((<) i_3_0 (Int32.to_int size_1))) ->
       ((=)
       (Int32.to_int (select !intP_intM_result_6 (shift result_0 i_3_0)))
       (ComputerDivision.div
       (Int.(+) (Int32.to_int (select intP_intM_a_1_7 (shift a_1 i_3_0)))
       (Int32.to_int (select intP_intM_b_8 (shift b_0 i_3_0)))) (2)))))))) }
   diverges  ->
   'Init:
   try
    begin
    (let i_5 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (i_5 :=
      (#"whole_program.jc" 364 22 34# "expl:Integer cast"
      (Unsafe_int32.of_int (0))));
      'Loop_5:
      loop
      invariant
        { (((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 15 22 36#
            (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 15 22 36#
            ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 15 22 28#
             (Int32.(<=) (#"whole_program.jc" 368 38 50# "expl:Integer cast"
             (Int32.of_int (0))) !i_5))
            /\
            (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 15 27 36#
            (Int32.(<=) !i_5 size_1)))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 16 22 86#
           (forall j_0 : int.
            ((((<=) (0) j_0) /\ ((<) j_0 (Int32.to_int !i_5))) ->
             ((=)
             (Int32.to_int (select !intP_intM_result_6 (shift result_0 j_0)))
             (ComputerDivision.div
             (Int.(+) (Int32.to_int (select intP_intM_a_1_7 (shift a_1 j_0)))
             (Int32.to_int (select intP_intM_b_8 (shift b_0 j_0)))) (2)))))))
          /\
          (#"whole_program.jc" 354 10 56# "expl:Assigns clause"
          (not_assigns voidP_result_6_alloc_table voidP_result_6_alloc_table
          (at !intP_intM_result_6 'Init) !intP_intM_result_6
          (pset_range (pset_singleton result_0) (0)
          (Int.(-) (Int32.to_int size_1) (1)))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 19 14 22#
         (Unsafe_int32.(<)  !i_5 size_1 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          begin
          (let _jessie_120 =
          (Unsafe_int32.(/) 
           (Unsafe_int32.(+) 
            (acc  intP_intM_a_1_7 (shift_  a_1 (Unsafe_int32.to_int  !i_5 ) )
             )
            (acc  intP_intM_b_8 (shift_  b_0 (Unsafe_int32.to_int  !i_5 ) ) )
            )
           (#"whole_program.jc" 394 66 78# "expl:Integer cast"
           (Unsafe_int32.of_int (2))) ) in
          (let _jessie_121 = result_0 in
          (let _jessie_122 = (Unsafe_int32.to_int  !i_5 ) in
          (let _jessie_123 = (shift_  _jessie_121 _jessie_122 ) in
          (upd  intP_intM_result_6 _jessie_123 _jessie_120 )))));
           (i_5 :=
            (Unsafe_int32.(+)  !i_5
             (#"whole_program.jc" 395 56 68# "expl:Integer cast"
             (Unsafe_int32.of_int (1))) )) end end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc _jessie_9
         -> () end end end; (raise (Goto_while_0_break_exc ())) end with
     Goto_while_0_break_exc _jessie_7 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_arrays_sum_safety

  use import Struct_intP 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_offset_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let arrays_sum
  #"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 13 5 57#
  "expl:Function arrays_sum, safety" =
  fun
   (result_0_0 : (pointer voidP)) (a_2_0 : (pointer voidP)) (b_0_0 : (pointer
   voidP)) (size_2 : Int32.t) (intP_intM_result_0_9 : ref (memory voidP
   Int32.t)) (voidP_result_0_9_alloc_table : (alloc_table voidP))
   (voidP_a_2_10_alloc_table : (alloc_table voidP)) (voidP_b_0_11_alloc_table
   : (alloc_table voidP)) (voidP_b_0_11_tag_table : (tag_table voidP))
   (voidP_a_2_10_tag_table : (tag_table voidP)) (voidP_result_0_9_tag_table :
   (tag_table voidP)) (intP_intM_a_2_10 : (memory voidP Int32.t))
   (intP_intM_b_0_11 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_b_0_11_alloc_table b_0_0) ->
     (((=) (typeof voidP_b_0_11_tag_table b_0_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_b_0_11_alloc_table b_0_0) i) /\
       ((<) i (offset_max voidP_b_0_11_alloc_table b_0_0))) ->
       ((=) (typeof voidP_b_0_11_tag_table (shift b_0_0 i)) intP_tag)))))
   /\
   (((allocated voidP_a_2_10_alloc_table a_2_0) ->
     (((=) (typeof voidP_a_2_10_tag_table a_2_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_2_10_alloc_table a_2_0) i) /\
       ((<) i (offset_max voidP_a_2_10_alloc_table a_2_0))) ->
       ((=) (typeof voidP_a_2_10_tag_table (shift a_2_0 i)) intP_tag)))))
   /\
   (((allocated voidP_result_0_9_alloc_table result_0_0) ->
     (((=) (typeof voidP_result_0_9_tag_table result_0_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_result_0_9_alloc_table result_0_0) i) /\
       ((<) i (offset_max voidP_result_0_9_alloc_table result_0_0))) ->
       ((=) (typeof voidP_result_0_9_tag_table (shift result_0_0 i))
       intP_tag)))))
   /\
   (#"whole_program.jc" 405 12 2664#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 5 13 22#
    (Int32.(>=) size_2 (#"whole_program.jc" 405 33 45# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 405 12 2664#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 6 13 39#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
     (((<=) (offset_min voidP_result_0_9_alloc_table result_0_0) (0)) /\
     (((>=) (offset_max voidP_result_0_9_alloc_table result_0_0)
      (Int.(-) (Int32.to_int size_2) (1)))
     /\
     (forall __framac_tmp6 : int.
      ((((<=) (0) __framac_tmp6) /\
       ((<=) __framac_tmp6 (Int.(-) (Int32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 405 12 2664#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 7 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
     (((<=) (offset_min voidP_a_2_10_alloc_table a_2_0) (0)) /\
     (((>=) (offset_max voidP_a_2_10_alloc_table a_2_0)
      (Int.(-) (Int32.to_int size_2) (1)))
     /\
     (forall __framac_tmp7 : int.
      ((((<=) (0) __framac_tmp7) /\
       ((<=) __framac_tmp7 (Int.(-) (Int32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 405 12 2664#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 8 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
     (((<=) (offset_min voidP_b_0_11_alloc_table b_0_0) (0)) /\
     (((>=) (offset_max voidP_b_0_11_alloc_table b_0_0)
      (Int.(-) (Int32.to_int size_2) (1)))
     /\
     (forall __framac_tmp8 : int.
      ((((<=) (0) __framac_tmp8) /\
       ((<=) __framac_tmp8 (Int.(-) (Int32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 9 13 90#
   (forall i_4_0 : int.
    ((((<=) (0) i_4_0) /\ ((<) i_4_0 (Int32.to_int size_2))) ->
     (((<=) (Int.(-_) (2147483648))
      (Int.(+) (Int32.to_int (select intP_intM_a_2_10 (shift a_2_0 i_4_0)))
      (Int32.to_int (select intP_intM_b_0_11 (shift b_0_0 i_4_0)))))
     /\
     ((<=)
     (Int.(+) (Int32.to_int (select intP_intM_a_2_10 (shift a_2_0 i_4_0)))
     (Int32.to_int (select intP_intM_b_0_11 (shift b_0_0 i_4_0))))
     (2147483647))))))))))))))))) } ensures { ("expl:Postcondition" true) } 
   ->
   'Init:
   try
    begin
    (let i_6 = ref (Safe_int32.any_  () ) in
    try
     begin
     (i_6 :=
      (let _jessie_139 =
      (#"whole_program.jc" 455 23 35# "expl:Integer cast"
      (Safe_int32.of_int (0))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 20 7 12#
      "expl:Pointer index bounds" true) }); _jessie_139 end));
      'Loop_8:
      loop
      invariant { (#"whole_program.jc" 457 6 1046# true) }
        variant {
          (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 18 20 28#
          (Int.(-) (Int32.to_int size_2) (Int32.to_int !i_6))) }
       begin
       any unit
       requires { true } reads { a_2_0, b_0_0, intP_intM_result_0_9,
       result_0_0, size_2 }
       ensures {
         ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 17 22 80#
          (forall j_1 : int.
           ((((<=) (0) j_1) /\ ((<) j_1 (Int32.to_int !i_6))) ->
            ((=)
            (Int32.to_int
            (select !intP_intM_result_0_9 (shift result_0_0 j_1)))
            (Int.(+)
            (Int32.to_int (select intP_intM_a_2_10 (shift a_2_0 j_1)))
            (Int32.to_int (select intP_intM_b_0_11 (shift b_0_0 j_1))))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 16 22 36#
         (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 16 22 36#
         ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 16 22 28#
          (Int32.(<=) (#"whole_program.jc" 459 40 52# "expl:Integer cast"
          (Int32.of_int (0))) !i_6))
         /\
         (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 16 27 36#
         (Int32.(<=) !i_6 size_2)))))) } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 20 14 22#
         (Safe_int32.(<)  !i_6 size_2 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          begin
          (let _jessie_141 =
          (let _jessie_140 =
          (Safe_int32.(+) 
           (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 21 18 22#
           "expl:Pointer dereference"
           (acc_offset_typesafe  voidP_a_2_10_alloc_table intP_intM_a_2_10
            a_2_0 (Safe_int32.to_int  !i_6 ) ))
           (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 21 25 29#
           "expl:Pointer dereference"
           (acc_offset_typesafe  voidP_b_0_11_alloc_table intP_intM_b_0_11
            b_0_0 (Safe_int32.to_int  !i_6 ) )) ) in
          begin
          (assert {
          (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 21 6 29#
          "expl:Pointer index bounds" true) }); _jessie_140 end) in
          (let _jessie_142 = result_0_0 in
          (let _jessie_143 = (Safe_int32.to_int  !i_6 ) in
          (let _jessie_144 = (shift_typesafe  _jessie_142 _jessie_143 ) in
          (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 21 6 29#
          "expl:Pointer dereference"
          (upd_offset_typesafe  voidP_result_0_9_alloc_table
           intP_intM_result_0_9 _jessie_142 _jessie_143 _jessie_141 ))))));
           (i_6 :=
            (let _jessie_145 =
            (Safe_int32.(+)  !i_6
             (#"whole_program.jc" 475 57 69# "expl:Integer cast"
             (Safe_int32.of_int (1))) ) in
            begin
            (assert {
            (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 20 24 27#
            "expl:Pointer index bounds" true) }); _jessie_145 end)) end end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_12 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_10 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_arrays_sum_behaviors

  use Unsafe_int32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let arrays_sum_ensures_default
  #"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 13 5 57#
  "expl:Function arrays_sum, default behavior" =
  fun
   (result_0_0 : (pointer voidP)) (a_2_0 : (pointer voidP)) (b_0_0 : (pointer
   voidP)) (size_2 : Int32.t) (intP_intM_result_0_9 : ref (memory voidP
   Int32.t)) (voidP_result_0_9_alloc_table : (alloc_table voidP))
   (voidP_a_2_10_alloc_table : (alloc_table voidP)) (voidP_b_0_11_alloc_table
   : (alloc_table voidP)) (voidP_b_0_11_tag_table : (tag_table voidP))
   (voidP_a_2_10_tag_table : (tag_table voidP)) (voidP_result_0_9_tag_table :
   (tag_table voidP)) (intP_intM_a_2_10 : (memory voidP Int32.t))
   (intP_intM_b_0_11 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_b_0_11_alloc_table b_0_0) ->
     (((=) (typeof voidP_b_0_11_tag_table b_0_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_b_0_11_alloc_table b_0_0) i) /\
       ((<) i (offset_max voidP_b_0_11_alloc_table b_0_0))) ->
       ((=) (typeof voidP_b_0_11_tag_table (shift b_0_0 i)) intP_tag)))))
   /\
   (((allocated voidP_a_2_10_alloc_table a_2_0) ->
     (((=) (typeof voidP_a_2_10_tag_table a_2_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_2_10_alloc_table a_2_0) i) /\
       ((<) i (offset_max voidP_a_2_10_alloc_table a_2_0))) ->
       ((=) (typeof voidP_a_2_10_tag_table (shift a_2_0 i)) intP_tag)))))
   /\
   (((allocated voidP_result_0_9_alloc_table result_0_0) ->
     (((=) (typeof voidP_result_0_9_tag_table result_0_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_result_0_9_alloc_table result_0_0) i) /\
       ((<) i (offset_max voidP_result_0_9_alloc_table result_0_0))) ->
       ((=) (typeof voidP_result_0_9_tag_table (shift result_0_0 i))
       intP_tag)))))
   /\
   (#"whole_program.jc" 405 12 2664#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 5 13 22#
    (Int32.(>=) size_2 (#"whole_program.jc" 405 33 45# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 405 12 2664#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 6 13 39#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
     (((<=) (offset_min voidP_result_0_9_alloc_table result_0_0) (0)) /\
     (((>=) (offset_max voidP_result_0_9_alloc_table result_0_0)
      (Int.(-) (Int32.to_int size_2) (1)))
     /\
     (forall __framac_tmp6 : int.
      ((((<=) (0) __framac_tmp6) /\
       ((<=) __framac_tmp6 (Int.(-) (Int32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 405 12 2664#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 7 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
     (((<=) (offset_min voidP_a_2_10_alloc_table a_2_0) (0)) /\
     (((>=) (offset_max voidP_a_2_10_alloc_table a_2_0)
      (Int.(-) (Int32.to_int size_2) (1)))
     /\
     (forall __framac_tmp7 : int.
      ((((<=) (0) __framac_tmp7) /\
       ((<=) __framac_tmp7 (Int.(-) (Int32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 405 12 2664#
   ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 8 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
     (((<=) (offset_min voidP_b_0_11_alloc_table b_0_0) (0)) /\
     (((>=) (offset_max voidP_b_0_11_alloc_table b_0_0)
      (Int.(-) (Int32.to_int size_2) (1)))
     /\
     (forall __framac_tmp8 : int.
      ((((<=) (0) __framac_tmp8) /\
       ((<=) __framac_tmp8 (Int.(-) (Int32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 9 13 90#
   (forall i_4_0 : int.
    ((((<=) (0) i_4_0) /\ ((<) i_4_0 (Int32.to_int size_2))) ->
     (((<=) (Int.(-_) (2147483648))
      (Int.(+) (Int32.to_int (select intP_intM_a_2_10 (shift a_2_0 i_4_0)))
      (Int32.to_int (select intP_intM_b_0_11 (shift b_0_0 i_4_0)))))
     /\
     ((<=)
     (Int.(+) (Int32.to_int (select intP_intM_a_2_10 (shift a_2_0 i_4_0)))
     (Int32.to_int (select intP_intM_b_0_11 (shift b_0_0 i_4_0))))
     (2147483647))))))))))))))))) }
   ensures {
     ("expl:Postcondition"
     ((#"whole_program.jc" 446 10 58# "expl:Assigns clause"
      (not_assigns voidP_result_0_9_alloc_table voidP_result_0_9_alloc_table
      (old !intP_intM_result_0_9) !intP_intM_result_0_9
      (pset_range (pset_singleton result_0_0) (0)
      (Int.(-) (Int32.to_int size_2) (1)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 11 12 73#
     "expl:Ensures clause"
     (forall i_5_0 : int.
      ((((<=) (0) i_5_0) /\ ((<) i_5_0 (Int32.to_int size_2))) ->
       ((=)
       (Int32.to_int (select !intP_intM_result_0_9 (shift result_0_0 i_5_0)))
       (Int.(+) (Int32.to_int (select intP_intM_a_2_10 (shift a_2_0 i_5_0)))
       (Int32.to_int (select intP_intM_b_0_11 (shift b_0_0 i_5_0)))))))))) }
   diverges  ->
   'Init:
   try
    begin
    (let i_6 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (i_6 :=
      (#"whole_program.jc" 455 23 35# "expl:Integer cast"
      (Unsafe_int32.of_int (0))));
      'Loop_7:
      loop
      invariant
        { (((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 16 22 36#
            (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 16 22 36#
            ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 16 22 28#
             (Int32.(<=) (#"whole_program.jc" 459 40 52# "expl:Integer cast"
             (Int32.of_int (0))) !i_6))
            /\
            (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 16 27 36#
            (Int32.(<=) !i_6 size_2)))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 17 22 80#
           (forall j_1 : int.
            ((((<=) (0) j_1) /\ ((<) j_1 (Int32.to_int !i_6))) ->
             ((=)
             (Int32.to_int
             (select !intP_intM_result_0_9 (shift result_0_0 j_1)))
             (Int.(+)
             (Int32.to_int (select intP_intM_a_2_10 (shift a_2_0 j_1)))
             (Int32.to_int (select intP_intM_b_0_11 (shift b_0_0 j_1)))))))))
          /\
          (#"whole_program.jc" 446 10 58# "expl:Assigns clause"
          (not_assigns voidP_result_0_9_alloc_table
          voidP_result_0_9_alloc_table (at !intP_intM_result_0_9 'Init)
          !intP_intM_result_0_9
          (pset_range (pset_singleton result_0_0) (0)
          (Int.(-) (Int32.to_int size_2) (1)))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 20 14 22#
         (Unsafe_int32.(<)  !i_6 size_2 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          begin
          (let _jessie_134 =
          (Unsafe_int32.(+) 
           (acc  intP_intM_a_2_10
            (shift_  a_2_0 (Unsafe_int32.to_int  !i_6 ) ) )
           (acc  intP_intM_b_0_11
            (shift_  b_0_0 (Unsafe_int32.to_int  !i_6 ) ) ) ) in
          (let _jessie_135 = result_0_0 in
          (let _jessie_136 = (Unsafe_int32.to_int  !i_6 ) in
          (let _jessie_137 = (shift_  _jessie_135 _jessie_136 ) in
          (upd  intP_intM_result_0_9 _jessie_137 _jessie_134 )))));
           (i_6 :=
            (Unsafe_int32.(+)  !i_6
             (#"whole_program.jc" 475 57 69# "expl:Integer cast"
             (Unsafe_int32.of_int (1))) )) end end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_12 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_10 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_average_safety

  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let average #"/home/work/workspace/education/acsl-exam/./average.c" 4 4 25#
  "expl:Function average, safety" =
  fun (a_3 : Int32.t) (b_1 : Int32.t) 
   requires { (true) } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_int32.any_  () ) in
   try
    begin
    (let average_0 = ref (Safe_int32.any_  () ) in
    (let greater = ref (Safe_int32.any_  () ) in
    (let smaller = ref (Safe_int32.any_  () ) in
    try
     begin
     try
      begin
      try
       begin
       try
        begin
        try
         begin
         try
          begin
          try
           begin
           (average_0 :=
            (let _jessie_155 =
            (#"whole_program.jc" 498 29 41# "expl:Integer cast"
            (Safe_int32.of_int (0))) in
            begin
            (assert {
            (#"/home/work/workspace/education/acsl-exam/./average.c" 6 3 6#
            "expl:Pointer index bounds" true) }); _jessie_155 end));
            (if
            (#"/home/work/workspace/education/acsl-exam/./average.c" 10 5 10#
            (Safe_int32.(>)  a_3 b_1 ))
            then
             begin
             (greater :=
              (let _jessie_158 = a_3 in
              begin
              (assert {
              (#"/home/work/workspace/education/acsl-exam/./average.c" 11 4 15#
              "expl:Pointer index bounds" true) }); _jessie_158 end));
              (smaller :=
               (let _jessie_159 = b_1 in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./average.c" 12 4 15#
               "expl:Pointer index bounds" true) }); _jessie_159 end)) end
            else
             begin
             (greater :=
              (let _jessie_156 = b_1 in
              begin
              (assert {
              (#"/home/work/workspace/education/acsl-exam/./average.c" 14 4 15#
              "expl:Pointer index bounds" true) }); _jessie_156 end));
              (smaller :=
               (let _jessie_157 = a_3 in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./average.c" 15 4 15#
               "expl:Pointer index bounds" true) }); _jessie_157 end)) end);
            (if
            (#"/home/work/workspace/education/acsl-exam/./average.c" 17 5 11#
            (Safe_int32.(>=)  a_3
             (#"whole_program.jc" 506 28 40# "expl:Integer cast"
             (Safe_int32.of_int (0))) ))
            then
             (if
             (#"/home/work/workspace/education/acsl-exam/./average.c" 17 15 21#
             (Safe_int32.(>=)  b_1
              (#"whole_program.jc" 507 64 76# "expl:Integer cast"
              (Safe_int32.of_int (0))) ))
             then
              (average_0 :=
               (let _jessie_160 =
               (Safe_int32.(+)  !smaller
                (#"/home/work/workspace/education/acsl-exam/./average.c" 18 24 47#
                "expl:Division by zero"
                (Safe_int32.(/)  (Safe_int32.(-)  !greater !smaller )
                 (#"whole_program.jc" 517 63 75# "expl:Integer cast"
                 (Safe_int32.of_int (2))) )) ) in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./average.c" 18 4 47#
               "expl:Pointer index bounds" true) }); _jessie_160 end))
             else (raise (Goto__LAND_3_exc ())))
            else (raise (Goto__LAND_3_exc ())));
            (raise (Goto__LAND_4_exc ())); (raise (Goto__LAND_3_exc ())) end
           with Goto__LAND_3_exc _jessie_13 ->
           'U__LAND_3:
           'U__LAND_3:
           begin
           ();
            (if
            (#"/home/work/workspace/education/acsl-exam/./average.c" 19 12 17#
            (Safe_int32.(<)  a_3
             (#"whole_program.jc" 523 27 39# "expl:Integer cast"
             (Safe_int32.of_int (0))) ))
            then
             (if
             (#"/home/work/workspace/education/acsl-exam/./average.c" 19 21 26#
             (Safe_int32.(<)  b_1
              (#"whole_program.jc" 524 63 75# "expl:Integer cast"
              (Safe_int32.of_int (0))) ))
             then
              (average_0 :=
               (let _jessie_161 =
               (Safe_int32.(+)  !greater
                (#"/home/work/workspace/education/acsl-exam/./average.c" 20 24 47#
                "expl:Division by zero"
                (Safe_int32.(/)  (Safe_int32.(-)  !smaller !greater )
                 (#"whole_program.jc" 533 68 80# "expl:Integer cast"
                 (Safe_int32.of_int (2))) )) ) in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./average.c" 20 4 47#
               "expl:Pointer index bounds" true) }); _jessie_161 end))
             else (raise (Goto__LAND_1_exc ())))
            else (raise (Goto__LAND_1_exc ())));
            (raise (Goto__LAND_2_exc ())) end end;
           (raise (Goto__LAND_1_exc ())) end with Goto__LAND_1_exc _jessie_14
          ->
          'U__LAND_1:
          'U__LAND_1:
          begin
          ();
           (if
           (#"/home/work/workspace/education/acsl-exam/./average.c" 21 13 19#
           (Safe_int32.(>=)  a_3
            (#"whole_program.jc" 539 28 40# "expl:Integer cast"
            (Safe_int32.of_int (0))) ))
           then
            (if
            (#"/home/work/workspace/education/acsl-exam/./average.c" 21 23 29#
            (Safe_int32.(<=)  b_1
             (#"whole_program.jc" 540 64 76# "expl:Integer cast"
             (Safe_int32.of_int (0))) )) then (raise (Goto__LOR_exc ()))
            else (raise (Goto__LAND_exc ())))
           else (raise (Goto__LAND_exc ()))) end end;
          (raise (Goto__LAND_exc ())) end with Goto__LAND_exc _jessie_15 ->
         'U__LAND:
         'U__LAND:
         begin
         ();
          (if
          (#"/home/work/workspace/education/acsl-exam/./average.c" 21 35 41#
          (Safe_int32.(<=)  a_3
           (#"whole_program.jc" 545 28 40# "expl:Integer cast"
           (Safe_int32.of_int (0))) ))
          then
           (if
           (#"/home/work/workspace/education/acsl-exam/./average.c" 21 45 51#
           (Safe_int32.(>=)  b_1
            (#"whole_program.jc" 546 64 76# "expl:Integer cast"
            (Safe_int32.of_int (0))) )) then (raise (Goto__LOR_exc ()))
           else ()) else ()); (raise (Goto__LOR_0_exc ())) end end;
         (raise (Goto__LOR_exc ())) end with Goto__LOR_exc _jessie_16 ->
        'U__LOR:
        'U__LOR:
        'U__LOR:
        'U__LOR:
        (average_0 :=
         (let _jessie_162 =
         (#"/home/work/workspace/education/acsl-exam/./average.c" 22 14 25#
         "expl:Division by zero"
         (Safe_int32.(/)  (Safe_int32.(+)  a_3 b_1 )
          (#"whole_program.jc" 554 68 80# "expl:Integer cast"
          (Safe_int32.of_int (2))) )) in
         begin
         (assert {
         (#"whole_program.jc" 550 14 414# "expl:Pointer index bounds" true)
         }); _jessie_162 end)) end; (raise (Goto__LOR_0_exc ())) end with
       Goto__LOR_0_exc _jessie_17 -> 'U__LOR_0: 'U__LOR_0: () end;
       (raise (Goto__LAND_2_exc ())) end with Goto__LAND_2_exc _jessie_18 ->
      'U__LAND_2: 'U__LAND_2: () end; (raise (Goto__LAND_4_exc ())) end with
     Goto__LAND_4_exc _jessie_19 ->
     'U__LAND_4:
     'U__LAND_4:
     begin
     ();
      begin
      (return :=
       (let _jessie_163 = !average_0 in
       begin
       (assert {
       (#"whole_program.jc" 559 7 23# "expl:Pointer index bounds" true) });
        _jessie_163 end)); (raise Return) end end end))); absurd  end with
    Return -> !return end)
  
end

module Function_average_behaviors

  use Unsafe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let average_ensures_default
  #"/home/work/workspace/education/acsl-exam/./average.c" 4 4 25#
  "expl:Function average, default behavior" =
  fun (a_3 : Int32.t) (b_1 : Int32.t) 
   requires { (true) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./average.c" 2 12 30#
     "expl:Ensures clause"
     ((=) (Int32.to_int result)
     (ComputerDivision.div (Int.(+) (Int32.to_int a_3) (Int32.to_int b_1))
     (2))))) }  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (let average_0 = ref (Unsafe_int32.any_  () ) in
    (let greater = ref (Unsafe_int32.any_  () ) in
    (let smaller = ref (Unsafe_int32.any_  () ) in
    try
     begin
     try
      begin
      try
       begin
       try
        begin
        try
         begin
         try
          begin
          try
           begin
           (average_0 :=
            (#"whole_program.jc" 498 29 41# "expl:Integer cast"
            (Unsafe_int32.of_int (0))));
            (if
            (#"/home/work/workspace/education/acsl-exam/./average.c" 10 5 10#
            (Unsafe_int32.(>)  a_3 b_1 ))
            then begin (greater := a_3); (smaller := b_1) end
            else begin (greater := b_1); (smaller := a_3) end);
            (if
            (#"/home/work/workspace/education/acsl-exam/./average.c" 17 5 11#
            (Unsafe_int32.(>=)  a_3
             (#"whole_program.jc" 506 28 40# "expl:Integer cast"
             (Unsafe_int32.of_int (0))) ))
            then
             (if
             (#"/home/work/workspace/education/acsl-exam/./average.c" 17 15 21#
             (Unsafe_int32.(>=)  b_1
              (#"whole_program.jc" 507 64 76# "expl:Integer cast"
              (Unsafe_int32.of_int (0))) ))
             then
              (average_0 :=
               (Unsafe_int32.(+)  !smaller
                (Unsafe_int32.(/)  (Unsafe_int32.(-)  !greater !smaller )
                 (#"whole_program.jc" 517 63 75# "expl:Integer cast"
                 (Unsafe_int32.of_int (2))) ) ))
             else (raise (Goto__LAND_3_exc ())))
            else (raise (Goto__LAND_3_exc ())));
            (raise (Goto__LAND_4_exc ())); (raise (Goto__LAND_3_exc ())) end
           with Goto__LAND_3_exc _jessie_13 ->
           'U__LAND_3:
           'U__LAND_3:
           begin
           ();
            (if
            (#"/home/work/workspace/education/acsl-exam/./average.c" 19 12 17#
            (Unsafe_int32.(<)  a_3
             (#"whole_program.jc" 523 27 39# "expl:Integer cast"
             (Unsafe_int32.of_int (0))) ))
            then
             (if
             (#"/home/work/workspace/education/acsl-exam/./average.c" 19 21 26#
             (Unsafe_int32.(<)  b_1
              (#"whole_program.jc" 524 63 75# "expl:Integer cast"
              (Unsafe_int32.of_int (0))) ))
             then
              (average_0 :=
               (Unsafe_int32.(+)  !greater
                (Unsafe_int32.(/)  (Unsafe_int32.(-)  !smaller !greater )
                 (#"whole_program.jc" 533 68 80# "expl:Integer cast"
                 (Unsafe_int32.of_int (2))) ) ))
             else (raise (Goto__LAND_1_exc ())))
            else (raise (Goto__LAND_1_exc ())));
            (raise (Goto__LAND_2_exc ())) end end;
           (raise (Goto__LAND_1_exc ())) end with Goto__LAND_1_exc _jessie_14
          ->
          'U__LAND_1:
          'U__LAND_1:
          begin
          ();
           (if
           (#"/home/work/workspace/education/acsl-exam/./average.c" 21 13 19#
           (Unsafe_int32.(>=)  a_3
            (#"whole_program.jc" 539 28 40# "expl:Integer cast"
            (Unsafe_int32.of_int (0))) ))
           then
            (if
            (#"/home/work/workspace/education/acsl-exam/./average.c" 21 23 29#
            (Unsafe_int32.(<=)  b_1
             (#"whole_program.jc" 540 64 76# "expl:Integer cast"
             (Unsafe_int32.of_int (0))) )) then (raise (Goto__LOR_exc ()))
            else (raise (Goto__LAND_exc ())))
           else (raise (Goto__LAND_exc ()))) end end;
          (raise (Goto__LAND_exc ())) end with Goto__LAND_exc _jessie_15 ->
         'U__LAND:
         'U__LAND:
         begin
         ();
          (if
          (#"/home/work/workspace/education/acsl-exam/./average.c" 21 35 41#
          (Unsafe_int32.(<=)  a_3
           (#"whole_program.jc" 545 28 40# "expl:Integer cast"
           (Unsafe_int32.of_int (0))) ))
          then
           (if
           (#"/home/work/workspace/education/acsl-exam/./average.c" 21 45 51#
           (Unsafe_int32.(>=)  b_1
            (#"whole_program.jc" 546 64 76# "expl:Integer cast"
            (Unsafe_int32.of_int (0))) )) then (raise (Goto__LOR_exc ()))
           else ()) else ()); (raise (Goto__LOR_0_exc ())) end end;
         (raise (Goto__LOR_exc ())) end with Goto__LOR_exc _jessie_16 ->
        'U__LOR:
        'U__LOR:
        'U__LOR:
        'U__LOR:
        (average_0 :=
         (Unsafe_int32.(/)  (Unsafe_int32.(+)  a_3 b_1 )
          (#"whole_program.jc" 554 68 80# "expl:Integer cast"
          (Unsafe_int32.of_int (2))) )) end; (raise (Goto__LOR_0_exc ())) end
       with Goto__LOR_0_exc _jessie_17 -> 'U__LOR_0: 'U__LOR_0: () end;
       (raise (Goto__LAND_2_exc ())) end with Goto__LAND_2_exc _jessie_18 ->
      'U__LAND_2: 'U__LAND_2: () end; (raise (Goto__LAND_4_exc ())) end with
     Goto__LAND_4_exc _jessie_19 ->
     'U__LAND_4:
     'U__LAND_4:
     begin (); begin (return := !average_0); (raise Return) end end end)));
     absurd  end with Return -> !return end)
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Function_bsearch_safety

  use enum.Uint32 
  
  use import Struct_intP 
  
  use Safe_uint32_of_Safe_int64 
  
  use Safe_uint32 
  
  use Safe_int64_of_Safe_uint32 
  
  use Safe_int64 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int64 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let bsearch
  #"/home/work/workspace/education/acsl-exam/./binary_search.c" 18 4 42#
  "expl:Function bsearch, safety" =
  fun
   (a_4 : (pointer voidP)) (n_2 : Uint32.t) (key : Int32.t)
   (voidP_a_4_12_alloc_table : (alloc_table voidP)) (voidP_a_4_12_tag_table :
   (tag_table voidP)) (intP_intM_a_4_12 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_4_12_alloc_table a_4) ->
     (((=) (typeof voidP_a_4_12_tag_table a_4) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_4_12_alloc_table a_4) i) /\
       ((<) i (offset_max voidP_a_4_12_alloc_table a_4))) ->
       ((=) (typeof voidP_a_4_12_tag_table (shift a_4 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 564 12 921#
   ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 5 13 31#
    (if ((<=) (0) (Int.(-) (Uint32.to_int n_2) (1))) then
     (((<=) (offset_min voidP_a_4_12_alloc_table a_4) (0)) /\
     (((>=) (offset_max voidP_a_4_12_alloc_table a_4)
      (Int.(-) (Uint32.to_int n_2) (1)))
     /\
     (forall __framac_tmp9 : int.
      ((((<=) (0) __framac_tmp9) /\
       ((<=) __framac_tmp9 (Int.(-) (Uint32.to_int n_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 6 13 66#
   (forall i_11 : int.
    (forall j_2 : int.
     ((((<=) (0) i_11) /\ (((<) i_11 j_2) /\ ((<) j_2 (Uint32.to_int n_2))))
      ->
      (Int32.(<=) (select intP_intM_a_4_12 (shift a_4 i_11))
      (select intP_intM_a_4_12 (shift a_4 j_2)))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (); ();
     (let left = ref (Safe_uint32.any_  () ) in
     (let right = ref (Safe_int64.any_  () ) in
     (let m = ref (Safe_uint32.any_  () ) in
     (let __retres_0 = ref (any_pointer  () : (pointer voidP)) in
     try
      begin
      try
       begin
       (left :=
        (let _jessie_193 =
        (#"whole_program.jc" 622 24 37# "expl:Integer cast"
        (Safe_uint32.of_int (0))) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 20 3 11#
        "expl:Pointer index bounds" true) }); _jessie_193 end));
        begin
        (right :=
         (let _jessie_188 =
         (Safe_int64.(-) 
          (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 21 17 24#
          "expl:Integer cast" (Safe_int64_of_Safe_uint32.cast  n_2 ))
          (#"whole_program.jc" 624 48 60# "expl:Integer cast"
          (Safe_int64.of_int (1))) ) in
         begin
         (assert {
         (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 21 3 7#
         "expl:Pointer index bounds" true) }); _jessie_188 end));
         'Loop_12:
         loop
         invariant { (#"whole_program.jc" 626 6 2327# true) }
           variant {
             (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 28 20 32#
             (Int.(-) (Int64.to_int !right) (Uint32.to_int !left))) }
          begin
          any unit
          requires { true } reads { a_4, key, n_2 }
          ensures {
            ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 27 22 97#
             (forall i_7 : int.
              ((((<=) (0) i_7) /\
               (((<) i_7 (Uint32.to_int n_2)) /\
               (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_7)) key))) ->
               ((Int32.(<=)
                (select intP_intM_a_4_12 (shift a_4 (Uint32.to_int !left)))
                key)
               /\
               (Int32.(<=) key
               (select intP_intM_a_4_12 (shift a_4 (Int64.to_int !right))))))))
            /\
            ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 26 22 89#
             (forall i_6_0 : int.
              ((((<=) (0) i_6_0) /\
               (((<) i_6_0 (Uint32.to_int n_2)) /\
               (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_6_0)) key)))
               ->
               (((<=) (Uint32.to_int !left) i_6_0) /\
               ((<=) i_6_0 (Int64.to_int !right))))))
            /\
            ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 24 22 31#
             ((<) (Int64.to_int !right) (Uint32.to_int n_2)))
            /\
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 23 22 31#
            ((<=) (0) (Uint32.to_int !left)))))) } ;
           try
            begin
            begin
            (if
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 30 10 23#
            (Safe_int64.(<=) 
             (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 30 10 14#
             "expl:Integer cast" (Safe_int64_of_Safe_uint32.cast  !left ))
             !right )) then () else (raise (Goto_while_0_break_exc ())));
             begin
             (m :=
              (let _jessie_189 =
              (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 19 44#
              "expl:Integer cast"
              (Safe_uint32_of_Safe_int64.cast 
               (Safe_int64.(+) 
                (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 19 23#
                "expl:Integer cast" (Safe_int64_of_Safe_uint32.cast  !left ))
                (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 26 44#
                "expl:Division by zero"
                (Safe_int64.(/) 
                 (Safe_int64.(-)  !right
                  (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 35 39#
                  "expl:Integer cast"
                  (Safe_int64_of_Safe_uint32.cast  !left )) )
                 (#"whole_program.jc" 655 66 78# "expl:Integer cast"
                 (Safe_int64.of_int (2))) )) ) )) in
              begin
              (assert {
              (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 6 14#
              "expl:Pointer index bounds" true) }); _jessie_189 end));
              (if
              (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 33 10 20#
              (Safe_int32.(<) 
               (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 33 10 14#
               "expl:Pointer dereference"
               (acc_offset_typesafe  voidP_a_4_12_alloc_table
                intP_intM_a_4_12 a_4 (Safe_uint32.to_int  !m ) )) key ))
              then
               (left :=
                (let _jessie_192 =
                (Safe_uint32.(+)  !m
                 (#"whole_program.jc" 657 59 72# "expl:Integer cast"
                 (Safe_uint32.of_int (1))) ) in
                begin
                (assert {
                (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 34 9 21#
                "expl:Pointer index bounds" true) }); _jessie_192 end))
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 35 17 27#
               (Safe_int32.(>) 
                (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 35 17 21#
                "expl:Pointer dereference"
                (acc_offset_typesafe  voidP_a_4_12_alloc_table
                 intP_intM_a_4_12 a_4 (Safe_uint32.to_int  !m ) )) key ))
               then
                (right :=
                 (let _jessie_191 =
                 (Safe_int64.(-) 
                  (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 36 18 25#
                  "expl:Integer cast" (Safe_int64_of_Safe_uint32.cast  !m ))
                  (#"whole_program.jc" 660 57 69# "expl:Integer cast"
                  (Safe_int64.of_int (1))) ) in
                 begin
                 (assert {
                 (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 36 9 30#
                 "expl:Pointer index bounds" true) }); _jessie_191 end))
               else
                begin
                (__retres_0 :=
                 (let _jessie_190 =
                 (shift_typesafe  a_4 (Safe_uint32.to_int  !m ) ) in
                 begin
                 (assert {
                 (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 38 9 22#
                 "expl:Pointer index bounds" true) }); _jessie_190 end));
                 (raise (Return_label_exc ())) end)) end end;
             (raise (Loop_continue_exc ())) end with Loop_continue_exc
            _jessie_23 -> () end end end; (raise (Goto_while_0_break_exc ()))
        end end with Goto_while_0_break_exc _jessie_20 ->
       'While_0_break:
       'While_0_break:
       begin
       ();
        (__retres_0 :=
         (let _jessie_194 = (null  ) in
         begin
         (assert {
         (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 41 3 100#
         "expl:Pointer index bounds" true) }); _jessie_194 end)) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_21 ->
      'Return_label:
      'Return_label:
      begin
      (return :=
       (let _jessie_195 = !__retres_0 in
       begin
       (assert {
       (#"whole_program.jc" 671 7 24# "expl:Pointer index bounds" true) });
        _jessie_195 end)); (raise Return) end end)))); absurd  end with
    Return -> !return end)
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Function_bsearch_behaviors

  use Unsafe_uint32_of_Unsafe_int64 
  
  use Unsafe_uint32 
  
  use Unsafe_int64_of_Unsafe_uint32 
  
  use Unsafe_int64 
  
  use Unsafe_int32 
  
  use enum.Uint32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int64 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let bsearch_ensures_EXISTS
  #"/home/work/workspace/education/acsl-exam/./binary_search.c" 18 4 42#
  "expl:Function bsearch, behavior EXISTS" =
  fun
   (a_4 : (pointer voidP)) (n_2 : Uint32.t) (key : Int32.t)
   (voidP_a_4_12_alloc_table : (alloc_table voidP)) (voidP_a_4_12_tag_table :
   (tag_table voidP)) (intP_intM_a_4_12 : (memory voidP Int32.t)) 
   requires {
   ((exists i_8 : int.
     (((<=) (0) i_8) /\
     (((<) i_8 (Uint32.to_int n_2)) /\
     (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_8)) key))))
   /\
   (((allocated voidP_a_4_12_alloc_table a_4) ->
     (((=) (typeof voidP_a_4_12_tag_table a_4) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_4_12_alloc_table a_4) i) /\
       ((<) i (offset_max voidP_a_4_12_alloc_table a_4))) ->
       ((=) (typeof voidP_a_4_12_tag_table (shift a_4 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 564 12 921#
   ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 5 13 31#
    (if ((<=) (0) (Int.(-) (Uint32.to_int n_2) (1))) then
     (((<=) (offset_min voidP_a_4_12_alloc_table a_4) (0)) /\
     (((>=) (offset_max voidP_a_4_12_alloc_table a_4)
      (Int.(-) (Uint32.to_int n_2) (1)))
     /\
     (forall __framac_tmp9 : int.
      ((((<=) (0) __framac_tmp9) /\
       ((<=) __framac_tmp9 (Int.(-) (Uint32.to_int n_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 6 13 66#
   (forall i_11 : int.
    (forall j_2 : int.
     ((((<=) (0) i_11) /\ (((<) i_11 j_2) /\ ((<) j_2 (Uint32.to_int n_2))))
      ->
      (Int32.(<=) (select intP_intM_a_4_12 (shift a_4 i_11))
      (select intP_intM_a_4_12 (shift a_4 j_2))))))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 13 15 66#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 13 15 66#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 13 15 66#
      "expl:Ensures clause"
      (exists i_9 : int.
       (((<=) (0) i_9) /\
       (((<) i_9 (Uint32.to_int n_2)) /\ ((=) result (shift a_4 i_9))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 14 15 32#
     "expl:Ensures clause" (Int32.(=) (select intP_intM_a_4_12 result) key))))))
     } diverges  ->
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (); ();
     (let left = ref (Unsafe_uint32.any_  () ) in
     (let right = ref (Unsafe_int64.any_  () ) in
     (let m = ref (Unsafe_uint32.any_  () ) in
     (let __retres_0 = ref (any_pointer  () : (pointer voidP)) in
     try
      begin
      try
       begin
       (left :=
        (#"whole_program.jc" 622 24 37# "expl:Integer cast"
        (Unsafe_uint32.of_int (0))));
        begin
        (right :=
         (Unsafe_int64.(-) 
          (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 21 17 24#
          "expl:Integer cast" (Unsafe_int64_of_Unsafe_uint32.cast  n_2 ))
          (#"whole_program.jc" 624 48 60# "expl:Integer cast"
          (Unsafe_int64.of_int (1))) ));
         'Loop_11:
         loop
         invariant { (#"whole_program.jc" 626 6 2327# true) } 
          begin
          any unit
          requires { true } reads { a_4, key, n_2 }
          ensures {
            ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 27 22 97#
             (forall i_7 : int.
              ((((<=) (0) i_7) /\
               (((<) i_7 (Uint32.to_int n_2)) /\
               (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_7)) key))) ->
               ((Int32.(<=)
                (select intP_intM_a_4_12 (shift a_4 (Uint32.to_int !left)))
                key)
               /\
               (Int32.(<=) key
               (select intP_intM_a_4_12 (shift a_4 (Int64.to_int !right))))))))
            /\
            ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 26 22 89#
             (forall i_6_0 : int.
              ((((<=) (0) i_6_0) /\
               (((<) i_6_0 (Uint32.to_int n_2)) /\
               (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_6_0)) key)))
               ->
               (((<=) (Uint32.to_int !left) i_6_0) /\
               ((<=) i_6_0 (Int64.to_int !right))))))
            /\
            ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 24 22 31#
             ((<) (Int64.to_int !right) (Uint32.to_int n_2)))
            /\
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 23 22 31#
            ((<=) (0) (Uint32.to_int !left)))))) } ;
           try
            begin
            begin
            (if
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 30 10 23#
            (Unsafe_int64.(<=) 
             (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 30 10 14#
             "expl:Integer cast"
             (Unsafe_int64_of_Unsafe_uint32.cast  !left )) !right )) 
            then () else (raise (Goto_while_0_break_exc ())));
             begin
             (m :=
              (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 19 44#
              "expl:Integer cast"
              (Unsafe_uint32_of_Unsafe_int64.cast 
               (Unsafe_int64.(+) 
                (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 19 23#
                "expl:Integer cast"
                (Unsafe_int64_of_Unsafe_uint32.cast  !left ))
                (Unsafe_int64.(/) 
                 (Unsafe_int64.(-)  !right
                  (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 35 39#
                  "expl:Integer cast"
                  (Unsafe_int64_of_Unsafe_uint32.cast  !left )) )
                 (#"whole_program.jc" 655 66 78# "expl:Integer cast"
                 (Unsafe_int64.of_int (2))) ) ) )));
              (if
              (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 33 10 20#
              (Unsafe_int32.(<) 
               (acc  intP_intM_a_4_12
                (shift_  a_4 (Unsafe_uint32.to_int  !m ) ) ) key ))
              then
               (left :=
                (Unsafe_uint32.(+)  !m
                 (#"whole_program.jc" 657 59 72# "expl:Integer cast"
                 (Unsafe_uint32.of_int (1))) ))
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 35 17 27#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_4_12
                 (shift_  a_4 (Unsafe_uint32.to_int  !m ) ) ) key ))
               then
                (right :=
                 (Unsafe_int64.(-) 
                  (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 36 18 25#
                  "expl:Integer cast"
                  (Unsafe_int64_of_Unsafe_uint32.cast  !m ))
                  (#"whole_program.jc" 660 57 69# "expl:Integer cast"
                  (Unsafe_int64.of_int (1))) ))
               else
                begin
                (__retres_0 := (shift_  a_4 (Unsafe_uint32.to_int  !m ) ));
                 (raise (Return_label_exc ())) end)) end end;
             (raise (Loop_continue_exc ())) end with Loop_continue_exc
            _jessie_23 -> () end end end; (raise (Goto_while_0_break_exc ()))
        end end with Goto_while_0_break_exc _jessie_20 ->
       'While_0_break: 'While_0_break: begin (); (__retres_0 := (null  )) end
       end; (raise (Return_label_exc ())) end with Return_label_exc
      _jessie_21 ->
      'Return_label:
      'Return_label: begin (return := !__retres_0); (raise Return) end end))));
     absurd  end with Return -> !return end)
  
  let bsearch_ensures_NOT_EXISTS
  #"/home/work/workspace/education/acsl-exam/./binary_search.c" 18 4 42#
  "expl:Function bsearch, behavior NOT_EXISTS" =
  fun
   (a_4 : (pointer voidP)) (n_2 : Uint32.t) (key : Int32.t)
   (voidP_a_4_12_alloc_table : (alloc_table voidP)) (voidP_a_4_12_tag_table :
   (tag_table voidP)) (intP_intM_a_4_12 : (memory voidP Int32.t)) 
   requires {
   ((forall i_10 : int.
     ((((<=) (0) i_10) /\ ((<) i_10 (Uint32.to_int n_2))) ->
      (Int32.(<>) (select intP_intM_a_4_12 (shift a_4 i_10)) key)))
   /\
   (((allocated voidP_a_4_12_alloc_table a_4) ->
     (((=) (typeof voidP_a_4_12_tag_table a_4) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_4_12_alloc_table a_4) i) /\
       ((<) i (offset_max voidP_a_4_12_alloc_table a_4))) ->
       ((=) (typeof voidP_a_4_12_tag_table (shift a_4 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 564 12 921#
   ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 5 13 31#
    (if ((<=) (0) (Int.(-) (Uint32.to_int n_2) (1))) then
     (((<=) (offset_min voidP_a_4_12_alloc_table a_4) (0)) /\
     (((>=) (offset_max voidP_a_4_12_alloc_table a_4)
      (Int.(-) (Uint32.to_int n_2) (1)))
     /\
     (forall __framac_tmp9 : int.
      ((((<=) (0) __framac_tmp9) /\
       ((<=) __framac_tmp9 (Int.(-) (Uint32.to_int n_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 6 13 66#
   (forall i_11 : int.
    (forall j_2 : int.
     ((((<=) (0) i_11) /\ (((<) i_11 j_2) /\ ((<) j_2 (Uint32.to_int n_2))))
      ->
      (Int32.(<=) (select intP_intM_a_4_12 (shift a_4 i_11))
      (select intP_intM_a_4_12 (shift a_4 j_2))))))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 10 15 31#
     "expl:Ensures clause" ((=) result null))) } diverges  ->
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (); ();
     (let left = ref (Unsafe_uint32.any_  () ) in
     (let right = ref (Unsafe_int64.any_  () ) in
     (let m = ref (Unsafe_uint32.any_  () ) in
     (let __retres_0 = ref (any_pointer  () : (pointer voidP)) in
     try
      begin
      try
       begin
       (left :=
        (#"whole_program.jc" 622 24 37# "expl:Integer cast"
        (Unsafe_uint32.of_int (0))));
        begin
        (right :=
         (Unsafe_int64.(-) 
          (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 21 17 24#
          "expl:Integer cast" (Unsafe_int64_of_Unsafe_uint32.cast  n_2 ))
          (#"whole_program.jc" 624 48 60# "expl:Integer cast"
          (Unsafe_int64.of_int (1))) ));
         'Loop_10:
         loop
         invariant { (#"whole_program.jc" 626 6 2327# true) } 
          begin
          any unit
          requires { true } reads { a_4, key, n_2 }
          ensures {
            ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 27 22 97#
             (forall i_7 : int.
              ((((<=) (0) i_7) /\
               (((<) i_7 (Uint32.to_int n_2)) /\
               (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_7)) key))) ->
               ((Int32.(<=)
                (select intP_intM_a_4_12 (shift a_4 (Uint32.to_int !left)))
                key)
               /\
               (Int32.(<=) key
               (select intP_intM_a_4_12 (shift a_4 (Int64.to_int !right))))))))
            /\
            ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 26 22 89#
             (forall i_6_0 : int.
              ((((<=) (0) i_6_0) /\
               (((<) i_6_0 (Uint32.to_int n_2)) /\
               (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_6_0)) key)))
               ->
               (((<=) (Uint32.to_int !left) i_6_0) /\
               ((<=) i_6_0 (Int64.to_int !right))))))
            /\
            ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 24 22 31#
             ((<) (Int64.to_int !right) (Uint32.to_int n_2)))
            /\
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 23 22 31#
            ((<=) (0) (Uint32.to_int !left)))))) } ;
           try
            begin
            begin
            (if
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 30 10 23#
            (Unsafe_int64.(<=) 
             (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 30 10 14#
             "expl:Integer cast"
             (Unsafe_int64_of_Unsafe_uint32.cast  !left )) !right )) 
            then () else (raise (Goto_while_0_break_exc ())));
             begin
             (m :=
              (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 19 44#
              "expl:Integer cast"
              (Unsafe_uint32_of_Unsafe_int64.cast 
               (Unsafe_int64.(+) 
                (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 19 23#
                "expl:Integer cast"
                (Unsafe_int64_of_Unsafe_uint32.cast  !left ))
                (Unsafe_int64.(/) 
                 (Unsafe_int64.(-)  !right
                  (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 35 39#
                  "expl:Integer cast"
                  (Unsafe_int64_of_Unsafe_uint32.cast  !left )) )
                 (#"whole_program.jc" 655 66 78# "expl:Integer cast"
                 (Unsafe_int64.of_int (2))) ) ) )));
              (if
              (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 33 10 20#
              (Unsafe_int32.(<) 
               (acc  intP_intM_a_4_12
                (shift_  a_4 (Unsafe_uint32.to_int  !m ) ) ) key ))
              then
               (left :=
                (Unsafe_uint32.(+)  !m
                 (#"whole_program.jc" 657 59 72# "expl:Integer cast"
                 (Unsafe_uint32.of_int (1))) ))
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 35 17 27#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_4_12
                 (shift_  a_4 (Unsafe_uint32.to_int  !m ) ) ) key ))
               then
                (right :=
                 (Unsafe_int64.(-) 
                  (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 36 18 25#
                  "expl:Integer cast"
                  (Unsafe_int64_of_Unsafe_uint32.cast  !m ))
                  (#"whole_program.jc" 660 57 69# "expl:Integer cast"
                  (Unsafe_int64.of_int (1))) ))
               else
                begin
                (__retres_0 := (shift_  a_4 (Unsafe_uint32.to_int  !m ) ));
                 (raise (Return_label_exc ())) end)) end end;
             (raise (Loop_continue_exc ())) end with Loop_continue_exc
            _jessie_23 -> () end end end; (raise (Goto_while_0_break_exc ()))
        end end with Goto_while_0_break_exc _jessie_20 ->
       'While_0_break: 'While_0_break: begin (); (__retres_0 := (null  )) end
       end; (raise (Return_label_exc ())) end with Return_label_exc
      _jessie_21 ->
      'Return_label:
      'Return_label: begin (return := !__retres_0); (raise Return) end end))));
     absurd  end with Return -> !return end)
  
  let bsearch_ensures_default
  #"/home/work/workspace/education/acsl-exam/./binary_search.c" 18 4 42#
  "expl:Function bsearch, default behavior" =
  fun
   (a_4 : (pointer voidP)) (n_2 : Uint32.t) (key : Int32.t)
   (voidP_a_4_12_alloc_table : (alloc_table voidP)) (voidP_a_4_12_tag_table :
   (tag_table voidP)) (intP_intM_a_4_12 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_4_12_alloc_table a_4) ->
     (((=) (typeof voidP_a_4_12_tag_table a_4) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_4_12_alloc_table a_4) i) /\
       ((<) i (offset_max voidP_a_4_12_alloc_table a_4))) ->
       ((=) (typeof voidP_a_4_12_tag_table (shift a_4 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 564 12 921#
   ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 5 13 31#
    (if ((<=) (0) (Int.(-) (Uint32.to_int n_2) (1))) then
     (((<=) (offset_min voidP_a_4_12_alloc_table a_4) (0)) /\
     (((>=) (offset_max voidP_a_4_12_alloc_table a_4)
      (Int.(-) (Uint32.to_int n_2) (1)))
     /\
     (forall __framac_tmp9 : int.
      ((((<=) (0) __framac_tmp9) /\
       ((<=) __framac_tmp9 (Int.(-) (Uint32.to_int n_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 6 13 66#
   (forall i_11 : int.
    (forall j_2 : int.
     ((((<=) (0) i_11) /\ (((<) i_11 j_2) /\ ((<) j_2 (Uint32.to_int n_2))))
      ->
      (Int32.(<=) (select intP_intM_a_4_12 (shift a_4 i_11))
      (select intP_intM_a_4_12 (shift a_4 j_2)))))))))) }
   ensures { ("expl:Postcondition" ("expl:Ensures clause" true)) } diverges 
   ->
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (check {
    (#"whole_program.jc" 597 10 514# "expl:Behavior disjointness check"
    (not
    ((forall i_10_0 : int.
      ((((<=) (0) i_10_0) /\ ((<) i_10_0 (Uint32.to_int n_2))) ->
       (Int32.(<>) (select intP_intM_a_4_12 (shift a_4 i_10_0)) key)))
    /\
    (exists i_8_0 : int.
     (((<=) (0) i_8_0) /\
     (((<) i_8_0 (Uint32.to_int n_2)) /\
     (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_8_0)) key))))))) });
     (check {
     (#"whole_program.jc" 606 10 451# "expl:Behavior completeness check"
     ((exists i_8_1 : int.
       (((<=) (0) i_8_1) /\
       (((<) i_8_1 (Uint32.to_int n_2)) /\
       (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_8_1)) key))))
     \/
     (forall i_10_1 : int.
      ((((<=) (0) i_10_1) /\ ((<) i_10_1 (Uint32.to_int n_2))) ->
       (Int32.(<>) (select intP_intM_a_4_12 (shift a_4 i_10_1)) key))))) });
     (let left = ref (Unsafe_uint32.any_  () ) in
     (let right = ref (Unsafe_int64.any_  () ) in
     (let m = ref (Unsafe_uint32.any_  () ) in
     (let __retres_0 = ref (any_pointer  () : (pointer voidP)) in
     try
      begin
      try
       begin
       (left :=
        (#"whole_program.jc" 622 24 37# "expl:Integer cast"
        (Unsafe_uint32.of_int (0))));
        begin
        (right :=
         (Unsafe_int64.(-) 
          (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 21 17 24#
          "expl:Integer cast" (Unsafe_int64_of_Unsafe_uint32.cast  n_2 ))
          (#"whole_program.jc" 624 48 60# "expl:Integer cast"
          (Unsafe_int64.of_int (1))) ));
         'Loop_9:
         loop
         invariant
           { ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 23 22 31#
              ((<=) (0) (Uint32.to_int !left)))
             &&
             ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 24 22 31#
              ((<) (Int64.to_int !right) (Uint32.to_int n_2)))
             &&
             ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 26 22 89#
              (forall i_6_0 : int.
               ((((<=) (0) i_6_0) /\
                (((<) i_6_0 (Uint32.to_int n_2)) /\
                (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_6_0)) key)))
                ->
                (((<=) (Uint32.to_int !left) i_6_0) /\
                ((<=) i_6_0 (Int64.to_int !right))))))
             &&
             (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 27 22 97#
             (forall i_7 : int.
              ((((<=) (0) i_7) /\
               (((<) i_7 (Uint32.to_int n_2)) /\
               (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_7)) key))) ->
               ((Int32.(<=)
                (select intP_intM_a_4_12 (shift a_4 (Uint32.to_int !left)))
                key)
               /\
               (Int32.(<=) key
               (select intP_intM_a_4_12 (shift a_4 (Int64.to_int !right))))))))))) }
           
          begin
          any unit requires { true } ensures { true } ;
           try
            begin
            begin
            (if
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 30 10 23#
            (Unsafe_int64.(<=) 
             (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 30 10 14#
             "expl:Integer cast"
             (Unsafe_int64_of_Unsafe_uint32.cast  !left )) !right )) 
            then () else (raise (Goto_while_0_break_exc ())));
             begin
             (m :=
              (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 19 44#
              "expl:Integer cast"
              (Unsafe_uint32_of_Unsafe_int64.cast 
               (Unsafe_int64.(+) 
                (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 19 23#
                "expl:Integer cast"
                (Unsafe_int64_of_Unsafe_uint32.cast  !left ))
                (Unsafe_int64.(/) 
                 (Unsafe_int64.(-)  !right
                  (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 31 35 39#
                  "expl:Integer cast"
                  (Unsafe_int64_of_Unsafe_uint32.cast  !left )) )
                 (#"whole_program.jc" 655 66 78# "expl:Integer cast"
                 (Unsafe_int64.of_int (2))) ) ) )));
              (if
              (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 33 10 20#
              (Unsafe_int32.(<) 
               (acc  intP_intM_a_4_12
                (shift_  a_4 (Unsafe_uint32.to_int  !m ) ) ) key ))
              then
               (left :=
                (Unsafe_uint32.(+)  !m
                 (#"whole_program.jc" 657 59 72# "expl:Integer cast"
                 (Unsafe_uint32.of_int (1))) ))
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 35 17 27#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_4_12
                 (shift_  a_4 (Unsafe_uint32.to_int  !m ) ) ) key ))
               then
                (right :=
                 (Unsafe_int64.(-) 
                  (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 36 18 25#
                  "expl:Integer cast"
                  (Unsafe_int64_of_Unsafe_uint32.cast  !m ))
                  (#"whole_program.jc" 660 57 69# "expl:Integer cast"
                  (Unsafe_int64.of_int (1))) ))
               else
                begin
                (__retres_0 := (shift_  a_4 (Unsafe_uint32.to_int  !m ) ));
                 (raise (Return_label_exc ())) end)) end end;
             (raise (Loop_continue_exc ())) end with Loop_continue_exc
            _jessie_23 -> () end end end; (raise (Goto_while_0_break_exc ()))
        end end with Goto_while_0_break_exc _jessie_20 ->
       'While_0_break: 'While_0_break: begin (); (__retres_0 := (null  )) end
       end; (raise (Return_label_exc ())) end with Return_label_exc
      _jessie_21 ->
      'Return_label:
      'Return_label: begin (return := !__retres_0); (raise Return) end end))));
     absurd  end with Return -> !return end)
  
end

module Function_distance_safety

  use enum.Uint32 
  
  use Safe_uint32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let distance
  #"/home/work/workspace/education/acsl-exam/./distance.c" 7 9 41#
  "expl:Function distance, safety" =
  fun (a_5 : Uint32.t) (b_2_0 : Uint32.t) 
   requires { (true) } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_uint32.any_  () ) in
   try
    begin
    (let tmp = ref (Safe_uint32.any_  () ) in
    begin
    (if
    (#"/home/work/workspace/education/acsl-exam/./distance.c" 9 11 16#
    (Safe_uint32.(>)  a_5 b_2_0 ))
    then
     (tmp :=
      (let _jessie_200 = (Safe_uint32.(-)  a_5 b_2_0 ) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./distance.c" 9 10 37#
      "expl:Pointer index bounds" true) }); _jessie_200 end))
    else
     (tmp :=
      (let _jessie_199 = (Safe_uint32.(-)  b_2_0 a_5 ) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./distance.c" 9 10 37#
      "expl:Pointer index bounds" true) }); _jessie_199 end)));
     begin
     (return :=
      (let _jessie_201 = !tmp in
      begin
      (assert {
      (#"whole_program.jc" 692 7 17# "expl:Pointer index bounds" true) });
       _jessie_201 end)); (raise Return) end end); absurd  end with Return ->
    !return end)
  
end

module Function_distance_behaviors

  use Unsafe_uint32 
  
  use enum.Uint32 
  
  use import ref.Ref 
  
  use int.MinMax 
  
  use import core.Jessie_return 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let distance_ensures_default
  #"/home/work/workspace/education/acsl-exam/./distance.c" 7 9 41#
  "expl:Function distance, default behavior" =
  fun (a_5 : Uint32.t) (b_2_0 : Uint32.t) 
   requires { (true) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./distance.c" 5 12 46#
     "expl:Ensures clause"
     ((=) (Uint32.to_int result)
     (Int.(-) (MinMax.max (Uint32.to_int a_5) (Uint32.to_int b_2_0))
     (MinMax.min (Uint32.to_int a_5) (Uint32.to_int b_2_0)))))) }  ->
   'Init:
   (let return = ref (Unsafe_uint32.any_  () ) in
   try
    begin
    (let tmp = ref (Unsafe_uint32.any_  () ) in
    begin
    (if
    (#"/home/work/workspace/education/acsl-exam/./distance.c" 9 11 16#
    (Unsafe_uint32.(>)  a_5 b_2_0 ))
    then (tmp := (Unsafe_uint32.(-)  a_5 b_2_0 ))
    else (tmp := (Unsafe_uint32.(-)  b_2_0 a_5 )));
     begin (return := !tmp); (raise Return) end end); absurd  end with Return
    -> !return end)
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Function_distance_abs_safety

  use enum.Uint32 
  
  use Safe_uint32_of_Safe_int32 
  
  use Safe_uint32 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let distance_abs
  #"/home/work/workspace/education/acsl-exam/./distance_abs.c" 11 9 35#
  "expl:Function distance_abs, safety" =
  fun (a_6 : Int32.t) (b_3 : Int32.t) 
   requires {
   (#"whole_program.jc" 697 12 157#
   ((#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 5 13 18#
    ((=) true true))
   /\
   (#"whole_program.jc" 697 12 157#
   ((#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 6 13 28#
    ((>) (Int32.to_int a_6) (Int.(-_) (2147483648))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 7 13 28#
   ((>) (Int32.to_int b_3) (Int.(-_) (2147483648)))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_uint32.any_  () ) in
   try
    begin
    (let ua = ref (Safe_uint32.any_  () ) in
    (let tmp_0 = ref (Safe_int32.any_  () ) in
    (let ub = ref (Safe_uint32.any_  () ) in
    (let tmp_0_0 = ref (Safe_int32.any_  () ) in
    (let tmp_1 = ref (Safe_uint32.any_  () ) in
    begin
    (if
    (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 13 17 22#
    (Safe_int32.(<)  a_6
     (#"whole_program.jc" 716 27 39# "expl:Integer cast"
     (Safe_int32.of_int (0))) ))
    then
     (tmp_0 :=
      (let _jessie_212 = (Safe_int32.(-_)  a_6 ) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 13 17 31#
      "expl:Pointer index bounds" true) }); _jessie_212 end))
    else
     (tmp_0 :=
      (let _jessie_211 = a_6 in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 13 17 31#
      "expl:Pointer index bounds" true) }); _jessie_211 end)));
     begin
     (ua :=
      (let _jessie_213 =
      (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 13 17 31#
      "expl:Integer cast" (Safe_uint32_of_Safe_int32.cast  !tmp_0 )) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 13 3 11#
      "expl:Pointer index bounds" true) }); _jessie_213 end));
      (if
      (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 14 17 22#
      (Safe_int32.(<)  b_3
       (#"whole_program.jc" 721 27 39# "expl:Integer cast"
       (Safe_int32.of_int (0))) ))
      then
       (tmp_0_0 :=
        (let _jessie_215 = (Safe_int32.(-_)  b_3 ) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 14 17 31#
        "expl:Pointer index bounds" true) }); _jessie_215 end))
      else
       (tmp_0_0 :=
        (let _jessie_214 = b_3 in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 14 17 31#
        "expl:Pointer index bounds" true) }); _jessie_214 end)));
      begin
      (ub :=
       (let _jessie_216 =
       (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 14 17 31#
       "expl:Integer cast" (Safe_uint32_of_Safe_int32.cast  !tmp_0_0 )) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 14 3 11#
       "expl:Pointer index bounds" true) }); _jessie_216 end));
       (if
       (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 18 10 17#
       (Safe_uint32.(>)  !ua !ub ))
       then
        (tmp_1 :=
         (let _jessie_218 = (Safe_uint32.(-)  !ua !ub ) in
         begin
         (assert {
         (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 18 10 37#
         "expl:Pointer index bounds" true) }); _jessie_218 end))
       else
        (tmp_1 :=
         (let _jessie_217 = (Safe_uint32.(-)  !ub !ua ) in
         begin
         (assert {
         (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 18 10 37#
         "expl:Pointer index bounds" true) }); _jessie_217 end)));
       begin
       (return :=
        (let _jessie_219 = !tmp_1 in
        begin
        (assert {
        (#"whole_program.jc" 731 7 19# "expl:Pointer index bounds" true) });
         _jessie_219 end)); (raise Return) end end end end))))); absurd  end
    with Return -> !return end)
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Function_distance_abs_behaviors

  use Unsafe_uint32_of_Unsafe_int32 
  
  use Unsafe_uint32 
  
  use Unsafe_int32 
  
  use enum.Uint32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.Abs 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let distance_abs_ensures_default
  #"/home/work/workspace/education/acsl-exam/./distance_abs.c" 11 9 35#
  "expl:Function distance_abs, default behavior" =
  fun (a_6 : Int32.t) (b_3 : Int32.t) 
   requires {
   (#"whole_program.jc" 697 12 157#
   ((#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 5 13 18#
    ((=) true true))
   /\
   (#"whole_program.jc" 697 12 157#
   ((#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 6 13 28#
    ((>) (Int32.to_int a_6) (Int.(-_) (2147483648))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 7 13 28#
   ((>) (Int32.to_int b_3) (Int.(-_) (2147483648)))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 9 12 46#
     "expl:Ensures clause"
     ((=) (Uint32.to_int result)
     (Abs.abs
     (Int.(-) (Abs.abs (Int32.to_int a_6)) (Abs.abs (Int32.to_int b_3)))))))
     }  ->
   'Init:
   (let return = ref (Unsafe_uint32.any_  () ) in
   try
    begin
    (let ua = ref (Unsafe_uint32.any_  () ) in
    (let tmp_0 = ref (Unsafe_int32.any_  () ) in
    (let ub = ref (Unsafe_uint32.any_  () ) in
    (let tmp_0_0 = ref (Unsafe_int32.any_  () ) in
    (let tmp_1 = ref (Unsafe_uint32.any_  () ) in
    begin
    (if
    (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 13 17 22#
    (Unsafe_int32.(<)  a_6
     (#"whole_program.jc" 716 27 39# "expl:Integer cast"
     (Unsafe_int32.of_int (0))) )) then (tmp_0 := (Unsafe_int32.(-_)  a_6 ))
    else (tmp_0 := a_6));
     begin
     (ua :=
      (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 13 17 31#
      "expl:Integer cast" (Unsafe_uint32_of_Unsafe_int32.cast  !tmp_0 )));
      (if
      (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 14 17 22#
      (Unsafe_int32.(<)  b_3
       (#"whole_program.jc" 721 27 39# "expl:Integer cast"
       (Unsafe_int32.of_int (0))) ))
      then (tmp_0_0 := (Unsafe_int32.(-_)  b_3 )) else (tmp_0_0 := b_3));
      begin
      (ub :=
       (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 14 17 31#
       "expl:Integer cast" (Unsafe_uint32_of_Unsafe_int32.cast  !tmp_0_0 )));
       (if
       (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 18 10 17#
       (Unsafe_uint32.(>)  !ua !ub ))
       then (tmp_1 := (Unsafe_uint32.(-)  !ua !ub ))
       else (tmp_1 := (Unsafe_uint32.(-)  !ub !ua )));
       begin (return := !tmp_1); (raise Return) end end end end))))); 
     absurd  end with Return -> !return end)
  
end

theory Axiomatic_Factorial

  use import int.Int 
  
  use why3.Bool.Bool 
  
  function factorial int : int
  
  axiom Nil_0
  #"/home/work/workspace/education/acsl-exam/./factorial.c" 4 7 24#
  "expl:Axiom nil" :
  (#"/home/work/workspace/education/acsl-exam/./factorial.c" 4 7 24#
  ((=) (factorial (0)) (1)))
  
  axiom Step
  #"/home/work/workspace/education/acsl-exam/./factorial.c" 6 7 83#
  "expl:Axiom step" :
  (#"/home/work/workspace/education/acsl-exam/./factorial.c" 6 7 83#
  (forall i_13 : int.
   (((>=) i_13 (0)) ->
    ((=) (factorial i_13) (Int.( *) (factorial (Int.(-) i_13 (1))) i_13)))))
  
  lemma Non_negative
  #"/home/work/workspace/education/acsl-exam/./factorial.c" 10 7 63#
  "expl:Lemma non_negative" :
  (#"/home/work/workspace/education/acsl-exam/./factorial.c" 10 7 63#
  (forall i_14 : int. (((>=) i_14 (0)) -> ((>) (factorial i_14) (0)))))
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Function_factorial_0_safety

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Safe_uint64_of_Safe_uint32 
  
  use Safe_uint64 
  
  use Safe_uint32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_Factorial 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let factorial_0
  #"/home/work/workspace/education/acsl-exam/./factorial.c" 21 14 35#
  "expl:Function factorial, safety" =
  fun (i : Uint32.t) 
   requires {
   (#"/home/work/workspace/education/acsl-exam/./factorial.c" 17 13 51#
   ((<=) (factorial (Uint32.to_int i)) (18446744073709551615))) }
   ensures { ("expl:Postcondition" true) }  ->
   (let mutable_i = ref i in
   'Init:
   (let return = ref (Safe_uint64.any_  () ) in
   try
    begin
    (let f_0 = ref (Safe_uint64.any_  () ) in
    (let tmp_1_0 = ref (Safe_uint32.any_  () ) in
    try
     begin
     (f_0 :=
      (let _jessie_225 =
      (#"whole_program.jc" 764 21 34# "expl:Integer cast"
      (Safe_uint64.of_int (1))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./factorial.c" 23 3 11#
      "expl:Pointer index bounds" true) }); _jessie_225 end));
      'Loop_14:
      loop
      invariant { (#"whole_program.jc" 766 6 691# true) }
        variant {
          (#"/home/work/workspace/education/acsl-exam/./factorial.c" 26 20 21#
          (Uint32.to_int
          (#"/home/work/workspace/education/acsl-exam/./factorial.c" 26 20 21#
          !mutable_i))) }
       begin
       any unit
       requires { true } reads { mutable_i }
       ensures {
         (#"/home/work/workspace/education/acsl-exam/./factorial.c" 24 22 28#
         ((<=) (0) (Uint32.to_int !mutable_i))) } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./factorial.c" 28 10 11#
         (Safe_uint32.(<>)  !mutable_i
          (#"whole_program.jc" 776 44 57# "expl:Integer cast"
          (Safe_uint32.of_int (0))) )) then ()
         else (raise (Goto_while_0_break_exc ())));
          begin
          (tmp_1_0 :=
           (let _jessie_226 = !mutable_i in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./factorial.c" 29 11 14#
           "expl:Pointer index bounds" true) }); _jessie_226 end));
           begin
           (mutable_i :=
            (let _jessie_227 =
            (Safe_uint32.(-)  !mutable_i
             (#"whole_program.jc" 781 59 72# "expl:Integer cast"
             (Safe_uint32.of_int (1))) ) in
            begin
            (assert {
            (#"/home/work/workspace/education/acsl-exam/./factorial.c" 29 11 14#
            "expl:Pointer index bounds" true) }); _jessie_227 end));
            (f_0 :=
             (let _jessie_228 =
             (Safe_uint64.( *)  !f_0
              (#"/home/work/workspace/education/acsl-exam/./factorial.c" 29 11 14#
              "expl:Integer cast"
              (Safe_uint64_of_Safe_uint32.cast  !tmp_1_0 )) ) in
             begin
             (assert {
             (#"/home/work/workspace/education/acsl-exam/./factorial.c" 29 6 14#
             "expl:Pointer index bounds" true) }); _jessie_228 end)) end end
         end; (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_26 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_24 ->
     'While_0_break:
     'While_0_break:
     begin
     ();
      begin
      (return :=
       (let _jessie_229 = !f_0 in
       begin
       (assert {
       (#"whole_program.jc" 790 7 15# "expl:Pointer index bounds" true) });
        _jessie_229 end)); (raise Return) end end end)); absurd  end with
    Return -> !return end))
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Function_factorial_0_behaviors

  use Unsafe_uint64_of_Unsafe_uint32 
  
  use Unsafe_uint64 
  
  use Unsafe_uint32 
  
  use enum.Uint64 
  
  use enum.Uint32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_Factorial 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let factorial_ensures_default
  #"/home/work/workspace/education/acsl-exam/./factorial.c" 21 14 35#
  "expl:Function factorial, default behavior" =
  fun (i : Uint32.t) 
   requires {
   (#"/home/work/workspace/education/acsl-exam/./factorial.c" 17 13 51#
   ((<=) (factorial (Uint32.to_int i)) (18446744073709551615))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./factorial.c" 19 12 35#
     "expl:Ensures clause"
     ((=) (Uint64.to_int result) (factorial (Uint32.to_int i))))) } diverges 
   ->
   (let mutable_i = ref i in
   'Init:
   (let return = ref (Unsafe_uint64.any_  () ) in
   try
    begin
    (let f_0 = ref (Unsafe_uint64.any_  () ) in
    (let tmp_1_0 = ref (Unsafe_uint32.any_  () ) in
    try
     begin
     (f_0 :=
      (#"whole_program.jc" 764 21 34# "expl:Integer cast"
      (Unsafe_uint64.of_int (1))));
      'Loop_13:
      loop
      invariant
        { (#"/home/work/workspace/education/acsl-exam/./factorial.c" 24 22 28#
          ((<=) (0) (Uint32.to_int !mutable_i))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./factorial.c" 28 10 11#
         (Unsafe_uint32.(<>)  !mutable_i
          (#"whole_program.jc" 776 44 57# "expl:Integer cast"
          (Unsafe_uint32.of_int (0))) )) then ()
         else (raise (Goto_while_0_break_exc ())));
          begin
          (tmp_1_0 := !mutable_i);
           begin
           (mutable_i :=
            (Unsafe_uint32.(-)  !mutable_i
             (#"whole_program.jc" 781 59 72# "expl:Integer cast"
             (Unsafe_uint32.of_int (1))) ));
            (f_0 :=
             (Unsafe_uint64.( *)  !f_0
              (#"/home/work/workspace/education/acsl-exam/./factorial.c" 29 11 14#
              "expl:Integer cast"
              (Unsafe_uint64_of_Unsafe_uint32.cast  !tmp_1_0 )) )) end end
         end; (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_26 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_24 ->
     'While_0_break:
     'While_0_break: begin (); begin (return := !f_0); (raise Return) end end
     end)); absurd  end with Return -> !return end))
  
end

module Function_factorial_rec_safe

  use enum.Uint64 
  
  use enum.Uint32 
  
  use import Logic_factorial_ind 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val factorial_rec
  (i_0 : Uint32.t) : Uint64.t
   requires {
     ("expl:Internal"
     (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 18 13 20#
     "expl:Requires clause" ((<=) (Uint32.to_int i_0) (20)))) }
   ensures {
     (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 21 12 37#
     "expl:Ensures clause"
     (factorial_ind (Uint32.to_int i_0) (Uint64.to_int result))) }
  
end

module Function_factorial_rec_safety

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Safe_uint64_of_Safe_uint32 
  
  use Safe_uint64 
  
  use Safe_uint32 
  
  use import ref.Ref 
  
  use import core.Jessie_zwf 
  
  use import core.Jessie_return 
  
  use import int.Int 
  
  use Function_factorial_rec_safe 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let factorial_rec
  #"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 23 14 39#
  "expl:Function factorial_rec, safety" =
  fun (i_0 : Uint32.t) 
   requires {
   (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 18 13 20#
   ((<=) (Uint32.to_int i_0) (20))) } ensures { ("expl:Postcondition" true) }
    ->
   'Init:
   (let return = ref (Safe_uint64.any_  () ) in
   try
    begin
    (let tmp_1_1 = ref (Safe_uint64.any_  () ) in
    (let __retres_1 = ref (Safe_uint64.any_  () ) in
    try
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 25 7 13#
     (Safe_uint32.(=)  i_0
      (#"whole_program.jc" 828 28 41# "expl:Integer cast"
      (Safe_uint32.of_int (0))) ))
     then
      begin
      (__retres_1 :=
       (let _jessie_238 =
       (#"whole_program.jc" 829 33 46# "expl:Integer cast"
       (Safe_uint64.of_int (1))) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 26 6 15#
       "expl:Pointer index bounds" true) }); _jessie_238 end));
       (raise (Return_label_exc ())) end
     else
      begin
      begin
      (tmp_1_1 :=
       (let _jessie_235 =
       (let _jessie_236 =
       (Safe_uint32.(-)  i_0
        (#"whole_program.jc" 836 68 81# "expl:Integer cast"
        (Safe_uint32.of_int (1))) ) in
       (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 28 13 33#
       "expl:Variant decreases"
       begin
       (check {
       (zwf_zero
       (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 19 14 15#
       (Uint32.to_int
       (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 19 14 15#
       _jessie_236)))
       (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 19 14 15#
       (Uint32.to_int
       (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 19 14 15#
       i_0)))) });
        (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 28 13 33#
        "expl:Precondition for factorial_rec"
        (Function_factorial_rec_safe.factorial_rec  _jessie_236 )) end)) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 28 13 33#
       "expl:Pointer index bounds" true) }); _jessie_235 end)); () end;
       begin
       (__retres_1 :=
        (let _jessie_237 =
        (Safe_uint64.( *)  !tmp_1_1
         (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 28 36 37#
         "expl:Integer cast" (Safe_uint64_of_Safe_uint32.cast  i_0 )) ) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 28 6 38#
        "expl:Pointer index bounds" true) }); _jessie_237 end));
        (raise (Return_label_exc ())) end end); (raise (Return_label_exc ()))
     end with Return_label_exc _jessie_27 ->
     'Return_label:
     'Return_label:
     begin
     (return :=
      (let _jessie_239 = !__retres_1 in
      begin
      (assert {
      (#"whole_program.jc" 845 7 24# "expl:Pointer index bounds" true) });
       _jessie_239 end)); (raise Return) end end)); absurd  end with Return
    -> !return end)
  
end

module Function_factorial_rec

  use enum.Uint64 
  
  use enum.Uint32 
  
  use import Logic_factorial_ind 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val factorial_rec
  (i_0 : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 21 12 37#
     "expl:Ensures clause"
     (factorial_ind (Uint32.to_int i_0) (Uint64.to_int result))) }
  
end

module Function_factorial_rec_behaviors

  use Unsafe_uint64_of_Unsafe_uint32 
  
  use Unsafe_uint64 
  
  use Unsafe_uint32 
  
  use enum.Uint64 
  
  use enum.Uint32 
  
  use import ref.Ref 
  
  use import Logic_factorial_ind 
  
  use import core.Jessie_return 
  
  use import int.Int 
  
  use Function_factorial_rec 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let factorial_rec_ensures_default
  #"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 23 14 39#
  "expl:Function factorial_rec, default behavior" =
  fun (i_0 : Uint32.t) 
   requires {
   (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 18 13 20#
   ((<=) (Uint32.to_int i_0) (20))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 21 12 37#
     "expl:Ensures clause"
     (factorial_ind (Uint32.to_int i_0) (Uint64.to_int result)))) }  ->
   'Init:
   (let return = ref (Unsafe_uint64.any_  () ) in
   try
    begin
    (let tmp_1_1 = ref (Unsafe_uint64.any_  () ) in
    (let __retres_1 = ref (Unsafe_uint64.any_  () ) in
    try
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 25 7 13#
     (Unsafe_uint32.(=)  i_0
      (#"whole_program.jc" 828 28 41# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      begin
      (__retres_1 :=
       (#"whole_program.jc" 829 33 46# "expl:Integer cast"
       (Unsafe_uint64.of_int (1)))); (raise (Return_label_exc ())) end
     else
      begin
      begin
      (tmp_1_1 :=
       (let _jessie_231 =
       (Unsafe_uint32.(-)  i_0
        (#"whole_program.jc" 836 68 81# "expl:Integer cast"
        (Unsafe_uint32.of_int (1))) ) in
       (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 28 13 33#
       "expl:Precondition for factorial_rec"
       (Function_factorial_rec.factorial_rec  _jessie_231 )))); () end;
       begin
       (__retres_1 :=
        (Unsafe_uint64.( *)  !tmp_1_1
         (#"/home/work/workspace/education/acsl-exam/./factorial_rec.c" 28 36 37#
         "expl:Integer cast" (Unsafe_uint64_of_Unsafe_uint32.cast  i_0 )) ));
        (raise (Return_label_exc ())) end end); (raise (Return_label_exc ()))
     end with Return_label_exc _jessie_27 ->
     'Return_label:
     'Return_label: begin (return := !__retres_1); (raise Return) end end));
     absurd  end with Return -> !return end)
  
end

theory Axiomatic_Power

  use import int.Int 
  
  use why3.Bool.Bool 
  
  function power_int_pos int int : int
  
  axiom Power_nil
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 4 7 60#
  "expl:Axiom power_nil" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 4 7 60#
  (forall b_8 : int. ((=) (power_int_pos b_8 (0)) (1))))
  
  axiom Power_step
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 7 7 100#
  "expl:Axiom power_step" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 7 7 100#
  (forall b_9 : int.
   (forall p_0_1 : int.
    (((>=) p_0_1 (0)) ->
     ((=) (power_int_pos b_9 (Int.(+) p_0_1 (1)))
     (Int.( *) b_9 (power_int_pos b_9 p_0_1)))))))
  
  lemma Power_alt_step
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 10 7 99#
  "expl:Lemma power_alt_step" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 10 7 99#
  (forall b_10 : int.
   (forall p_1_0 : int.
    (((>) p_1_0 (0)) ->
     ((=) (power_int_pos b_10 p_1_0)
     (Int.( *) b_10 (power_int_pos b_10 (Int.(-) p_1_0 (1)))))))))
  
  lemma Power_one
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 13 7 60#
  "expl:Lemma power_one" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 13 7 60#
  (forall b_11 : int. ((=) (power_int_pos b_11 (1)) b_11)))
  
  lemma Power_sum
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 16 7 139#
  "expl:Lemma power_sum" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 16 7 139#
  (forall b_12 : int.
   (forall p1_1 : int.
    (forall p2_1 : int.
     ((((>=) p1_1 (0)) /\ ((>=) p2_1 (0))) ->
      ((=) (power_int_pos b_12 (Int.(+) p1_1 p2_1))
      (Int.( *) (power_int_pos b_12 p1_1) (power_int_pos b_12 p2_1))))))))
  
  lemma Power_mult_1
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 19 7 135#
  "expl:Lemma power_mult_1" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 19 7 135#
  (forall b_13 : int.
   (forall p1_2 : int.
    (forall p2_2 : int.
     ((((>=) p1_2 (0)) /\ ((>=) p2_2 (0))) ->
      ((=) (power_int_pos b_13 (Int.( *) p1_2 p2_2))
      (power_int_pos (power_int_pos b_13 p1_2) p2_2)))))))
  
  lemma Power_mult_2
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 22 7 127#
  "expl:Lemma power_mult_2" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 22 7 127#
  (forall b1 : int.
   (forall b2 : int.
    (forall p_2_0 : int.
     (((>=) p_2_0 (0)) ->
      ((=) (power_int_pos (Int.( *) b1 b2) p_2_0)
      (Int.( *) (power_int_pos b1 p_2_0) (power_int_pos b2 p_2_0))))))))
  
  lemma Power_non_negative
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 25 7 74#
  "expl:Lemma power_non_negative" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 25 7 74#
  (forall b_14 : int.
   (forall p_3 : int.
    ((((>=) b_14 (0)) /\ ((>=) p_3 (0))) ->
     ((>=) (power_int_pos b_14 p_3) (0))))))
  
  lemma Power_monotonic
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 27 7 105#
  "expl:Lemma power_monotonic" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 27 7 105#
  (forall b_15 : int.
   (forall p1_3 : int.
    (forall p2_3 : int.
     ((((>) b_15 (0)) /\ (((<=) (0) p1_3) /\ ((<=) p1_3 p2_3))) ->
      ((<=) (power_int_pos b_15 p1_3) (power_int_pos b_15 p2_3)))))))
  
end

theory Axiomatic_Fib

  use import int.Int 
  
  use import Axiomatic_Power 
  
  use int.Abs 
  
  use why3.Bool.Bool 
  
  function fib int : int
  
  axiom Fib_nil
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 34 7 18#
  "expl:Axiom fib_nil" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 34 7 18#
  ((=) (fib (0)) (0)))
  
  axiom Fib_one
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 36 7 18#
  "expl:Axiom fib_one" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 36 7 18#
  ((=) (fib (1)) (1)))
  
  axiom Fib_step_positive
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 38 7 80#
  "expl:Axiom fib_step_positive" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 38 7 80#
  (forall i_18 : int.
   (((>=) i_18 (2)) ->
    ((=) (fib i_18)
    (Int.(+) (fib (Int.(-) i_18 (1))) (fib (Int.(-) i_18 (2))))))))
  
  axiom Fib_step_negative
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 41 7 79#
  "expl:Axiom fib_step_negative" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 41 7 79#
  (forall i_19 : int.
   (((<) i_19 (0)) ->
    ((=) (fib i_19)
    (Int.(-) (fib (Int.(+) i_19 (2))) (fib (Int.(+) i_19 (1))))))))
  
  lemma Fib_non_negative
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 44 7 58#
  "expl:Lemma fib_non_negative" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 44 7 58#
  (forall i_20 : int. (((>=) i_20 (0)) -> ((>=) (fib i_20) (0)))))
  
  lemma Fib_non_negative_increasing
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 47 7 86#
  "expl:Lemma fib_non_negative_increasing" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 47 7 86#
  (forall i_21 : int.
   (forall j_3 : int.
    ((((>=) i_21 (0)) /\ (((>=) j_3 (0)) /\ ((>=) i_21 j_3))) ->
     ((>=) (fib i_21) (fib j_3))))))
  
  lemma Fib_negative_positive_1
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 50 7 90#
  "expl:Lemma fib_negative_positive_1" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 50 7 90#
  (forall i_22 : int.
   (((<) i_22 (0)) ->
    ((=) (fib i_22)
    (Int.( *) (power_int_pos (Int.(-_) (1)) (Int.(+) i_22 (1)))
    (fib (Int.(-_) i_22)))))))
  
  lemma Fib_negative_positive_2
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 53 7 69#
  "expl:Lemma fib_negative_positive_2" :
  (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 53 7 69#
  (forall i_23 : int.
   (((<) i_23 (0)) -> ((=) (Abs.abs (fib i_23)) (fib (Int.(-_) i_23))))))
  
end

module Function_fib_rec_safe

  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Fib 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val fib_rec
  (i_1 : Int32.t) : Int32.t
   requires {
     ("expl:Internal"
     (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 13 48#
     "expl:Requires clause"
     (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 13 48#
     "expl:Requires clause"
     ((#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 13 34#
      "expl:Requires clause"
      ((<=) (Int.(-_) (2147483648)) (fib (Int32.to_int i_1))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 28 48#
     "expl:Requires clause" ((<=) (fib (Int32.to_int i_1)) (2147483647)))))))
     }
   ensures {
     (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 64 12 29#
     "expl:Ensures clause"
     ((=) (Int32.to_int result) (fib (Int32.to_int i_1)))) }
  
end

module Function_fib_rec_safety

  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_zwf 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_fib_rec_safe 
  
  use import Exceptions 
  
  use import Axiomatic_Fib 
  
  use int.Abs 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let fib_rec
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 66 4 18#
  "expl:Function fib_rec, safety" =
  fun (i_1 : Int32.t) 
   requires {
   (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 13 48#
   (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 13 48#
   ((#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 13 34#
    ((<=) (Int.(-_) (2147483648)) (fib (Int32.to_int i_1))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 28 48#
   ((<=) (fib (Int32.to_int i_1)) (2147483647)))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_int32.any_  () ) in
   try
    begin
    (let tmp_1_2 = ref (Safe_int32.any_  () ) in
    (let tmp_0_1 = ref (Safe_int32.any_  () ) in
    (let tmp_1_3 = ref (Safe_int32.any_  () ) in
    (let tmp_2 = ref (Safe_int32.any_  () ) in
    (let __retres_2 = ref (Safe_int32.any_  () ) in
    try
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 68 7 13#
     (Safe_int32.(=)  i_1
      (#"whole_program.jc" 974 28 40# "expl:Integer cast"
      (Safe_int32.of_int (0))) ))
     then
      begin
      (__retres_2 :=
       (let _jessie_255 = i_1 in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 68 25 34#
       "expl:Pointer index bounds" true) }); _jessie_255 end));
       (raise (Return_label_exc ())) end
     else
      (if
      (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 68 17 23#
      (Safe_int32.(=)  i_1
       (#"whole_program.jc" 978 35 47# "expl:Integer cast"
       (Safe_int32.of_int (1))) ))
      then
       begin
       (__retres_2 :=
        (let _jessie_254 = i_1 in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 68 25 34#
        "expl:Pointer index bounds" true) }); _jessie_254 end));
        (raise (Return_label_exc ())) end else ()));
      (if
      (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 69 7 14#
      (Safe_int32.(=)  i_1
       (#"whole_program.jc" 983 28 41# "expl:Integer cast"
       (Safe_int32.of_int  (Int.(-_)  (1) ) )) ))
      then
       begin
       (__retres_2 :=
        (let _jessie_256 =
        (#"whole_program.jc" 984 33 45# "expl:Integer cast"
        (Safe_int32.of_int (1))) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 69 16 25#
        "expl:Pointer index bounds" true) }); _jessie_256 end));
        (raise (Return_label_exc ())) end else ());
      (if
      (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 71 7 12#
      (Safe_int32.(>)  i_1
       (#"whole_program.jc" 988 27 39# "expl:Integer cast"
       (Safe_int32.of_int (0))) ))
      then
       begin
       begin
       (tmp_1_2 :=
        (let _jessie_262 =
        (let _jessie_263 =
        (Safe_int32.(-)  i_1
         (#"whole_program.jc" 992 64 76# "expl:Integer cast"
         (Safe_int32.of_int (1))) ) in
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 72 13 27#
        "expl:Variant decreases"
        begin
        (check {
        (zwf_zero
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 62 14 21#
        (Abs.abs (Int32.to_int _jessie_263)))
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 62 14 21#
        (Abs.abs (Int32.to_int i_1)))) });
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 72 13 27#
         "expl:Precondition for fib_rec"
         (Function_fib_rec_safe.fib_rec  _jessie_263 )) end)) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 72 13 27#
        "expl:Pointer index bounds" true) }); _jessie_262 end));
        (tmp_0_1 :=
         (let _jessie_264 =
         (let _jessie_265 =
         (Safe_int32.(-)  i_1
          (#"whole_program.jc" 995 64 76# "expl:Integer cast"
          (Safe_int32.of_int (2))) ) in
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 72 30 44#
         "expl:Variant decreases"
         begin
         (check {
         (zwf_zero
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 62 14 21#
         (Abs.abs (Int32.to_int _jessie_265)))
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 62 14 21#
         (Abs.abs (Int32.to_int i_1)))) });
          (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 72 30 44#
          "expl:Precondition for fib_rec"
          (Function_fib_rec_safe.fib_rec  _jessie_265 )) end)) in
         begin
         (assert {
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 72 30 44#
         "expl:Pointer index bounds" true) }); _jessie_264 end)) end;
        begin
        (__retres_2 :=
         (let _jessie_266 = (Safe_int32.(+)  !tmp_1_2 !tmp_0_1 ) in
         begin
         (assert {
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 72 6 45#
         "expl:Pointer index bounds" true) }); _jessie_266 end));
         (raise (Return_label_exc ())) end end
      else
       begin
       begin
       (tmp_1_3 :=
        (let _jessie_257 =
        (let _jessie_258 =
        (Safe_int32.(+)  i_1
         (#"whole_program.jc" 1004 64 76# "expl:Integer cast"
         (Safe_int32.of_int (2))) ) in
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 74 13 27#
        "expl:Variant decreases"
        begin
        (check {
        (zwf_zero
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 62 14 21#
        (Abs.abs (Int32.to_int _jessie_258)))
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 62 14 21#
        (Abs.abs (Int32.to_int i_1)))) });
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 74 13 27#
         "expl:Precondition for fib_rec"
         (Function_fib_rec_safe.fib_rec  _jessie_258 )) end)) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 74 13 27#
        "expl:Pointer index bounds" true) }); _jessie_257 end));
        (tmp_2 :=
         (let _jessie_259 =
         (let _jessie_260 =
         (Safe_int32.(+)  i_1
          (#"whole_program.jc" 1007 62 74# "expl:Integer cast"
          (Safe_int32.of_int (1))) ) in
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 74 30 44#
         "expl:Variant decreases"
         begin
         (check {
         (zwf_zero
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 62 14 21#
         (Abs.abs (Int32.to_int _jessie_260)))
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 62 14 21#
         (Abs.abs (Int32.to_int i_1)))) });
          (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 74 30 44#
          "expl:Precondition for fib_rec"
          (Function_fib_rec_safe.fib_rec  _jessie_260 )) end)) in
         begin
         (assert {
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 74 30 44#
         "expl:Pointer index bounds" true) }); _jessie_259 end)) end;
        begin
        (__retres_2 :=
         (let _jessie_261 = (Safe_int32.(-)  !tmp_1_3 !tmp_2 ) in
         begin
         (assert {
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 74 6 45#
         "expl:Pointer index bounds" true) }); _jessie_261 end));
         (raise (Return_label_exc ())) end end);
      (raise (Return_label_exc ())) end with Return_label_exc _jessie_28 ->
     'Return_label:
     'Return_label:
     begin
     (return :=
      (let _jessie_267 = !__retres_2 in
      begin
      (assert {
      (#"whole_program.jc" 1014 7 24# "expl:Pointer index bounds" true) });
       _jessie_267 end)); (raise Return) end end))))); absurd  end with
    Return -> !return end)
  
end

module Function_fib_rec

  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Fib 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val fib_rec
  (i_1 : Int32.t) : Int32.t
   requires { true }
   ensures {
     (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 64 12 29#
     "expl:Ensures clause"
     ((=) (Int32.to_int result) (fib (Int32.to_int i_1)))) }
  
end

module Function_fib_rec_behaviors

  use Unsafe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_fib_rec 
  
  use import Exceptions 
  
  use import Axiomatic_Fib 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let fib_rec_ensures_default
  #"/home/work/workspace/education/acsl-exam/./fib_rec.c" 66 4 18#
  "expl:Function fib_rec, default behavior" =
  fun (i_1 : Int32.t) 
   requires {
   (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 13 48#
   (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 13 48#
   ((#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 13 34#
    ((<=) (Int.(-_) (2147483648)) (fib (Int32.to_int i_1))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 61 28 48#
   ((<=) (fib (Int32.to_int i_1)) (2147483647)))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 64 12 29#
     "expl:Ensures clause"
     ((=) (Int32.to_int result) (fib (Int32.to_int i_1))))) }  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (let tmp_1_2 = ref (Unsafe_int32.any_  () ) in
    (let tmp_0_1 = ref (Unsafe_int32.any_  () ) in
    (let tmp_1_3 = ref (Unsafe_int32.any_  () ) in
    (let tmp_2 = ref (Unsafe_int32.any_  () ) in
    (let __retres_2 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 68 7 13#
     (Unsafe_int32.(=)  i_1
      (#"whole_program.jc" 974 28 40# "expl:Integer cast"
      (Unsafe_int32.of_int (0))) ))
     then begin (__retres_2 := i_1); (raise (Return_label_exc ())) end
     else
      (if
      (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 68 17 23#
      (Unsafe_int32.(=)  i_1
       (#"whole_program.jc" 978 35 47# "expl:Integer cast"
       (Unsafe_int32.of_int (1))) ))
      then begin (__retres_2 := i_1); (raise (Return_label_exc ())) end
      else ()));
      (if
      (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 69 7 14#
      (Unsafe_int32.(=)  i_1
       (#"whole_program.jc" 983 28 41# "expl:Integer cast"
       (Unsafe_int32.of_int  (Int.(-_)  (1) ) )) ))
      then
       begin
       (__retres_2 :=
        (#"whole_program.jc" 984 33 45# "expl:Integer cast"
        (Unsafe_int32.of_int (1)))); (raise (Return_label_exc ())) end
      else ());
      (if
      (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 71 7 12#
      (Unsafe_int32.(>)  i_1
       (#"whole_program.jc" 988 27 39# "expl:Integer cast"
       (Unsafe_int32.of_int (0))) ))
      then
       begin
       begin
       (tmp_1_2 :=
        (let _jessie_249 =
        (Unsafe_int32.(-)  i_1
         (#"whole_program.jc" 992 64 76# "expl:Integer cast"
         (Unsafe_int32.of_int (1))) ) in
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 72 13 27#
        "expl:Precondition for fib_rec"
        (Function_fib_rec.fib_rec  _jessie_249 ))));
        (tmp_0_1 :=
         (let _jessie_251 =
         (Unsafe_int32.(-)  i_1
          (#"whole_program.jc" 995 64 76# "expl:Integer cast"
          (Unsafe_int32.of_int (2))) ) in
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 72 30 44#
         "expl:Precondition for fib_rec"
         (Function_fib_rec.fib_rec  _jessie_251 )))) end;
        begin
        (__retres_2 := (Unsafe_int32.(+)  !tmp_1_2 !tmp_0_1 ));
         (raise (Return_label_exc ())) end end
      else
       begin
       begin
       (tmp_1_3 :=
        (let _jessie_244 =
        (Unsafe_int32.(+)  i_1
         (#"whole_program.jc" 1004 64 76# "expl:Integer cast"
         (Unsafe_int32.of_int (2))) ) in
        (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 74 13 27#
        "expl:Precondition for fib_rec"
        (Function_fib_rec.fib_rec  _jessie_244 ))));
        (tmp_2 :=
         (let _jessie_246 =
         (Unsafe_int32.(+)  i_1
          (#"whole_program.jc" 1007 62 74# "expl:Integer cast"
          (Unsafe_int32.of_int (1))) ) in
         (#"/home/work/workspace/education/acsl-exam/./fib_rec.c" 74 30 44#
         "expl:Precondition for fib_rec"
         (Function_fib_rec.fib_rec  _jessie_246 )))) end;
        begin
        (__retres_2 := (Unsafe_int32.(-)  !tmp_1_3 !tmp_2 ));
         (raise (Return_label_exc ())) end end);
      (raise (Return_label_exc ())) end with Return_label_exc _jessie_28 ->
     'Return_label:
     'Return_label: begin (return := !__retres_2); (raise Return) end end)))));
     absurd  end with Return -> !return end)
  
end

theory Root_int_xP

  use why3.Bool.Bool 
  
  type int_xP 
  
end

module Function_max_max_safety

  use enum.Uint32 
  
  use import Struct_intP 
  
  use Safe_uint32 
  
  use Safe_int32 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let max_max
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 22 5 59#
  "expl:Function max_max, safety" =
  fun
   (a_7 : (pointer voidP)) (size_5 : Uint32.t) (max1 : (pointer int_xP))
   (max2 : (pointer int_xP)) (int_xP_int_xM_max1_15 : ref (memory int_xP
   (pointer voidP))) (int_xP_int_xM_max2_16 : ref (memory int_xP (pointer
   voidP))) (int_xP_max1_15_alloc_table : (alloc_table int_xP))
   (int_xP_max2_16_alloc_table : (alloc_table int_xP))
   (voidP_a_7_14_alloc_table : (alloc_table voidP)) (voidP_a_7_14_tag_table :
   (tag_table voidP)) (intP_intM_a_7_14 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_7_14_alloc_table a_7) ->
     (((=) (typeof voidP_a_7_14_tag_table a_7) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_7_14_alloc_table a_7) i) /\
       ((<) i (offset_max voidP_a_7_14_alloc_table a_7))) ->
       ((=) (typeof voidP_a_7_14_tag_table (shift a_7 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_5) (1))) then
     (((<=) (offset_min voidP_a_7_14_alloc_table a_7) (0)) /\
     (((>=) (offset_max voidP_a_7_14_alloc_table a_7)
      (Int.(-) (Uint32.to_int size_5) (1)))
     /\
     (forall __framac_tmp12 : int.
      ((((<=) (0) __framac_tmp12) /\
       ((<=) __framac_tmp12 (Int.(-) (Uint32.to_int size_5) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 13 25#
    (#"whole_program.jc" 1019 12 1287#
    ((#"whole_program.jc" 1019 12 1287#
     ((<=) (offset_min int_xP_max1_15_alloc_table max1) (0)))
    /\
    (#"whole_program.jc" 1019 12 1287#
    ((#"whole_program.jc" 1019 12 1287#
     ((>=) (offset_max int_xP_max1_15_alloc_table max1) (0)))
    /\ (#"whole_program.jc" 1019 12 1287# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 29 41#
   (#"whole_program.jc" 1019 12 1287#
   ((#"whole_program.jc" 1019 12 1287#
    ((<=) (offset_min int_xP_max2_16_alloc_table max2) (0)))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"whole_program.jc" 1019 12 1287#
    ((>=) (offset_max int_xP_max2_16_alloc_table max2) (0)))
   /\ (#"whole_program.jc" 1019 12 1287# ((=) true true)))))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (); ();
     (let i_7_0 = ref (Safe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 25 7 15#
     (Safe_uint32.(>)  size_5
      (#"whole_program.jc" 1110 30 43# "expl:Integer cast"
      (Safe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_372 =
       (let _jessie_371 =
       (shift_typesafe  a_7
        (Safe_int32.to_int 
         (#"whole_program.jc" 1111 62 74# "expl:Integer cast"
         (Safe_int32.of_int (0))) ) ) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./max_max.c" 28 6 19#
       "expl:Pointer index bounds" true) }); _jessie_371 end) in
       (let _jessie_373 = max1 in
       (let _jessie_374 = (0) in
       (let _jessie_375 = _jessie_373 in
       (#"/home/work/workspace/education/acsl-exam/./max_max.c" 28 6 19#
       "expl:Pointer dereference"
       (upd  int_xP_max1_15_alloc_table int_xP_int_xM_max1_15 _jessie_373
        _jessie_372 ))))));
        begin
        (let _jessie_367 =
        (let _jessie_366 =
        (#"/home/work/workspace/education/acsl-exam/./max_max.c" 29 14 19#
        "expl:Pointer dereference"
        (acc  int_xP_max1_15_alloc_table !int_xP_int_xM_max1_15 max1 )) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./max_max.c" 29 6 19#
        "expl:Pointer index bounds" true) }); _jessie_366 end) in
        (let _jessie_368 = max2 in
        (let _jessie_369 = (0) in
        (let _jessie_370 = _jessie_368 in
        (#"/home/work/workspace/education/acsl-exam/./max_max.c" 29 6 19#
        "expl:Pointer dereference"
        (upd  int_xP_max2_16_alloc_table int_xP_int_xM_max2_16 _jessie_368
         _jessie_367 ))))));
         begin
         (i_7_0 :=
          (let _jessie_349 =
          (#"whole_program.jc" 1113 26 39# "expl:Integer cast"
          (Safe_uint32.of_int (1))) in
          begin
          (assert {
          (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 10 15#
          "expl:Pointer index bounds" true) }); _jessie_349 end));
          'Loop_18:
          loop
          invariant { (#"whole_program.jc" 1115 9 3307# true) }
            variant {
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 23 31#
              (Int.(-) (Uint32.to_int size_5) (Uint32.to_int !i_7_0))) }
           begin
           any unit
           requires { true } reads { a_7, int_xP_int_xM_max1_15,
           int_xP_int_xM_max2_16, max1, max2, size_5 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 37 25 135#
              (not
              (exists j_8 : int.
               (exists k_1 : int.
                (((<=) (0) j_8) /\
                (((<) j_8 (Uint32.to_int !i_7_0)) /\
                (((<=) (0) k_1) /\
                (((<) k_1 (Uint32.to_int !i_7_0)) /\
                (((<>) j_8 k_1) /\
                ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 j_8))
                 (select intP_intM_a_7_14
                 (select !int_xP_int_xM_max2_16 max2)))
                /\
                ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 k_1))
                 (select intP_intM_a_7_14
                 (select !int_xP_int_xM_max2_16 max2)))
                /\
                (Int32.(>) (select intP_intM_a_7_14 (shift a_7 k_1))
                (select intP_intM_a_7_14 (shift a_7 j_8))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 36 25 90#
              (exists j_7 : int.
               (((<=) (0) j_7) /\
               (((<) j_7 (Uint32.to_int !i_7_0)) /\
               ((Int32.(>=) (select intP_intM_a_7_14 (shift a_7 j_7))
                (select intP_intM_a_7_14
                (select !int_xP_int_xM_max2_16 max2)))
               /\
               (Int32.(=) (select intP_intM_a_7_14 (shift a_7 j_7))
               (select intP_intM_a_7_14 (select !int_xP_int_xM_max1_15 max1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 35 25 73#
              (forall j_6 : int.
               ((((<=) (0) j_6) /\ ((<) j_6 (Uint32.to_int !i_7_0))) ->
                (Int32.(<=) (select intP_intM_a_7_14 (shift a_7 j_6))
                (select intP_intM_a_7_14
                (select !int_xP_int_xM_max1_15 max1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 25 41#
              (Int32.(>=)
              (select intP_intM_a_7_14 (select !int_xP_int_xM_max1_15 max1))
              (select intP_intM_a_7_14 (select !int_xP_int_xM_max2_16 max2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 33 25 74#
              (exists j_5 : int.
               (((<=) (0) j_5) /\
               (((<) j_5 (Uint32.to_int !i_7_0)) /\
               ((=) (shift a_7 j_5) (select !int_xP_int_xM_max2_16 max2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 32 25 74#
              (exists j_4 : int.
               (((<=) (0) j_4) /\
               (((<) j_4 (Uint32.to_int !i_7_0)) /\
               ((=) (shift a_7 j_4) (select !int_xP_int_xM_max1_15 max1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 30#
              ((<) (0) (Uint32.to_int !i_7_0)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 29 38#
             (Uint32.(<=) !i_7_0 size_5))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 17 25#
             (Safe_uint32.(<)  !i_7_0 size_5 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 13 26#
              (Safe_int32.(>) 
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 13 17#
               "expl:Pointer dereference"
               (acc_offset_typesafe  voidP_a_7_14_alloc_table
                intP_intM_a_7_14 a_7 (Safe_uint32.to_int  !i_7_0 ) ))
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 20 26#
               "expl:Pointer dereference"
               (acc  voidP_a_7_14_alloc_table intP_intM_a_7_14
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 21 26#
                "expl:Pointer dereference"
                (acc  int_xP_max1_15_alloc_table !int_xP_int_xM_max1_15 max1
                 )) )) ))
              then
               begin
               (let _jessie_356 =
               (let _jessie_355 =
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 43 20 25#
               "expl:Pointer dereference"
               (acc  int_xP_max1_15_alloc_table !int_xP_int_xM_max1_15 max1 ))
               in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 43 12 25#
               "expl:Pointer index bounds" true) }); _jessie_355 end) in
               (let _jessie_357 = max2 in
               (let _jessie_358 = (0) in
               (let _jessie_359 = _jessie_357 in
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 43 12 25#
               "expl:Pointer dereference"
               (upd  int_xP_max2_16_alloc_table int_xP_int_xM_max2_16
                _jessie_357 _jessie_356 ))))));
                (let _jessie_361 =
                (let _jessie_360 =
                (shift_typesafe  a_7 (Safe_uint32.to_int  !i_7_0 ) ) in
                begin
                (assert {
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 44 12 25#
                "expl:Pointer index bounds" true) }); _jessie_360 end) in
                (let _jessie_362 = max1 in
                (let _jessie_363 = (0) in
                (let _jessie_364 = _jessie_362 in
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 44 12 25#
                "expl:Pointer dereference"
                (upd  int_xP_max1_15_alloc_table int_xP_int_xM_max1_15
                 _jessie_362 _jessie_361 )))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 20 33#
               (Safe_int32.(>) 
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 20 24#
                "expl:Pointer dereference"
                (acc_offset_typesafe  voidP_a_7_14_alloc_table
                 intP_intM_a_7_14 a_7 (Safe_uint32.to_int  !i_7_0 ) ))
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 27 33#
                "expl:Pointer dereference"
                (acc  voidP_a_7_14_alloc_table intP_intM_a_7_14
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 28 33#
                 "expl:Pointer dereference"
                 (acc  int_xP_max2_16_alloc_table !int_xP_int_xM_max2_16 max2
                  )) )) ))
               then
                (let _jessie_351 =
                (let _jessie_350 =
                (shift_typesafe  a_7 (Safe_uint32.to_int  !i_7_0 ) ) in
                begin
                (assert {
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 12 25#
                "expl:Pointer index bounds" true) }); _jessie_350 end) in
                (let _jessie_352 = max2 in
                (let _jessie_353 = (0) in
                (let _jessie_354 = _jessie_352 in
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 12 25#
                "expl:Pointer dereference"
                (upd  int_xP_max2_16_alloc_table int_xP_int_xM_max2_16
                 _jessie_352 _jessie_351 )))))) else ()));
              (i_7_0 :=
               (let _jessie_365 =
               (Safe_uint32.(+)  !i_7_0
                (#"whole_program.jc" 1172 60 73# "expl:Integer cast"
                (Safe_uint32.of_int (1))) ) in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 27 30#
               "expl:Pointer index bounds" true) }); _jessie_365 end)) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_31 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_29 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
end

module Function_max_max_behaviors

  use Unsafe_uint32 
  
  use Unsafe_int32 
  
  use enum.Uint32 
  
  use import Struct_intP 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let max_max_ensures_default
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 22 5 59#
  "expl:Function max_max, default behavior" =
  fun
   (a_7 : (pointer voidP)) (size_5 : Uint32.t) (max1 : (pointer int_xP))
   (max2 : (pointer int_xP)) (int_xP_int_xM_max1_15 : ref (memory int_xP
   (pointer voidP))) (int_xP_int_xM_max2_16 : ref (memory int_xP (pointer
   voidP))) (int_xP_max1_15_alloc_table : (alloc_table int_xP))
   (int_xP_max2_16_alloc_table : (alloc_table int_xP))
   (voidP_a_7_14_alloc_table : (alloc_table voidP)) (voidP_a_7_14_tag_table :
   (tag_table voidP)) (intP_intM_a_7_14 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_7_14_alloc_table a_7) ->
     (((=) (typeof voidP_a_7_14_tag_table a_7) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_7_14_alloc_table a_7) i) /\
       ((<) i (offset_max voidP_a_7_14_alloc_table a_7))) ->
       ((=) (typeof voidP_a_7_14_tag_table (shift a_7 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_5) (1))) then
     (((<=) (offset_min voidP_a_7_14_alloc_table a_7) (0)) /\
     (((>=) (offset_max voidP_a_7_14_alloc_table a_7)
      (Int.(-) (Uint32.to_int size_5) (1)))
     /\
     (forall __framac_tmp12 : int.
      ((((<=) (0) __framac_tmp12) /\
       ((<=) __framac_tmp12 (Int.(-) (Uint32.to_int size_5) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 13 25#
    (#"whole_program.jc" 1019 12 1287#
    ((#"whole_program.jc" 1019 12 1287#
     ((<=) (offset_min int_xP_max1_15_alloc_table max1) (0)))
    /\
    (#"whole_program.jc" 1019 12 1287#
    ((#"whole_program.jc" 1019 12 1287#
     ((>=) (offset_max int_xP_max1_15_alloc_table max1) (0)))
    /\ (#"whole_program.jc" 1019 12 1287# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 29 41#
   (#"whole_program.jc" 1019 12 1287#
   ((#"whole_program.jc" 1019 12 1287#
    ((<=) (offset_min int_xP_max2_16_alloc_table max2) (0)))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"whole_program.jc" 1019 12 1287#
    ((>=) (offset_max int_xP_max2_16_alloc_table max2) (0)))
   /\ (#"whole_program.jc" 1019 12 1287# ((=) true true)))))))))))) }
   ensures { ("expl:Postcondition" ("expl:Ensures clause" true)) } diverges 
   ->
   'Init:
   try
    begin
    (check {
    (#"whole_program.jc" 1102 10 131# "expl:Behavior disjointness check"
    (not
    (((=) (Uint32.to_int size_5) (0)) /\ ((>) (Uint32.to_int size_5) (0)))))
    });
     (check {
     (#"whole_program.jc" 1105 10 124# "expl:Behavior completeness check"
     (((>) (Uint32.to_int size_5) (0)) \/ ((=) (Uint32.to_int size_5) (0))))
     });
     (let i_7_0 = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 25 7 15#
     (Unsafe_uint32.(>)  size_5
      (#"whole_program.jc" 1110 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_291 =
       (shift_  a_7
        (Unsafe_int32.to_int 
         (#"whole_program.jc" 1111 62 74# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_292 = max1 in
       (let _jessie_293 = (0) in
       (let _jessie_294 = _jessie_292 in
       (upd  int_xP_int_xM_max1_15 _jessie_294 _jessie_291 )))));
        begin
        (let _jessie_286 = (acc  !int_xP_int_xM_max1_15 max1 ) in
        (let _jessie_287 = max2 in
        (let _jessie_288 = (0) in
        (let _jessie_289 = _jessie_287 in
        (upd  int_xP_int_xM_max2_16 _jessie_289 _jessie_286 )))));
         begin
         (i_7_0 :=
          (#"whole_program.jc" 1113 26 39# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_15:
          loop
          invariant
            { (((#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
                ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 30#
                 ((<) (0) (Uint32.to_int !i_7_0)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 29 38#
                (Uint32.(<=) !i_7_0 size_5)))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 32 25 74#
                (exists j_4 : int.
                 (((<=) (0) j_4) /\
                 (((<) j_4 (Uint32.to_int !i_7_0)) /\
                 ((=) (shift a_7 j_4) (select !int_xP_int_xM_max1_15 max1))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 33 25 74#
                (exists j_5 : int.
                 (((<=) (0) j_5) /\
                 (((<) j_5 (Uint32.to_int !i_7_0)) /\
                 ((=) (shift a_7 j_5) (select !int_xP_int_xM_max2_16 max2))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 25 41#
                (Int32.(>=)
                (select intP_intM_a_7_14
                (select !int_xP_int_xM_max1_15 max1))
                (select intP_intM_a_7_14
                (select !int_xP_int_xM_max2_16 max2))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 35 25 73#
                (forall j_6 : int.
                 ((((<=) (0) j_6) /\ ((<) j_6 (Uint32.to_int !i_7_0))) ->
                  (Int32.(<=) (select intP_intM_a_7_14 (shift a_7 j_6))
                  (select intP_intM_a_7_14
                  (select !int_xP_int_xM_max1_15 max1))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 36 25 90#
                (exists j_7 : int.
                 (((<=) (0) j_7) /\
                 (((<) j_7 (Uint32.to_int !i_7_0)) /\
                 ((Int32.(>=) (select intP_intM_a_7_14 (shift a_7 j_7))
                  (select intP_intM_a_7_14
                  (select !int_xP_int_xM_max2_16 max2)))
                 /\
                 (Int32.(=) (select intP_intM_a_7_14 (shift a_7 j_7))
                 (select intP_intM_a_7_14
                 (select !int_xP_int_xM_max1_15 max1))))))))
               &&
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 37 25 135#
               (not
               (exists j_8 : int.
                (exists k_1 : int.
                 (((<=) (0) j_8) /\
                 (((<) j_8 (Uint32.to_int !i_7_0)) /\
                 (((<=) (0) k_1) /\
                 (((<) k_1 (Uint32.to_int !i_7_0)) /\
                 (((<>) j_8 k_1) /\
                 ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 j_8))
                  (select intP_intM_a_7_14
                  (select !int_xP_int_xM_max2_16 max2)))
                 /\
                 ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 k_1))
                  (select intP_intM_a_7_14
                  (select !int_xP_int_xM_max2_16 max2)))
                 /\
                 (Int32.(>) (select intP_intM_a_7_14 (shift a_7 k_1))
                 (select intP_intM_a_7_14 (shift a_7 j_8))))))))))))))))))))
              /\
              (#"whole_program.jc" 1115 9 3307#
              ((#"whole_program.jc" 1115 9 3307# "expl:Assigns clause"
               (not_assigns int_xP_max1_15_alloc_table
               int_xP_max1_15_alloc_table (at !int_xP_int_xM_max1_15
               'Loop_15) !int_xP_int_xM_max1_15 (pset_singleton max1)))
              /\
              (#"whole_program.jc" 1115 9 3307# "expl:Assigns clause"
              (not_assigns int_xP_max2_16_alloc_table
              int_xP_max2_16_alloc_table (at !int_xP_int_xM_max2_16 'Loop_15)
              !int_xP_int_xM_max2_16 (pset_singleton max2)))))) } 
           begin
           any unit requires { true } ensures { true } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 17 25#
             (Unsafe_uint32.(<)  !i_7_0 size_5 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 13 26#
              (Unsafe_int32.(>) 
               (acc  intP_intM_a_7_14
                (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) )
               (acc  intP_intM_a_7_14 (acc  !int_xP_int_xM_max1_15 max1 ) ) ))
              then
               begin
               (let _jessie_275 = (acc  !int_xP_int_xM_max1_15 max1 ) in
               (let _jessie_276 = max2 in
               (let _jessie_277 = (0) in
               (let _jessie_278 = _jessie_276 in
               (upd  int_xP_int_xM_max2_16 _jessie_278 _jessie_275 )))));
                (let _jessie_280 =
                (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) in
                (let _jessie_281 = max1 in
                (let _jessie_282 = (0) in
                (let _jessie_283 = _jessie_281 in
                (upd  int_xP_int_xM_max1_15 _jessie_283 _jessie_280 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 20 33#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_7_14
                 (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) )
                (acc  intP_intM_a_7_14 (acc  !int_xP_int_xM_max2_16 max2 ) )
                ))
               then
                (let _jessie_270 =
                (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) in
                (let _jessie_271 = max2 in
                (let _jessie_272 = (0) in
                (let _jessie_273 = _jessie_271 in
                (upd  int_xP_int_xM_max2_16 _jessie_273 _jessie_270 )))))
               else ()));
              (i_7_0 :=
               (Unsafe_uint32.(+)  !i_7_0
                (#"whole_program.jc" 1172 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_31 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_29 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
  let max_max_ensures_positive_size
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 22 5 59#
  "expl:Function max_max, behavior positive_size" =
  fun
   (a_7 : (pointer voidP)) (size_5 : Uint32.t) (max1 : (pointer int_xP))
   (max2 : (pointer int_xP)) (int_xP_int_xM_max1_15 : ref (memory int_xP
   (pointer voidP))) (int_xP_int_xM_max2_16 : ref (memory int_xP (pointer
   voidP))) (int_xP_max1_15_alloc_table : (alloc_table int_xP))
   (int_xP_max2_16_alloc_table : (alloc_table int_xP))
   (voidP_a_7_14_alloc_table : (alloc_table voidP)) (voidP_a_7_14_tag_table :
   (tag_table voidP)) (intP_intM_a_7_14 : (memory voidP Int32.t)) 
   requires {
   (((>) (Uint32.to_int size_5) (0)) /\
   (((allocated voidP_a_7_14_alloc_table a_7) ->
     (((=) (typeof voidP_a_7_14_tag_table a_7) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_7_14_alloc_table a_7) i) /\
       ((<) i (offset_max voidP_a_7_14_alloc_table a_7))) ->
       ((=) (typeof voidP_a_7_14_tag_table (shift a_7 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_5) (1))) then
     (((<=) (offset_min voidP_a_7_14_alloc_table a_7) (0)) /\
     (((>=) (offset_max voidP_a_7_14_alloc_table a_7)
      (Int.(-) (Uint32.to_int size_5) (1)))
     /\
     (forall __framac_tmp12 : int.
      ((((<=) (0) __framac_tmp12) /\
       ((<=) __framac_tmp12 (Int.(-) (Uint32.to_int size_5) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 13 25#
    (#"whole_program.jc" 1019 12 1287#
    ((#"whole_program.jc" 1019 12 1287#
     ((<=) (offset_min int_xP_max1_15_alloc_table max1) (0)))
    /\
    (#"whole_program.jc" 1019 12 1287#
    ((#"whole_program.jc" 1019 12 1287#
     ((>=) (offset_max int_xP_max1_15_alloc_table max1) (0)))
    /\ (#"whole_program.jc" 1019 12 1287# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 29 41#
   (#"whole_program.jc" 1019 12 1287#
   ((#"whole_program.jc" 1019 12 1287#
    ((<=) (offset_min int_xP_max2_16_alloc_table max2) (0)))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"whole_program.jc" 1019 12 1287#
    ((>=) (offset_max int_xP_max2_16_alloc_table max2) (0)))
   /\ (#"whole_program.jc" 1019 12 1287# ((=) true true))))))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"whole_program.jc" 1048 10 36# "expl:Assigns clause"
       (not_assigns int_xP_max1_15_alloc_table int_xP_max1_15_alloc_table
       (old !int_xP_int_xM_max1_15) !int_xP_int_xM_max1_15
       (pset_singleton max1)))
      /\
      (#"whole_program.jc" 1048 10 36# "expl:Assigns clause"
      (not_assigns int_xP_max2_16_alloc_table int_xP_max2_16_alloc_table (old
      !int_xP_int_xM_max2_16) !int_xP_int_xM_max2_16 (pset_singleton max2))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 27#
      "expl:Ensures clause"
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
       "expl:Ensures clause"
       ((<=) (offset_min int_xP_max1_15_alloc_table max1) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
       "expl:Ensures clause"
       ((>=) (offset_max int_xP_max1_15_alloc_table max1) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause" ((=) true true)))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 31 43#
      "expl:Ensures clause"
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
       "expl:Ensures clause"
       ((<=) (offset_min int_xP_max2_16_alloc_table max2) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
       "expl:Ensures clause"
       ((>=) (offset_max int_xP_max2_16_alloc_table max2) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause" ((=) true true)))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 12 15 67#
      "expl:Ensures clause"
      (exists i_24 : int.
       (((<=) (0) i_24) /\
       (((<) i_24 (Uint32.to_int size_5)) /\
       ((=) (shift a_7 i_24) (select !int_xP_int_xM_max1_15 max1))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 67#
      "expl:Ensures clause"
      (exists i_25 : int.
       (((<=) (0) i_25) /\
       (((<) i_25 (Uint32.to_int size_5)) /\
       ((=) (shift a_7 i_25) (select !int_xP_int_xM_max2_16 max2))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 14 15 31#
      "expl:Ensures clause"
      (Int32.(>=)
      (select intP_intM_a_7_14 (select !int_xP_int_xM_max1_15 max1))
      (select intP_intM_a_7_14 (select !int_xP_int_xM_max2_16 max2))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 15 15 66#
      "expl:Ensures clause"
      (forall i_26 : int.
       ((((<=) (0) i_26) /\ ((<) i_26 (Uint32.to_int size_5))) ->
        (Int32.(<=) (select intP_intM_a_7_14 (shift a_7 i_26))
        (select intP_intM_a_7_14 (select !int_xP_int_xM_max1_15 max1))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 16 15 83#
      "expl:Ensures clause"
      (exists i_27 : int.
       (((<=) (0) i_27) /\
       (((<) i_27 (Uint32.to_int size_5)) /\
       ((Int32.(>=) (select intP_intM_a_7_14 (shift a_7 i_27))
        (select intP_intM_a_7_14 (select !int_xP_int_xM_max2_16 max2)))
       /\
       (Int32.(=) (select intP_intM_a_7_14 (shift a_7 i_27))
       (select intP_intM_a_7_14 (select !int_xP_int_xM_max1_15 max1))))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 17 15 131#
     "expl:Ensures clause"
     (not
     (exists i_28 : int.
      (exists j_9 : int.
       (((<=) (0) i_28) /\
       (((<) i_28 (Uint32.to_int size_5)) /\
       (((<=) (0) j_9) /\
       (((<) j_9 (Uint32.to_int size_5)) /\
       (((<>) i_28 j_9) /\
       ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 i_28))
        (select intP_intM_a_7_14 (select !int_xP_int_xM_max2_16 max2)))
       /\
       ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 j_9))
        (select intP_intM_a_7_14 (select !int_xP_int_xM_max2_16 max2)))
       /\
       (Int32.(>) (select intP_intM_a_7_14 (shift a_7 i_28))
       (select intP_intM_a_7_14 (shift a_7 j_9)))))))))))))))))))))))))))))))
     } diverges  ->
   'Init:
   try
    begin
    (); ();
     (let i_7_0 = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 25 7 15#
     (Unsafe_uint32.(>)  size_5
      (#"whole_program.jc" 1110 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_345 =
       (shift_  a_7
        (Unsafe_int32.to_int 
         (#"whole_program.jc" 1111 62 74# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_346 = max1 in
       (let _jessie_347 = (0) in
       (let _jessie_348 = _jessie_346 in
       (upd  int_xP_int_xM_max1_15 _jessie_348 _jessie_345 )))));
        begin
        (let _jessie_340 = (acc  !int_xP_int_xM_max1_15 max1 ) in
        (let _jessie_341 = max2 in
        (let _jessie_342 = (0) in
        (let _jessie_343 = _jessie_341 in
        (upd  int_xP_int_xM_max2_16 _jessie_343 _jessie_340 )))));
         begin
         (i_7_0 :=
          (#"whole_program.jc" 1113 26 39# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_17:
          loop
          invariant
            { (#"whole_program.jc" 1115 9 3307#
              ((#"whole_program.jc" 1048 10 36# "expl:Assigns clause"
               (not_assigns int_xP_max1_15_alloc_table
               int_xP_max1_15_alloc_table (at !int_xP_int_xM_max1_15 'Init)
               !int_xP_int_xM_max1_15 (pset_singleton max1)))
              /\
              (#"whole_program.jc" 1048 10 36# "expl:Assigns clause"
              (not_assigns int_xP_max2_16_alloc_table
              int_xP_max2_16_alloc_table (at !int_xP_int_xM_max2_16 'Init)
              !int_xP_int_xM_max2_16 (pset_singleton max2))))) } 
           begin
           any unit
           requires { true } reads { a_7, int_xP_int_xM_max1_15,
           int_xP_int_xM_max2_16, max1, max2, size_5 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 37 25 135#
              (not
              (exists j_8 : int.
               (exists k_1 : int.
                (((<=) (0) j_8) /\
                (((<) j_8 (Uint32.to_int !i_7_0)) /\
                (((<=) (0) k_1) /\
                (((<) k_1 (Uint32.to_int !i_7_0)) /\
                (((<>) j_8 k_1) /\
                ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 j_8))
                 (select intP_intM_a_7_14
                 (select !int_xP_int_xM_max2_16 max2)))
                /\
                ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 k_1))
                 (select intP_intM_a_7_14
                 (select !int_xP_int_xM_max2_16 max2)))
                /\
                (Int32.(>) (select intP_intM_a_7_14 (shift a_7 k_1))
                (select intP_intM_a_7_14 (shift a_7 j_8))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 36 25 90#
              (exists j_7 : int.
               (((<=) (0) j_7) /\
               (((<) j_7 (Uint32.to_int !i_7_0)) /\
               ((Int32.(>=) (select intP_intM_a_7_14 (shift a_7 j_7))
                (select intP_intM_a_7_14
                (select !int_xP_int_xM_max2_16 max2)))
               /\
               (Int32.(=) (select intP_intM_a_7_14 (shift a_7 j_7))
               (select intP_intM_a_7_14 (select !int_xP_int_xM_max1_15 max1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 35 25 73#
              (forall j_6 : int.
               ((((<=) (0) j_6) /\ ((<) j_6 (Uint32.to_int !i_7_0))) ->
                (Int32.(<=) (select intP_intM_a_7_14 (shift a_7 j_6))
                (select intP_intM_a_7_14
                (select !int_xP_int_xM_max1_15 max1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 25 41#
              (Int32.(>=)
              (select intP_intM_a_7_14 (select !int_xP_int_xM_max1_15 max1))
              (select intP_intM_a_7_14 (select !int_xP_int_xM_max2_16 max2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 33 25 74#
              (exists j_5 : int.
               (((<=) (0) j_5) /\
               (((<) j_5 (Uint32.to_int !i_7_0)) /\
               ((=) (shift a_7 j_5) (select !int_xP_int_xM_max2_16 max2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 32 25 74#
              (exists j_4 : int.
               (((<=) (0) j_4) /\
               (((<) j_4 (Uint32.to_int !i_7_0)) /\
               ((=) (shift a_7 j_4) (select !int_xP_int_xM_max1_15 max1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 30#
              ((<) (0) (Uint32.to_int !i_7_0)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 29 38#
             (Uint32.(<=) !i_7_0 size_5))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 17 25#
             (Unsafe_uint32.(<)  !i_7_0 size_5 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 13 26#
              (Unsafe_int32.(>) 
               (acc  intP_intM_a_7_14
                (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) )
               (acc  intP_intM_a_7_14 (acc  !int_xP_int_xM_max1_15 max1 ) ) ))
              then
               begin
               (let _jessie_329 = (acc  !int_xP_int_xM_max1_15 max1 ) in
               (let _jessie_330 = max2 in
               (let _jessie_331 = (0) in
               (let _jessie_332 = _jessie_330 in
               (upd  int_xP_int_xM_max2_16 _jessie_332 _jessie_329 )))));
                (let _jessie_334 =
                (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) in
                (let _jessie_335 = max1 in
                (let _jessie_336 = (0) in
                (let _jessie_337 = _jessie_335 in
                (upd  int_xP_int_xM_max1_15 _jessie_337 _jessie_334 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 20 33#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_7_14
                 (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) )
                (acc  intP_intM_a_7_14 (acc  !int_xP_int_xM_max2_16 max2 ) )
                ))
               then
                (let _jessie_324 =
                (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) in
                (let _jessie_325 = max2 in
                (let _jessie_326 = (0) in
                (let _jessie_327 = _jessie_325 in
                (upd  int_xP_int_xM_max2_16 _jessie_327 _jessie_324 )))))
               else ()));
              (i_7_0 :=
               (Unsafe_uint32.(+)  !i_7_0
                (#"whole_program.jc" 1172 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_31 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_29 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
  let max_max_ensures_zero_size
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 22 5 59#
  "expl:Function max_max, behavior zero_size" =
  fun
   (a_7 : (pointer voidP)) (size_5 : Uint32.t) (max1 : (pointer int_xP))
   (max2 : (pointer int_xP)) (int_xP_int_xM_max1_15 : ref (memory int_xP
   (pointer voidP))) (int_xP_int_xM_max2_16 : ref (memory int_xP (pointer
   voidP))) (int_xP_max1_15_alloc_table : (alloc_table int_xP))
   (int_xP_max2_16_alloc_table : (alloc_table int_xP))
   (voidP_a_7_14_alloc_table : (alloc_table voidP)) (voidP_a_7_14_tag_table :
   (tag_table voidP)) (intP_intM_a_7_14 : (memory voidP Int32.t)) 
   requires {
   (((=) (Uint32.to_int size_5) (0)) /\
   (((allocated voidP_a_7_14_alloc_table a_7) ->
     (((=) (typeof voidP_a_7_14_tag_table a_7) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_7_14_alloc_table a_7) i) /\
       ((<) i (offset_max voidP_a_7_14_alloc_table a_7))) ->
       ((=) (typeof voidP_a_7_14_tag_table (shift a_7 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_5) (1))) then
     (((<=) (offset_min voidP_a_7_14_alloc_table a_7) (0)) /\
     (((>=) (offset_max voidP_a_7_14_alloc_table a_7)
      (Int.(-) (Uint32.to_int size_5) (1)))
     /\
     (forall __framac_tmp12 : int.
      ((((<=) (0) __framac_tmp12) /\
       ((<=) __framac_tmp12 (Int.(-) (Uint32.to_int size_5) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 13 25#
    (#"whole_program.jc" 1019 12 1287#
    ((#"whole_program.jc" 1019 12 1287#
     ((<=) (offset_min int_xP_max1_15_alloc_table max1) (0)))
    /\
    (#"whole_program.jc" 1019 12 1287#
    ((#"whole_program.jc" 1019 12 1287#
     ((>=) (offset_max int_xP_max1_15_alloc_table max1) (0)))
    /\ (#"whole_program.jc" 1019 12 1287# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 29 41#
   (#"whole_program.jc" 1019 12 1287#
   ((#"whole_program.jc" 1019 12 1287#
    ((<=) (offset_min int_xP_max2_16_alloc_table max2) (0)))
   /\
   (#"whole_program.jc" 1019 12 1287#
   ((#"whole_program.jc" 1019 12 1287#
    ((>=) (offset_max int_xP_max2_16_alloc_table max2) (0)))
   /\ (#"whole_program.jc" 1019 12 1287# ((=) true true))))))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"whole_program.jc" 1043 10 18# "expl:Assigns clause"
       (not_assigns int_xP_max1_15_alloc_table int_xP_max1_15_alloc_table
       (old !int_xP_int_xM_max1_15) !int_xP_int_xM_max1_15 pset_empty))
      /\
      (#"whole_program.jc" 1043 10 18# "expl:Assigns clause"
      (not_assigns int_xP_max2_16_alloc_table int_xP_max2_16_alloc_table (old
      !int_xP_int_xM_max2_16) !int_xP_int_xM_max2_16 pset_empty)))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
      "expl:Ensures clause" ((=) max1 max1))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 7 15 33#
     "expl:Ensures clause" ((=) max2 max2))))))) } diverges  ->
   'Init:
   try
    begin
    (); ();
     (let i_7_0 = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 25 7 15#
     (Unsafe_uint32.(>)  size_5
      (#"whole_program.jc" 1110 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_318 =
       (shift_  a_7
        (Unsafe_int32.to_int 
         (#"whole_program.jc" 1111 62 74# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_319 = max1 in
       (let _jessie_320 = (0) in
       (let _jessie_321 = _jessie_319 in
       (upd  int_xP_int_xM_max1_15 _jessie_321 _jessie_318 )))));
        begin
        (let _jessie_313 = (acc  !int_xP_int_xM_max1_15 max1 ) in
        (let _jessie_314 = max2 in
        (let _jessie_315 = (0) in
        (let _jessie_316 = _jessie_314 in
        (upd  int_xP_int_xM_max2_16 _jessie_316 _jessie_313 )))));
         begin
         (i_7_0 :=
          (#"whole_program.jc" 1113 26 39# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_16:
          loop
          invariant
            { (#"whole_program.jc" 1115 9 3307#
              ((#"whole_program.jc" 1043 10 18# "expl:Assigns clause"
               (not_assigns int_xP_max1_15_alloc_table
               int_xP_max1_15_alloc_table (at !int_xP_int_xM_max1_15 'Init)
               !int_xP_int_xM_max1_15 pset_empty))
              /\
              (#"whole_program.jc" 1043 10 18# "expl:Assigns clause"
              (not_assigns int_xP_max2_16_alloc_table
              int_xP_max2_16_alloc_table (at !int_xP_int_xM_max2_16 'Init)
              !int_xP_int_xM_max2_16 pset_empty)))) } 
           begin
           any unit
           requires { true } reads { a_7, int_xP_int_xM_max1_15,
           int_xP_int_xM_max2_16, max1, max2, size_5 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 37 25 135#
              (not
              (exists j_8 : int.
               (exists k_1 : int.
                (((<=) (0) j_8) /\
                (((<) j_8 (Uint32.to_int !i_7_0)) /\
                (((<=) (0) k_1) /\
                (((<) k_1 (Uint32.to_int !i_7_0)) /\
                (((<>) j_8 k_1) /\
                ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 j_8))
                 (select intP_intM_a_7_14
                 (select !int_xP_int_xM_max2_16 max2)))
                /\
                ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 k_1))
                 (select intP_intM_a_7_14
                 (select !int_xP_int_xM_max2_16 max2)))
                /\
                (Int32.(>) (select intP_intM_a_7_14 (shift a_7 k_1))
                (select intP_intM_a_7_14 (shift a_7 j_8))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 36 25 90#
              (exists j_7 : int.
               (((<=) (0) j_7) /\
               (((<) j_7 (Uint32.to_int !i_7_0)) /\
               ((Int32.(>=) (select intP_intM_a_7_14 (shift a_7 j_7))
                (select intP_intM_a_7_14
                (select !int_xP_int_xM_max2_16 max2)))
               /\
               (Int32.(=) (select intP_intM_a_7_14 (shift a_7 j_7))
               (select intP_intM_a_7_14 (select !int_xP_int_xM_max1_15 max1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 35 25 73#
              (forall j_6 : int.
               ((((<=) (0) j_6) /\ ((<) j_6 (Uint32.to_int !i_7_0))) ->
                (Int32.(<=) (select intP_intM_a_7_14 (shift a_7 j_6))
                (select intP_intM_a_7_14
                (select !int_xP_int_xM_max1_15 max1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 25 41#
              (Int32.(>=)
              (select intP_intM_a_7_14 (select !int_xP_int_xM_max1_15 max1))
              (select intP_intM_a_7_14 (select !int_xP_int_xM_max2_16 max2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 33 25 74#
              (exists j_5 : int.
               (((<=) (0) j_5) /\
               (((<) j_5 (Uint32.to_int !i_7_0)) /\
               ((=) (shift a_7 j_5) (select !int_xP_int_xM_max2_16 max2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 32 25 74#
              (exists j_4 : int.
               (((<=) (0) j_4) /\
               (((<) j_4 (Uint32.to_int !i_7_0)) /\
               ((=) (shift a_7 j_4) (select !int_xP_int_xM_max1_15 max1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 30#
              ((<) (0) (Uint32.to_int !i_7_0)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 29 38#
             (Uint32.(<=) !i_7_0 size_5))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 17 25#
             (Unsafe_uint32.(<)  !i_7_0 size_5 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 13 26#
              (Unsafe_int32.(>) 
               (acc  intP_intM_a_7_14
                (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) )
               (acc  intP_intM_a_7_14 (acc  !int_xP_int_xM_max1_15 max1 ) ) ))
              then
               begin
               (let _jessie_302 = (acc  !int_xP_int_xM_max1_15 max1 ) in
               (let _jessie_303 = max2 in
               (let _jessie_304 = (0) in
               (let _jessie_305 = _jessie_303 in
               (upd  int_xP_int_xM_max2_16 _jessie_305 _jessie_302 )))));
                (let _jessie_307 =
                (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) in
                (let _jessie_308 = max1 in
                (let _jessie_309 = (0) in
                (let _jessie_310 = _jessie_308 in
                (upd  int_xP_int_xM_max1_15 _jessie_310 _jessie_307 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 20 33#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_7_14
                 (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) )
                (acc  intP_intM_a_7_14 (acc  !int_xP_int_xM_max2_16 max2 ) )
                ))
               then
                (let _jessie_297 =
                (shift_  a_7 (Unsafe_uint32.to_int  !i_7_0 ) ) in
                (let _jessie_298 = max2 in
                (let _jessie_299 = (0) in
                (let _jessie_300 = _jessie_298 in
                (upd  int_xP_int_xM_max2_16 _jessie_300 _jessie_297 )))))
               else ()));
              (i_7_0 :=
               (Unsafe_uint32.(+)  !i_7_0
                (#"whole_program.jc" 1172 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_31 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_29 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
end

module Function_max_min_safety

  use enum.Uint32 
  
  use import Struct_intP 
  
  use Safe_uint32 
  
  use Safe_int32 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let max_min
  #"/home/work/workspace/education/acsl-exam/./max_min.c" 18 5 58#
  "expl:Function max_min, safety" =
  fun
   (a_8 : (pointer voidP)) (size_6 : Uint32.t) (max : (pointer int_xP)) (min
   : (pointer int_xP)) (int_xP_int_xM_max_18 : ref (memory int_xP (pointer
   voidP))) (int_xP_int_xM_min_19 : ref (memory int_xP (pointer voidP)))
   (int_xP_max_18_alloc_table : (alloc_table int_xP))
   (int_xP_min_19_alloc_table : (alloc_table int_xP))
   (voidP_a_8_17_alloc_table : (alloc_table voidP)) (voidP_a_8_17_tag_table :
   (tag_table voidP)) (intP_intM_a_8_17 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_8_17_alloc_table a_8) ->
     (((=) (typeof voidP_a_8_17_tag_table a_8) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_8_17_alloc_table a_8) i) /\
       ((<) i (offset_max voidP_a_8_17_alloc_table a_8))) ->
       ((=) (typeof voidP_a_8_17_tag_table (shift a_8 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_6) (1))) then
     (((<=) (offset_min voidP_a_8_17_alloc_table a_8) (0)) /\
     (((>=) (offset_max voidP_a_8_17_alloc_table a_8)
      (Int.(-) (Uint32.to_int size_6) (1)))
     /\
     (forall __framac_tmp15 : int.
      ((((<=) (0) __framac_tmp15) /\
       ((<=) __framac_tmp15 (Int.(-) (Uint32.to_int size_6) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 2 13 24#
    (#"whole_program.jc" 1183 12 1050#
    ((#"whole_program.jc" 1183 12 1050#
     ((<=) (offset_min int_xP_max_18_alloc_table max) (0)))
    /\
    (#"whole_program.jc" 1183 12 1050#
    ((#"whole_program.jc" 1183 12 1050#
     ((>=) (offset_max int_xP_max_18_alloc_table max) (0)))
    /\ (#"whole_program.jc" 1183 12 1050# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_min.c" 3 13 24#
   (#"whole_program.jc" 1183 12 1050#
   ((#"whole_program.jc" 1183 12 1050#
    ((<=) (offset_min int_xP_min_19_alloc_table min) (0)))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"whole_program.jc" 1183 12 1050#
    ((>=) (offset_max int_xP_min_19_alloc_table min) (0)))
   /\ (#"whole_program.jc" 1183 12 1050# ((=) true true)))))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (); ();
     (let i_8_2 = ref (Safe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 20 7 15#
     (Safe_uint32.(>)  size_6
      (#"whole_program.jc" 1239 30 43# "expl:Integer cast"
      (Safe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_460 =
       (let _jessie_459 =
       (shift_typesafe  a_8
        (Safe_int32.to_int 
         (#"whole_program.jc" 1240 61 73# "expl:Integer cast"
         (Safe_int32.of_int (0))) ) ) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./max_min.c" 22 6 18#
       "expl:Pointer index bounds" true) }); _jessie_459 end) in
       (let _jessie_461 = max in
       (let _jessie_462 = (0) in
       (let _jessie_463 = _jessie_461 in
       (#"/home/work/workspace/education/acsl-exam/./max_min.c" 22 6 18#
       "expl:Pointer dereference"
       (upd  int_xP_max_18_alloc_table int_xP_int_xM_max_18 _jessie_461
        _jessie_460 ))))));
        begin
        (let _jessie_455 =
        (let _jessie_454 =
        (#"/home/work/workspace/education/acsl-exam/./max_min.c" 23 13 17#
        "expl:Pointer dereference"
        (acc  int_xP_max_18_alloc_table !int_xP_int_xM_max_18 max )) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./max_min.c" 23 6 17#
        "expl:Pointer index bounds" true) }); _jessie_454 end) in
        (let _jessie_456 = min in
        (let _jessie_457 = (0) in
        (let _jessie_458 = _jessie_456 in
        (#"/home/work/workspace/education/acsl-exam/./max_min.c" 23 6 17#
        "expl:Pointer dereference"
        (upd  int_xP_min_19_alloc_table int_xP_int_xM_min_19 _jessie_456
         _jessie_455 ))))));
         begin
         (i_8_2 :=
          (let _jessie_442 =
          (#"whole_program.jc" 1242 26 39# "expl:Integer cast"
          (Safe_uint32.of_int (1))) in
          begin
          (assert {
          (#"/home/work/workspace/education/acsl-exam/./max_min.c" 32 10 15#
          "expl:Pointer index bounds" true) }); _jessie_442 end));
          'Loop_22:
          loop
          invariant { (#"whole_program.jc" 1244 9 1974# true) }
            variant {
              (#"/home/work/workspace/education/acsl-exam/./max_min.c" 30 23 31#
              (Int.(-) (Uint32.to_int size_6) (Uint32.to_int !i_8_2))) }
           begin
           any unit
           requires { true } reads { a_8, int_xP_int_xM_max_18,
           int_xP_int_xM_min_19, max, min, size_6 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 28 25 81#
              (forall j_12 : int.
               ((((<=) (0) j_12) /\ ((<) j_12 (Uint32.to_int !i_8_2))) ->
                ((Int32.(>=)
                 (select intP_intM_a_8_17 (select !int_xP_int_xM_max_18 max))
                 (select intP_intM_a_8_17 (shift a_8 j_12)))
                /\
                (Int32.(>=) (select intP_intM_a_8_17 (shift a_8 j_12))
                (select intP_intM_a_8_17 (select !int_xP_int_xM_min_19 min)))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 27 25 39#
              (Int32.(>=)
              (select intP_intM_a_8_17 (select !int_xP_int_xM_max_18 max))
              (select intP_intM_a_8_17 (select !int_xP_int_xM_min_19 min))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 26 25 71#
              (exists j_11 : int.
               (((<=) (0) j_11) /\
               (((<) j_11 (Uint32.to_int !i_8_2)) /\
               ((=) (shift a_8 j_11) (select !int_xP_int_xM_min_19 min))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 25 25 71#
              (exists j_10 : int.
               (((<=) (0) j_10) /\
               (((<) j_10 (Uint32.to_int !i_8_2)) /\
               ((=) (shift a_8 j_10) (select !int_xP_int_xM_max_18 max))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 39#
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 39#
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 31#
              ((<=) (1) (Uint32.to_int !i_8_2)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 30 39#
             (Uint32.(<=) !i_8_2 size_6))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 32 17 25#
             (Safe_uint32.(<)  !i_8_2 size_6 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_min.c" 33 13 25#
              (Safe_int32.(<) 
               (#"/home/work/workspace/education/acsl-exam/./max_min.c" 33 13 18#
               "expl:Pointer dereference"
               (acc  voidP_a_8_17_alloc_table intP_intM_a_8_17
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 33 14 18#
                "expl:Pointer dereference"
                (acc  int_xP_max_18_alloc_table !int_xP_int_xM_max_18 max ))
                ))
               (#"/home/work/workspace/education/acsl-exam/./max_min.c" 33 21 25#
               "expl:Pointer dereference"
               (acc_offset_typesafe  voidP_a_8_17_alloc_table
                intP_intM_a_8_17 a_8 (Safe_uint32.to_int  !i_8_2 ) )) ))
              then
               (let _jessie_449 =
               (let _jessie_448 =
               (shift_typesafe  a_8 (Safe_uint32.to_int  !i_8_2 ) ) in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./max_min.c" 34 12 24#
               "expl:Pointer index bounds" true) }); _jessie_448 end) in
               (let _jessie_450 = max in
               (let _jessie_451 = (0) in
               (let _jessie_452 = _jessie_450 in
               (#"/home/work/workspace/education/acsl-exam/./max_min.c" 34 12 24#
               "expl:Pointer dereference"
               (upd  int_xP_max_18_alloc_table int_xP_int_xM_max_18
                _jessie_450 _jessie_449 ))))))
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_min.c" 35 20 32#
               (Safe_int32.(>) 
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 35 20 25#
                "expl:Pointer dereference"
                (acc  voidP_a_8_17_alloc_table intP_intM_a_8_17
                 (#"/home/work/workspace/education/acsl-exam/./max_min.c" 35 21 25#
                 "expl:Pointer dereference"
                 (acc  int_xP_min_19_alloc_table !int_xP_int_xM_min_19 min ))
                 ))
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 35 28 32#
                "expl:Pointer dereference"
                (acc_offset_typesafe  voidP_a_8_17_alloc_table
                 intP_intM_a_8_17 a_8 (Safe_uint32.to_int  !i_8_2 ) )) ))
               then
                (let _jessie_444 =
                (let _jessie_443 =
                (shift_typesafe  a_8 (Safe_uint32.to_int  !i_8_2 ) ) in
                begin
                (assert {
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 36 12 24#
                "expl:Pointer index bounds" true) }); _jessie_443 end) in
                (let _jessie_445 = min in
                (let _jessie_446 = (0) in
                (let _jessie_447 = _jessie_445 in
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 36 12 24#
                "expl:Pointer dereference"
                (upd  int_xP_min_19_alloc_table int_xP_int_xM_min_19
                 _jessie_445 _jessie_444 )))))) else ()));
              (i_8_2 :=
               (let _jessie_453 =
               (Safe_uint32.(+)  !i_8_2
                (#"whole_program.jc" 1280 60 73# "expl:Integer cast"
                (Safe_uint32.of_int (1))) ) in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./max_min.c" 32 27 30#
               "expl:Pointer index bounds" true) }); _jessie_453 end)) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_34 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_32 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
end

module Function_max_min_behaviors

  use Unsafe_uint32 
  
  use Unsafe_int32 
  
  use enum.Uint32 
  
  use import Struct_intP 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let max_min_ensures_default
  #"/home/work/workspace/education/acsl-exam/./max_min.c" 18 5 58#
  "expl:Function max_min, default behavior" =
  fun
   (a_8 : (pointer voidP)) (size_6 : Uint32.t) (max : (pointer int_xP)) (min
   : (pointer int_xP)) (int_xP_int_xM_max_18 : ref (memory int_xP (pointer
   voidP))) (int_xP_int_xM_min_19 : ref (memory int_xP (pointer voidP)))
   (int_xP_max_18_alloc_table : (alloc_table int_xP))
   (int_xP_min_19_alloc_table : (alloc_table int_xP))
   (voidP_a_8_17_alloc_table : (alloc_table voidP)) (voidP_a_8_17_tag_table :
   (tag_table voidP)) (intP_intM_a_8_17 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_8_17_alloc_table a_8) ->
     (((=) (typeof voidP_a_8_17_tag_table a_8) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_8_17_alloc_table a_8) i) /\
       ((<) i (offset_max voidP_a_8_17_alloc_table a_8))) ->
       ((=) (typeof voidP_a_8_17_tag_table (shift a_8 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_6) (1))) then
     (((<=) (offset_min voidP_a_8_17_alloc_table a_8) (0)) /\
     (((>=) (offset_max voidP_a_8_17_alloc_table a_8)
      (Int.(-) (Uint32.to_int size_6) (1)))
     /\
     (forall __framac_tmp15 : int.
      ((((<=) (0) __framac_tmp15) /\
       ((<=) __framac_tmp15 (Int.(-) (Uint32.to_int size_6) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 2 13 24#
    (#"whole_program.jc" 1183 12 1050#
    ((#"whole_program.jc" 1183 12 1050#
     ((<=) (offset_min int_xP_max_18_alloc_table max) (0)))
    /\
    (#"whole_program.jc" 1183 12 1050#
    ((#"whole_program.jc" 1183 12 1050#
     ((>=) (offset_max int_xP_max_18_alloc_table max) (0)))
    /\ (#"whole_program.jc" 1183 12 1050# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_min.c" 3 13 24#
   (#"whole_program.jc" 1183 12 1050#
   ((#"whole_program.jc" 1183 12 1050#
    ((<=) (offset_min int_xP_min_19_alloc_table min) (0)))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"whole_program.jc" 1183 12 1050#
    ((>=) (offset_max int_xP_min_19_alloc_table min) (0)))
   /\ (#"whole_program.jc" 1183 12 1050# ((=) true true)))))))))))) }
   ensures { ("expl:Postcondition" ("expl:Ensures clause" true)) } diverges 
   ->
   'Init:
   try
    begin
    (check {
    (#"whole_program.jc" 1231 10 131# "expl:Behavior disjointness check"
    (not
    (((=) (Uint32.to_int size_6) (0)) /\ ((>) (Uint32.to_int size_6) (0)))))
    });
     (check {
     (#"whole_program.jc" 1234 10 124# "expl:Behavior completeness check"
     (((>) (Uint32.to_int size_6) (0)) \/ ((=) (Uint32.to_int size_6) (0))))
     });
     (let i_8_2 = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 20 7 15#
     (Unsafe_uint32.(>)  size_6
      (#"whole_program.jc" 1239 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_394 =
       (shift_  a_8
        (Unsafe_int32.to_int 
         (#"whole_program.jc" 1240 61 73# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_395 = max in
       (let _jessie_396 = (0) in
       (let _jessie_397 = _jessie_395 in
       (upd  int_xP_int_xM_max_18 _jessie_397 _jessie_394 )))));
        begin
        (let _jessie_389 = (acc  !int_xP_int_xM_max_18 max ) in
        (let _jessie_390 = min in
        (let _jessie_391 = (0) in
        (let _jessie_392 = _jessie_390 in
        (upd  int_xP_int_xM_min_19 _jessie_392 _jessie_389 )))));
         begin
         (i_8_2 :=
          (#"whole_program.jc" 1242 26 39# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_19:
          loop
          invariant
            { (((#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 39#
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 39#
                ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 31#
                 ((<=) (1) (Uint32.to_int !i_8_2)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 30 39#
                (Uint32.(<=) !i_8_2 size_6)))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 25 25 71#
                (exists j_10 : int.
                 (((<=) (0) j_10) /\
                 (((<) j_10 (Uint32.to_int !i_8_2)) /\
                 ((=) (shift a_8 j_10) (select !int_xP_int_xM_max_18 max))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 26 25 71#
                (exists j_11 : int.
                 (((<=) (0) j_11) /\
                 (((<) j_11 (Uint32.to_int !i_8_2)) /\
                 ((=) (shift a_8 j_11) (select !int_xP_int_xM_min_19 min))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 27 25 39#
                (Int32.(>=)
                (select intP_intM_a_8_17 (select !int_xP_int_xM_max_18 max))
                (select intP_intM_a_8_17 (select !int_xP_int_xM_min_19 min))))
               &&
               (#"/home/work/workspace/education/acsl-exam/./max_min.c" 28 25 81#
               (forall j_12 : int.
                ((((<=) (0) j_12) /\ ((<) j_12 (Uint32.to_int !i_8_2))) ->
                 ((Int32.(>=)
                  (select intP_intM_a_8_17
                  (select !int_xP_int_xM_max_18 max))
                  (select intP_intM_a_8_17 (shift a_8 j_12)))
                 /\
                 (Int32.(>=) (select intP_intM_a_8_17 (shift a_8 j_12))
                 (select intP_intM_a_8_17 (select !int_xP_int_xM_min_19 min)))))))))))
              /\
              (#"whole_program.jc" 1244 9 1974#
              ((#"whole_program.jc" 1244 9 1974# "expl:Assigns clause"
               (not_assigns int_xP_max_18_alloc_table
               int_xP_max_18_alloc_table (at !int_xP_int_xM_max_18 'Loop_19)
               !int_xP_int_xM_max_18 (pset_singleton max)))
              /\
              (#"whole_program.jc" 1244 9 1974# "expl:Assigns clause"
              (not_assigns int_xP_min_19_alloc_table
              int_xP_min_19_alloc_table (at !int_xP_int_xM_min_19 'Loop_19)
              !int_xP_int_xM_min_19 (pset_singleton min)))))) } 
           begin
           any unit requires { true } ensures { true } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 32 17 25#
             (Unsafe_uint32.(<)  !i_8_2 size_6 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_min.c" 33 13 25#
              (Unsafe_int32.(<) 
               (acc  intP_intM_a_8_17 (acc  !int_xP_int_xM_max_18 max ) )
               (acc  intP_intM_a_8_17
                (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) ) ))
              then
               (let _jessie_383 =
               (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) in
               (let _jessie_384 = max in
               (let _jessie_385 = (0) in
               (let _jessie_386 = _jessie_384 in
               (upd  int_xP_int_xM_max_18 _jessie_386 _jessie_383 )))))
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_min.c" 35 20 32#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_8_17 (acc  !int_xP_int_xM_min_19 min ) )
                (acc  intP_intM_a_8_17
                 (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) ) ))
               then
                (let _jessie_378 =
                (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) in
                (let _jessie_379 = min in
                (let _jessie_380 = (0) in
                (let _jessie_381 = _jessie_379 in
                (upd  int_xP_int_xM_min_19 _jessie_381 _jessie_378 )))))
               else ()));
              (i_8_2 :=
               (Unsafe_uint32.(+)  !i_8_2
                (#"whole_program.jc" 1280 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_34 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_32 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
  let max_min_ensures_positive_size
  #"/home/work/workspace/education/acsl-exam/./max_min.c" 18 5 58#
  "expl:Function max_min, behavior positive_size" =
  fun
   (a_8 : (pointer voidP)) (size_6 : Uint32.t) (max : (pointer int_xP)) (min
   : (pointer int_xP)) (int_xP_int_xM_max_18 : ref (memory int_xP (pointer
   voidP))) (int_xP_int_xM_min_19 : ref (memory int_xP (pointer voidP)))
   (int_xP_max_18_alloc_table : (alloc_table int_xP))
   (int_xP_min_19_alloc_table : (alloc_table int_xP))
   (voidP_a_8_17_alloc_table : (alloc_table voidP)) (voidP_a_8_17_tag_table :
   (tag_table voidP)) (intP_intM_a_8_17 : (memory voidP Int32.t)) 
   requires {
   (((>) (Uint32.to_int size_6) (0)) /\
   (((allocated voidP_a_8_17_alloc_table a_8) ->
     (((=) (typeof voidP_a_8_17_tag_table a_8) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_8_17_alloc_table a_8) i) /\
       ((<) i (offset_max voidP_a_8_17_alloc_table a_8))) ->
       ((=) (typeof voidP_a_8_17_tag_table (shift a_8 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_6) (1))) then
     (((<=) (offset_min voidP_a_8_17_alloc_table a_8) (0)) /\
     (((>=) (offset_max voidP_a_8_17_alloc_table a_8)
      (Int.(-) (Uint32.to_int size_6) (1)))
     /\
     (forall __framac_tmp15 : int.
      ((((<=) (0) __framac_tmp15) /\
       ((<=) __framac_tmp15 (Int.(-) (Uint32.to_int size_6) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 2 13 24#
    (#"whole_program.jc" 1183 12 1050#
    ((#"whole_program.jc" 1183 12 1050#
     ((<=) (offset_min int_xP_max_18_alloc_table max) (0)))
    /\
    (#"whole_program.jc" 1183 12 1050#
    ((#"whole_program.jc" 1183 12 1050#
     ((>=) (offset_max int_xP_max_18_alloc_table max) (0)))
    /\ (#"whole_program.jc" 1183 12 1050# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_min.c" 3 13 24#
   (#"whole_program.jc" 1183 12 1050#
   ((#"whole_program.jc" 1183 12 1050#
    ((<=) (offset_min int_xP_min_19_alloc_table min) (0)))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"whole_program.jc" 1183 12 1050#
    ((>=) (offset_max int_xP_min_19_alloc_table min) (0)))
   /\ (#"whole_program.jc" 1183 12 1050# ((=) true true))))))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"whole_program.jc" 1208 10 34# "expl:Assigns clause"
       (not_assigns int_xP_max_18_alloc_table int_xP_max_18_alloc_table (old
       !int_xP_int_xM_max_18) !int_xP_int_xM_max_18 (pset_singleton max)))
      /\
      (#"whole_program.jc" 1208 10 34# "expl:Assigns clause"
      (not_assigns int_xP_min_19_alloc_table int_xP_min_19_alloc_table (old
      !int_xP_int_xM_min_19) !int_xP_int_xM_min_19 (pset_singleton min))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
      "expl:Ensures clause"
      (exists i_29 : int.
       (((<=) (0) i_29) /\
       (((<) i_29 (Uint32.to_int size_6)) /\
       ((=) (shift a_8 i_29) (select !int_xP_int_xM_max_18 max))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 12 15 66#
      "expl:Ensures clause"
      (exists i_30 : int.
       (((<=) (0) i_30) /\
       (((<) i_30 (Uint32.to_int size_6)) /\
       ((=) (shift a_8 i_30) (select !int_xP_int_xM_min_19 min))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 13 15 29#
      "expl:Ensures clause"
      (Int32.(>=)
      (select intP_intM_a_8_17 (select !int_xP_int_xM_max_18 max))
      (select intP_intM_a_8_17 (select !int_xP_int_xM_min_19 min))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 14 15 74#
     "expl:Ensures clause"
     (forall i_31 : int.
      ((((<=) (0) i_31) /\ ((<) i_31 (Uint32.to_int size_6))) ->
       ((Int32.(>=)
        (select intP_intM_a_8_17 (select !int_xP_int_xM_max_18 max))
        (select intP_intM_a_8_17 (shift a_8 i_31)))
       /\
       (Int32.(>=) (select intP_intM_a_8_17 (shift a_8 i_31))
       (select intP_intM_a_8_17 (select !int_xP_int_xM_min_19 min))))))))))))))))
     } diverges  ->
   'Init:
   try
    begin
    (); ();
     (let i_8_2 = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 20 7 15#
     (Unsafe_uint32.(>)  size_6
      (#"whole_program.jc" 1239 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_438 =
       (shift_  a_8
        (Unsafe_int32.to_int 
         (#"whole_program.jc" 1240 61 73# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_439 = max in
       (let _jessie_440 = (0) in
       (let _jessie_441 = _jessie_439 in
       (upd  int_xP_int_xM_max_18 _jessie_441 _jessie_438 )))));
        begin
        (let _jessie_433 = (acc  !int_xP_int_xM_max_18 max ) in
        (let _jessie_434 = min in
        (let _jessie_435 = (0) in
        (let _jessie_436 = _jessie_434 in
        (upd  int_xP_int_xM_min_19 _jessie_436 _jessie_433 )))));
         begin
         (i_8_2 :=
          (#"whole_program.jc" 1242 26 39# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_21:
          loop
          invariant
            { (#"whole_program.jc" 1244 9 1974#
              ((#"whole_program.jc" 1208 10 34# "expl:Assigns clause"
               (not_assigns int_xP_max_18_alloc_table
               int_xP_max_18_alloc_table (at !int_xP_int_xM_max_18 'Init)
               !int_xP_int_xM_max_18 (pset_singleton max)))
              /\
              (#"whole_program.jc" 1208 10 34# "expl:Assigns clause"
              (not_assigns int_xP_min_19_alloc_table
              int_xP_min_19_alloc_table (at !int_xP_int_xM_min_19 'Init)
              !int_xP_int_xM_min_19 (pset_singleton min))))) } 
           begin
           any unit
           requires { true } reads { a_8, int_xP_int_xM_max_18,
           int_xP_int_xM_min_19, max, min, size_6 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 28 25 81#
              (forall j_12 : int.
               ((((<=) (0) j_12) /\ ((<) j_12 (Uint32.to_int !i_8_2))) ->
                ((Int32.(>=)
                 (select intP_intM_a_8_17 (select !int_xP_int_xM_max_18 max))
                 (select intP_intM_a_8_17 (shift a_8 j_12)))
                /\
                (Int32.(>=) (select intP_intM_a_8_17 (shift a_8 j_12))
                (select intP_intM_a_8_17 (select !int_xP_int_xM_min_19 min)))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 27 25 39#
              (Int32.(>=)
              (select intP_intM_a_8_17 (select !int_xP_int_xM_max_18 max))
              (select intP_intM_a_8_17 (select !int_xP_int_xM_min_19 min))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 26 25 71#
              (exists j_11 : int.
               (((<=) (0) j_11) /\
               (((<) j_11 (Uint32.to_int !i_8_2)) /\
               ((=) (shift a_8 j_11) (select !int_xP_int_xM_min_19 min))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 25 25 71#
              (exists j_10 : int.
               (((<=) (0) j_10) /\
               (((<) j_10 (Uint32.to_int !i_8_2)) /\
               ((=) (shift a_8 j_10) (select !int_xP_int_xM_max_18 max))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 39#
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 39#
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 31#
              ((<=) (1) (Uint32.to_int !i_8_2)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 30 39#
             (Uint32.(<=) !i_8_2 size_6))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 32 17 25#
             (Unsafe_uint32.(<)  !i_8_2 size_6 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_min.c" 33 13 25#
              (Unsafe_int32.(<) 
               (acc  intP_intM_a_8_17 (acc  !int_xP_int_xM_max_18 max ) )
               (acc  intP_intM_a_8_17
                (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) ) ))
              then
               (let _jessie_427 =
               (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) in
               (let _jessie_428 = max in
               (let _jessie_429 = (0) in
               (let _jessie_430 = _jessie_428 in
               (upd  int_xP_int_xM_max_18 _jessie_430 _jessie_427 )))))
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_min.c" 35 20 32#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_8_17 (acc  !int_xP_int_xM_min_19 min ) )
                (acc  intP_intM_a_8_17
                 (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) ) ))
               then
                (let _jessie_422 =
                (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) in
                (let _jessie_423 = min in
                (let _jessie_424 = (0) in
                (let _jessie_425 = _jessie_423 in
                (upd  int_xP_int_xM_min_19 _jessie_425 _jessie_422 )))))
               else ()));
              (i_8_2 :=
               (Unsafe_uint32.(+)  !i_8_2
                (#"whole_program.jc" 1280 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_34 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_32 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
  let max_min_ensures_zero_size
  #"/home/work/workspace/education/acsl-exam/./max_min.c" 18 5 58#
  "expl:Function max_min, behavior zero_size" =
  fun
   (a_8 : (pointer voidP)) (size_6 : Uint32.t) (max : (pointer int_xP)) (min
   : (pointer int_xP)) (int_xP_int_xM_max_18 : ref (memory int_xP (pointer
   voidP))) (int_xP_int_xM_min_19 : ref (memory int_xP (pointer voidP)))
   (int_xP_max_18_alloc_table : (alloc_table int_xP))
   (int_xP_min_19_alloc_table : (alloc_table int_xP))
   (voidP_a_8_17_alloc_table : (alloc_table voidP)) (voidP_a_8_17_tag_table :
   (tag_table voidP)) (intP_intM_a_8_17 : (memory voidP Int32.t)) 
   requires {
   (((=) (Uint32.to_int size_6) (0)) /\
   (((allocated voidP_a_8_17_alloc_table a_8) ->
     (((=) (typeof voidP_a_8_17_tag_table a_8) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_8_17_alloc_table a_8) i) /\
       ((<) i (offset_max voidP_a_8_17_alloc_table a_8))) ->
       ((=) (typeof voidP_a_8_17_tag_table (shift a_8 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_6) (1))) then
     (((<=) (offset_min voidP_a_8_17_alloc_table a_8) (0)) /\
     (((>=) (offset_max voidP_a_8_17_alloc_table a_8)
      (Int.(-) (Uint32.to_int size_6) (1)))
     /\
     (forall __framac_tmp15 : int.
      ((((<=) (0) __framac_tmp15) /\
       ((<=) __framac_tmp15 (Int.(-) (Uint32.to_int size_6) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 2 13 24#
    (#"whole_program.jc" 1183 12 1050#
    ((#"whole_program.jc" 1183 12 1050#
     ((<=) (offset_min int_xP_max_18_alloc_table max) (0)))
    /\
    (#"whole_program.jc" 1183 12 1050#
    ((#"whole_program.jc" 1183 12 1050#
     ((>=) (offset_max int_xP_max_18_alloc_table max) (0)))
    /\ (#"whole_program.jc" 1183 12 1050# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_min.c" 3 13 24#
   (#"whole_program.jc" 1183 12 1050#
   ((#"whole_program.jc" 1183 12 1050#
    ((<=) (offset_min int_xP_min_19_alloc_table min) (0)))
   /\
   (#"whole_program.jc" 1183 12 1050#
   ((#"whole_program.jc" 1183 12 1050#
    ((>=) (offset_max int_xP_min_19_alloc_table min) (0)))
   /\ (#"whole_program.jc" 1183 12 1050# ((=) true true))))))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"whole_program.jc" 1203 10 18# "expl:Assigns clause"
       (not_assigns int_xP_max_18_alloc_table int_xP_max_18_alloc_table (old
       !int_xP_int_xM_max_18) !int_xP_int_xM_max_18 pset_empty))
      /\
      (#"whole_program.jc" 1203 10 18# "expl:Assigns clause"
      (not_assigns int_xP_min_19_alloc_table int_xP_min_19_alloc_table (old
      !int_xP_int_xM_min_19) !int_xP_int_xM_min_19 pset_empty)))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 15 51#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 15 51#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 15 31#
      "expl:Ensures clause" ((=) max max))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 35 51#
     "expl:Ensures clause" ((=) min min))))))) } diverges  ->
   'Init:
   try
    begin
    (); ();
     (let i_8_2 = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_min.c" 20 7 15#
     (Unsafe_uint32.(>)  size_6
      (#"whole_program.jc" 1239 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_416 =
       (shift_  a_8
        (Unsafe_int32.to_int 
         (#"whole_program.jc" 1240 61 73# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_417 = max in
       (let _jessie_418 = (0) in
       (let _jessie_419 = _jessie_417 in
       (upd  int_xP_int_xM_max_18 _jessie_419 _jessie_416 )))));
        begin
        (let _jessie_411 = (acc  !int_xP_int_xM_max_18 max ) in
        (let _jessie_412 = min in
        (let _jessie_413 = (0) in
        (let _jessie_414 = _jessie_412 in
        (upd  int_xP_int_xM_min_19 _jessie_414 _jessie_411 )))));
         begin
         (i_8_2 :=
          (#"whole_program.jc" 1242 26 39# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_20:
          loop
          invariant
            { (#"whole_program.jc" 1244 9 1974#
              ((#"whole_program.jc" 1203 10 18# "expl:Assigns clause"
               (not_assigns int_xP_max_18_alloc_table
               int_xP_max_18_alloc_table (at !int_xP_int_xM_max_18 'Init)
               !int_xP_int_xM_max_18 pset_empty))
              /\
              (#"whole_program.jc" 1203 10 18# "expl:Assigns clause"
              (not_assigns int_xP_min_19_alloc_table
              int_xP_min_19_alloc_table (at !int_xP_int_xM_min_19 'Init)
              !int_xP_int_xM_min_19 pset_empty)))) } 
           begin
           any unit
           requires { true } reads { a_8, int_xP_int_xM_max_18,
           int_xP_int_xM_min_19, max, min, size_6 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 28 25 81#
              (forall j_12 : int.
               ((((<=) (0) j_12) /\ ((<) j_12 (Uint32.to_int !i_8_2))) ->
                ((Int32.(>=)
                 (select intP_intM_a_8_17 (select !int_xP_int_xM_max_18 max))
                 (select intP_intM_a_8_17 (shift a_8 j_12)))
                /\
                (Int32.(>=) (select intP_intM_a_8_17 (shift a_8 j_12))
                (select intP_intM_a_8_17 (select !int_xP_int_xM_min_19 min)))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 27 25 39#
              (Int32.(>=)
              (select intP_intM_a_8_17 (select !int_xP_int_xM_max_18 max))
              (select intP_intM_a_8_17 (select !int_xP_int_xM_min_19 min))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 26 25 71#
              (exists j_11 : int.
               (((<=) (0) j_11) /\
               (((<) j_11 (Uint32.to_int !i_8_2)) /\
               ((=) (shift a_8 j_11) (select !int_xP_int_xM_min_19 min))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 25 25 71#
              (exists j_10 : int.
               (((<=) (0) j_10) /\
               (((<) j_10 (Uint32.to_int !i_8_2)) /\
               ((=) (shift a_8 j_10) (select !int_xP_int_xM_max_18 max))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 39#
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 39#
             ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 25 31#
              ((<=) (1) (Uint32.to_int !i_8_2)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 24 30 39#
             (Uint32.(<=) !i_8_2 size_6))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_min.c" 32 17 25#
             (Unsafe_uint32.(<)  !i_8_2 size_6 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_min.c" 33 13 25#
              (Unsafe_int32.(<) 
               (acc  intP_intM_a_8_17 (acc  !int_xP_int_xM_max_18 max ) )
               (acc  intP_intM_a_8_17
                (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) ) ))
              then
               (let _jessie_405 =
               (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) in
               (let _jessie_406 = max in
               (let _jessie_407 = (0) in
               (let _jessie_408 = _jessie_406 in
               (upd  int_xP_int_xM_max_18 _jessie_408 _jessie_405 )))))
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_min.c" 35 20 32#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_8_17 (acc  !int_xP_int_xM_min_19 min ) )
                (acc  intP_intM_a_8_17
                 (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) ) ))
               then
                (let _jessie_400 =
                (shift_  a_8 (Unsafe_uint32.to_int  !i_8_2 ) ) in
                (let _jessie_401 = min in
                (let _jessie_402 = (0) in
                (let _jessie_403 = _jessie_401 in
                (upd  int_xP_int_xM_min_19 _jessie_403 _jessie_400 )))))
               else ()));
              (i_8_2 :=
               (Unsafe_uint32.(+)  !i_8_2
                (#"whole_program.jc" 1280 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_34 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_32 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
end

module Function_min_min_safety

  use enum.Uint32 
  
  use import Struct_intP 
  
  use Safe_uint32 
  
  use Safe_int32 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let min_min
  #"/home/work/workspace/education/acsl-exam/./min_min.c" 21 5 59#
  "expl:Function min_min, safety" =
  fun
   (a_9 : (pointer voidP)) (size_7 : Uint32.t) (min1 : (pointer int_xP))
   (min2 : (pointer int_xP)) (int_xP_int_xM_min1_21 : ref (memory int_xP
   (pointer voidP))) (int_xP_int_xM_min2_22 : ref (memory int_xP (pointer
   voidP))) (int_xP_min1_21_alloc_table : (alloc_table int_xP))
   (int_xP_min2_22_alloc_table : (alloc_table int_xP))
   (voidP_a_9_20_alloc_table : (alloc_table voidP)) (voidP_a_9_20_tag_table :
   (tag_table voidP)) (intP_intM_a_9_20 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_9_20_alloc_table a_9) ->
     (((=) (typeof voidP_a_9_20_tag_table a_9) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_9_20_alloc_table a_9) i) /\
       ((<) i (offset_max voidP_a_9_20_alloc_table a_9))) ->
       ((=) (typeof voidP_a_9_20_tag_table (shift a_9 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_7) (1))) then
     (((<=) (offset_min voidP_a_9_20_alloc_table a_9) (0)) /\
     (((>=) (offset_max voidP_a_9_20_alloc_table a_9)
      (Int.(-) (Uint32.to_int size_7) (1)))
     /\
     (forall __framac_tmp20 : int.
      ((((<=) (0) __framac_tmp20) /\
       ((<=) __framac_tmp20 (Int.(-) (Uint32.to_int size_7) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 2 13 25#
    (#"whole_program.jc" 1291 12 1287#
    ((#"whole_program.jc" 1291 12 1287#
     ((<=) (offset_min int_xP_min1_21_alloc_table min1) (0)))
    /\
    (#"whole_program.jc" 1291 12 1287#
    ((#"whole_program.jc" 1291 12 1287#
     ((>=) (offset_max int_xP_min1_21_alloc_table min1) (0)))
    /\ (#"whole_program.jc" 1291 12 1287# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./min_min.c" 2 29 41#
   (#"whole_program.jc" 1291 12 1287#
   ((#"whole_program.jc" 1291 12 1287#
    ((<=) (offset_min int_xP_min2_22_alloc_table min2) (0)))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"whole_program.jc" 1291 12 1287#
    ((>=) (offset_max int_xP_min2_22_alloc_table min2) (0)))
   /\ (#"whole_program.jc" 1291 12 1287# ((=) true true)))))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (); ();
     (let i_9_0 = ref (Safe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 24 7 15#
     (Safe_uint32.(>)  size_7
      (#"whole_program.jc" 1382 30 43# "expl:Integer cast"
      (Safe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_568 =
       (let _jessie_567 =
       (shift_typesafe  a_9
        (Safe_int32.to_int 
         (#"whole_program.jc" 1383 62 74# "expl:Integer cast"
         (Safe_int32.of_int (0))) ) ) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./min_min.c" 27 6 19#
       "expl:Pointer index bounds" true) }); _jessie_567 end) in
       (let _jessie_569 = min1 in
       (let _jessie_570 = (0) in
       (let _jessie_571 = _jessie_569 in
       (#"/home/work/workspace/education/acsl-exam/./min_min.c" 27 6 19#
       "expl:Pointer dereference"
       (upd  int_xP_min1_21_alloc_table int_xP_int_xM_min1_21 _jessie_569
        _jessie_568 ))))));
        begin
        (let _jessie_563 =
        (let _jessie_562 =
        (#"/home/work/workspace/education/acsl-exam/./min_min.c" 28 14 19#
        "expl:Pointer dereference"
        (acc  int_xP_min1_21_alloc_table !int_xP_int_xM_min1_21 min1 )) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./min_min.c" 28 6 19#
        "expl:Pointer index bounds" true) }); _jessie_562 end) in
        (let _jessie_564 = min2 in
        (let _jessie_565 = (0) in
        (let _jessie_566 = _jessie_564 in
        (#"/home/work/workspace/education/acsl-exam/./min_min.c" 28 6 19#
        "expl:Pointer dereference"
        (upd  int_xP_min2_22_alloc_table int_xP_int_xM_min2_22 _jessie_564
         _jessie_563 ))))));
         begin
         (i_9_0 :=
          (let _jessie_545 =
          (#"whole_program.jc" 1385 26 39# "expl:Integer cast"
          (Safe_uint32.of_int (1))) in
          begin
          (assert {
          (#"/home/work/workspace/education/acsl-exam/./min_min.c" 40 10 15#
          "expl:Pointer index bounds" true) }); _jessie_545 end));
          'Loop_26:
          loop
          invariant { (#"whole_program.jc" 1387 9 3372# true) }
            variant {
              (#"/home/work/workspace/education/acsl-exam/./min_min.c" 38 23 31#
              (Int.(-) (Uint32.to_int size_7) (Uint32.to_int !i_9_0))) }
           begin
           any unit
           requires { true } reads { a_9, int_xP_int_xM_min1_21,
           int_xP_int_xM_min2_22, min1, min2, size_7 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 36 25 135#
              (not
              (exists j_17 : int.
               (exists k_2 : int.
                (((<=) (0) j_17) /\
                (((<) j_17 (Uint32.to_int !i_9_0)) /\
                (((<=) (0) k_2) /\
                (((<) k_2 (Uint32.to_int !i_9_0)) /\
                (((<>) j_17 k_2) /\
                ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 j_17))
                 (select intP_intM_a_9_20
                 (select !int_xP_int_xM_min2_22 min2)))
                /\
                ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 k_2))
                 (select intP_intM_a_9_20
                 (select !int_xP_int_xM_min2_22 min2)))
                /\
                (Int32.(<) (select intP_intM_a_9_20 (shift a_9 k_2))
                (select intP_intM_a_9_20 (shift a_9 j_17))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 35 25 90#
              (exists j_16 : int.
               (((<=) (0) j_16) /\
               (((<) j_16 (Uint32.to_int !i_9_0)) /\
               ((Int32.(<=) (select intP_intM_a_9_20 (shift a_9 j_16))
                (select intP_intM_a_9_20
                (select !int_xP_int_xM_min2_22 min2)))
               /\
               (Int32.(=) (select intP_intM_a_9_20 (shift a_9 j_16))
               (select intP_intM_a_9_20 (select !int_xP_int_xM_min1_21 min1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 34 25 73#
              (forall j_15 : int.
               ((((<=) (0) j_15) /\ ((<) j_15 (Uint32.to_int !i_9_0))) ->
                (Int32.(>=) (select intP_intM_a_9_20 (shift a_9 j_15))
                (select intP_intM_a_9_20
                (select !int_xP_int_xM_min1_21 min1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 33 25 41#
              (Int32.(<=)
              (select intP_intM_a_9_20 (select !int_xP_int_xM_min1_21 min1))
              (select intP_intM_a_9_20 (select !int_xP_int_xM_min2_22 min2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 32 25 74#
              (exists j_14 : int.
               (((<=) (0) j_14) /\
               (((<) j_14 (Uint32.to_int !i_9_0)) /\
               ((=) (shift a_9 j_14) (select !int_xP_int_xM_min2_22 min2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 31 25 74#
              (exists j_13 : int.
               (((<=) (0) j_13) /\
               (((<) j_13 (Uint32.to_int !i_9_0)) /\
               ((=) (shift a_9 j_13) (select !int_xP_int_xM_min1_21 min1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 38#
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 38#
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 30#
              ((<) (0) (Uint32.to_int !i_9_0)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 29 38#
             (Uint32.(<=) !i_9_0 size_7))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 40 17 25#
             (Safe_uint32.(<)  !i_9_0 size_7 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./min_min.c" 41 13 26#
              (Safe_int32.(<) 
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 41 13 17#
               "expl:Pointer dereference"
               (acc_offset_typesafe  voidP_a_9_20_alloc_table
                intP_intM_a_9_20 a_9 (Safe_uint32.to_int  !i_9_0 ) ))
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 41 20 26#
               "expl:Pointer dereference"
               (acc  voidP_a_9_20_alloc_table intP_intM_a_9_20
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 41 21 26#
                "expl:Pointer dereference"
                (acc  int_xP_min1_21_alloc_table !int_xP_int_xM_min1_21 min1
                 )) )) ))
              then
               begin
               (let _jessie_552 =
               (let _jessie_551 =
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 42 20 25#
               "expl:Pointer dereference"
               (acc  int_xP_min1_21_alloc_table !int_xP_int_xM_min1_21 min1 ))
               in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 42 12 25#
               "expl:Pointer index bounds" true) }); _jessie_551 end) in
               (let _jessie_553 = min2 in
               (let _jessie_554 = (0) in
               (let _jessie_555 = _jessie_553 in
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 42 12 25#
               "expl:Pointer dereference"
               (upd  int_xP_min2_22_alloc_table int_xP_int_xM_min2_22
                _jessie_553 _jessie_552 ))))));
                (let _jessie_557 =
                (let _jessie_556 =
                (shift_typesafe  a_9 (Safe_uint32.to_int  !i_9_0 ) ) in
                begin
                (assert {
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 43 12 25#
                "expl:Pointer index bounds" true) }); _jessie_556 end) in
                (let _jessie_558 = min1 in
                (let _jessie_559 = (0) in
                (let _jessie_560 = _jessie_558 in
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 43 12 25#
                "expl:Pointer dereference"
                (upd  int_xP_min1_21_alloc_table int_xP_int_xM_min1_21
                 _jessie_558 _jessie_557 )))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 44 20 33#
               (Safe_int32.(<) 
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 44 20 24#
                "expl:Pointer dereference"
                (acc_offset_typesafe  voidP_a_9_20_alloc_table
                 intP_intM_a_9_20 a_9 (Safe_uint32.to_int  !i_9_0 ) ))
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 44 27 33#
                "expl:Pointer dereference"
                (acc  voidP_a_9_20_alloc_table intP_intM_a_9_20
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 44 28 33#
                 "expl:Pointer dereference"
                 (acc  int_xP_min2_22_alloc_table !int_xP_int_xM_min2_22 min2
                  )) )) ))
               then
                (let _jessie_547 =
                (let _jessie_546 =
                (shift_typesafe  a_9 (Safe_uint32.to_int  !i_9_0 ) ) in
                begin
                (assert {
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 45 12 25#
                "expl:Pointer index bounds" true) }); _jessie_546 end) in
                (let _jessie_548 = min2 in
                (let _jessie_549 = (0) in
                (let _jessie_550 = _jessie_548 in
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 45 12 25#
                "expl:Pointer dereference"
                (upd  int_xP_min2_22_alloc_table int_xP_int_xM_min2_22
                 _jessie_548 _jessie_547 )))))) else ()));
              (i_9_0 :=
               (let _jessie_561 =
               (Safe_uint32.(+)  !i_9_0
                (#"whole_program.jc" 1445 60 73# "expl:Integer cast"
                (Safe_uint32.of_int (1))) ) in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 40 27 30#
               "expl:Pointer index bounds" true) }); _jessie_561 end)) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_37 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_35 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
end

module Function_min_min_behaviors

  use Unsafe_uint32 
  
  use Unsafe_int32 
  
  use enum.Uint32 
  
  use import Struct_intP 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let min_min_ensures_default
  #"/home/work/workspace/education/acsl-exam/./min_min.c" 21 5 59#
  "expl:Function min_min, default behavior" =
  fun
   (a_9 : (pointer voidP)) (size_7 : Uint32.t) (min1 : (pointer int_xP))
   (min2 : (pointer int_xP)) (int_xP_int_xM_min1_21 : ref (memory int_xP
   (pointer voidP))) (int_xP_int_xM_min2_22 : ref (memory int_xP (pointer
   voidP))) (int_xP_min1_21_alloc_table : (alloc_table int_xP))
   (int_xP_min2_22_alloc_table : (alloc_table int_xP))
   (voidP_a_9_20_alloc_table : (alloc_table voidP)) (voidP_a_9_20_tag_table :
   (tag_table voidP)) (intP_intM_a_9_20 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_9_20_alloc_table a_9) ->
     (((=) (typeof voidP_a_9_20_tag_table a_9) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_9_20_alloc_table a_9) i) /\
       ((<) i (offset_max voidP_a_9_20_alloc_table a_9))) ->
       ((=) (typeof voidP_a_9_20_tag_table (shift a_9 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_7) (1))) then
     (((<=) (offset_min voidP_a_9_20_alloc_table a_9) (0)) /\
     (((>=) (offset_max voidP_a_9_20_alloc_table a_9)
      (Int.(-) (Uint32.to_int size_7) (1)))
     /\
     (forall __framac_tmp20 : int.
      ((((<=) (0) __framac_tmp20) /\
       ((<=) __framac_tmp20 (Int.(-) (Uint32.to_int size_7) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 2 13 25#
    (#"whole_program.jc" 1291 12 1287#
    ((#"whole_program.jc" 1291 12 1287#
     ((<=) (offset_min int_xP_min1_21_alloc_table min1) (0)))
    /\
    (#"whole_program.jc" 1291 12 1287#
    ((#"whole_program.jc" 1291 12 1287#
     ((>=) (offset_max int_xP_min1_21_alloc_table min1) (0)))
    /\ (#"whole_program.jc" 1291 12 1287# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./min_min.c" 2 29 41#
   (#"whole_program.jc" 1291 12 1287#
   ((#"whole_program.jc" 1291 12 1287#
    ((<=) (offset_min int_xP_min2_22_alloc_table min2) (0)))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"whole_program.jc" 1291 12 1287#
    ((>=) (offset_max int_xP_min2_22_alloc_table min2) (0)))
   /\ (#"whole_program.jc" 1291 12 1287# ((=) true true)))))))))))) }
   ensures { ("expl:Postcondition" ("expl:Ensures clause" true)) } diverges 
   ->
   'Init:
   try
    begin
    (check {
    (#"whole_program.jc" 1374 10 131# "expl:Behavior disjointness check"
    (not
    (((=) (Uint32.to_int size_7) (0)) /\ ((>) (Uint32.to_int size_7) (0)))))
    });
     (check {
     (#"whole_program.jc" 1377 10 124# "expl:Behavior completeness check"
     (((>) (Uint32.to_int size_7) (0)) \/ ((=) (Uint32.to_int size_7) (0))))
     });
     (let i_9_0 = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 24 7 15#
     (Unsafe_uint32.(>)  size_7
      (#"whole_program.jc" 1382 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_487 =
       (shift_  a_9
        (Unsafe_int32.to_int 
         (#"whole_program.jc" 1383 62 74# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_488 = min1 in
       (let _jessie_489 = (0) in
       (let _jessie_490 = _jessie_488 in
       (upd  int_xP_int_xM_min1_21 _jessie_490 _jessie_487 )))));
        begin
        (let _jessie_482 = (acc  !int_xP_int_xM_min1_21 min1 ) in
        (let _jessie_483 = min2 in
        (let _jessie_484 = (0) in
        (let _jessie_485 = _jessie_483 in
        (upd  int_xP_int_xM_min2_22 _jessie_485 _jessie_482 )))));
         begin
         (i_9_0 :=
          (#"whole_program.jc" 1385 26 39# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_23:
          loop
          invariant
            { (((#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 38#
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 38#
                ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 30#
                 ((<) (0) (Uint32.to_int !i_9_0)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 29 38#
                (Uint32.(<=) !i_9_0 size_7)))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 31 25 74#
                (exists j_13 : int.
                 (((<=) (0) j_13) /\
                 (((<) j_13 (Uint32.to_int !i_9_0)) /\
                 ((=) (shift a_9 j_13) (select !int_xP_int_xM_min1_21 min1))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 32 25 74#
                (exists j_14 : int.
                 (((<=) (0) j_14) /\
                 (((<) j_14 (Uint32.to_int !i_9_0)) /\
                 ((=) (shift a_9 j_14) (select !int_xP_int_xM_min2_22 min2))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 33 25 41#
                (Int32.(<=)
                (select intP_intM_a_9_20
                (select !int_xP_int_xM_min1_21 min1))
                (select intP_intM_a_9_20
                (select !int_xP_int_xM_min2_22 min2))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 34 25 73#
                (forall j_15 : int.
                 ((((<=) (0) j_15) /\ ((<) j_15 (Uint32.to_int !i_9_0))) ->
                  (Int32.(>=) (select intP_intM_a_9_20 (shift a_9 j_15))
                  (select intP_intM_a_9_20
                  (select !int_xP_int_xM_min1_21 min1))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 35 25 90#
                (exists j_16 : int.
                 (((<=) (0) j_16) /\
                 (((<) j_16 (Uint32.to_int !i_9_0)) /\
                 ((Int32.(<=) (select intP_intM_a_9_20 (shift a_9 j_16))
                  (select intP_intM_a_9_20
                  (select !int_xP_int_xM_min2_22 min2)))
                 /\
                 (Int32.(=) (select intP_intM_a_9_20 (shift a_9 j_16))
                 (select intP_intM_a_9_20
                 (select !int_xP_int_xM_min1_21 min1))))))))
               &&
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 36 25 135#
               (not
               (exists j_17 : int.
                (exists k_2 : int.
                 (((<=) (0) j_17) /\
                 (((<) j_17 (Uint32.to_int !i_9_0)) /\
                 (((<=) (0) k_2) /\
                 (((<) k_2 (Uint32.to_int !i_9_0)) /\
                 (((<>) j_17 k_2) /\
                 ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 j_17))
                  (select intP_intM_a_9_20
                  (select !int_xP_int_xM_min2_22 min2)))
                 /\
                 ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 k_2))
                  (select intP_intM_a_9_20
                  (select !int_xP_int_xM_min2_22 min2)))
                 /\
                 (Int32.(<) (select intP_intM_a_9_20 (shift a_9 k_2))
                 (select intP_intM_a_9_20 (shift a_9 j_17))))))))))))))))))))
              /\
              (#"whole_program.jc" 1387 9 3372#
              ((#"whole_program.jc" 1387 9 3372# "expl:Assigns clause"
               (not_assigns int_xP_min1_21_alloc_table
               int_xP_min1_21_alloc_table (at !int_xP_int_xM_min1_21
               'Loop_23) !int_xP_int_xM_min1_21 (pset_singleton min1)))
              /\
              (#"whole_program.jc" 1387 9 3372# "expl:Assigns clause"
              (not_assigns int_xP_min2_22_alloc_table
              int_xP_min2_22_alloc_table (at !int_xP_int_xM_min2_22 'Loop_23)
              !int_xP_int_xM_min2_22 (pset_singleton min2)))))) } 
           begin
           any unit requires { true } ensures { true } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 40 17 25#
             (Unsafe_uint32.(<)  !i_9_0 size_7 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./min_min.c" 41 13 26#
              (Unsafe_int32.(<) 
               (acc  intP_intM_a_9_20
                (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) )
               (acc  intP_intM_a_9_20 (acc  !int_xP_int_xM_min1_21 min1 ) ) ))
              then
               begin
               (let _jessie_471 = (acc  !int_xP_int_xM_min1_21 min1 ) in
               (let _jessie_472 = min2 in
               (let _jessie_473 = (0) in
               (let _jessie_474 = _jessie_472 in
               (upd  int_xP_int_xM_min2_22 _jessie_474 _jessie_471 )))));
                (let _jessie_476 =
                (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) in
                (let _jessie_477 = min1 in
                (let _jessie_478 = (0) in
                (let _jessie_479 = _jessie_477 in
                (upd  int_xP_int_xM_min1_21 _jessie_479 _jessie_476 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 44 20 33#
               (Unsafe_int32.(<) 
                (acc  intP_intM_a_9_20
                 (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) )
                (acc  intP_intM_a_9_20 (acc  !int_xP_int_xM_min2_22 min2 ) )
                ))
               then
                (let _jessie_466 =
                (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) in
                (let _jessie_467 = min2 in
                (let _jessie_468 = (0) in
                (let _jessie_469 = _jessie_467 in
                (upd  int_xP_int_xM_min2_22 _jessie_469 _jessie_466 )))))
               else ()));
              (i_9_0 :=
               (Unsafe_uint32.(+)  !i_9_0
                (#"whole_program.jc" 1445 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_37 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_35 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
  let min_min_ensures_positive_size
  #"/home/work/workspace/education/acsl-exam/./min_min.c" 21 5 59#
  "expl:Function min_min, behavior positive_size" =
  fun
   (a_9 : (pointer voidP)) (size_7 : Uint32.t) (min1 : (pointer int_xP))
   (min2 : (pointer int_xP)) (int_xP_int_xM_min1_21 : ref (memory int_xP
   (pointer voidP))) (int_xP_int_xM_min2_22 : ref (memory int_xP (pointer
   voidP))) (int_xP_min1_21_alloc_table : (alloc_table int_xP))
   (int_xP_min2_22_alloc_table : (alloc_table int_xP))
   (voidP_a_9_20_alloc_table : (alloc_table voidP)) (voidP_a_9_20_tag_table :
   (tag_table voidP)) (intP_intM_a_9_20 : (memory voidP Int32.t)) 
   requires {
   (((>) (Uint32.to_int size_7) (0)) /\
   (((allocated voidP_a_9_20_alloc_table a_9) ->
     (((=) (typeof voidP_a_9_20_tag_table a_9) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_9_20_alloc_table a_9) i) /\
       ((<) i (offset_max voidP_a_9_20_alloc_table a_9))) ->
       ((=) (typeof voidP_a_9_20_tag_table (shift a_9 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_7) (1))) then
     (((<=) (offset_min voidP_a_9_20_alloc_table a_9) (0)) /\
     (((>=) (offset_max voidP_a_9_20_alloc_table a_9)
      (Int.(-) (Uint32.to_int size_7) (1)))
     /\
     (forall __framac_tmp20 : int.
      ((((<=) (0) __framac_tmp20) /\
       ((<=) __framac_tmp20 (Int.(-) (Uint32.to_int size_7) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 2 13 25#
    (#"whole_program.jc" 1291 12 1287#
    ((#"whole_program.jc" 1291 12 1287#
     ((<=) (offset_min int_xP_min1_21_alloc_table min1) (0)))
    /\
    (#"whole_program.jc" 1291 12 1287#
    ((#"whole_program.jc" 1291 12 1287#
     ((>=) (offset_max int_xP_min1_21_alloc_table min1) (0)))
    /\ (#"whole_program.jc" 1291 12 1287# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./min_min.c" 2 29 41#
   (#"whole_program.jc" 1291 12 1287#
   ((#"whole_program.jc" 1291 12 1287#
    ((<=) (offset_min int_xP_min2_22_alloc_table min2) (0)))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"whole_program.jc" 1291 12 1287#
    ((>=) (offset_max int_xP_min2_22_alloc_table min2) (0)))
   /\ (#"whole_program.jc" 1291 12 1287# ((=) true true))))))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"whole_program.jc" 1320 10 36# "expl:Assigns clause"
       (not_assigns int_xP_min1_21_alloc_table int_xP_min1_21_alloc_table
       (old !int_xP_int_xM_min1_21) !int_xP_int_xM_min1_21
       (pset_singleton min1)))
      /\
      (#"whole_program.jc" 1320 10 36# "expl:Assigns clause"
      (not_assigns int_xP_min2_22_alloc_table int_xP_min2_22_alloc_table (old
      !int_xP_int_xM_min2_22) !int_xP_int_xM_min2_22 (pset_singleton min2))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 27#
      "expl:Ensures clause"
      (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
       "expl:Ensures clause"
       ((<=) (offset_min int_xP_min1_21_alloc_table min1) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
       "expl:Ensures clause"
       ((>=) (offset_max int_xP_min1_21_alloc_table min1) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
      "expl:Ensures clause" ((=) true true)))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 31 43#
      "expl:Ensures clause"
      (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
       "expl:Ensures clause"
       ((<=) (offset_min int_xP_min2_22_alloc_table min2) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
       "expl:Ensures clause"
       ((>=) (offset_max int_xP_min2_22_alloc_table min2) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
      "expl:Ensures clause" ((=) true true)))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 12 15 67#
      "expl:Ensures clause"
      (exists i_32 : int.
       (((<=) (0) i_32) /\
       (((<) i_32 (Uint32.to_int size_7)) /\
       ((=) (shift a_9 i_32) (select !int_xP_int_xM_min1_21 min1))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 13 15 67#
      "expl:Ensures clause"
      (exists i_33 : int.
       (((<=) (0) i_33) /\
       (((<) i_33 (Uint32.to_int size_7)) /\
       ((=) (shift a_9 i_33) (select !int_xP_int_xM_min2_22 min2))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 14 15 31#
      "expl:Ensures clause"
      (Int32.(<=)
      (select intP_intM_a_9_20 (select !int_xP_int_xM_min1_21 min1))
      (select intP_intM_a_9_20 (select !int_xP_int_xM_min2_22 min2))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 15 15 66#
      "expl:Ensures clause"
      (forall i_34 : int.
       ((((<=) (0) i_34) /\ ((<) i_34 (Uint32.to_int size_7))) ->
        (Int32.(>=) (select intP_intM_a_9_20 (shift a_9 i_34))
        (select intP_intM_a_9_20 (select !int_xP_int_xM_min1_21 min1))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 16 15 83#
      "expl:Ensures clause"
      (exists i_35 : int.
       (((<=) (0) i_35) /\
       (((<) i_35 (Uint32.to_int size_7)) /\
       ((Int32.(<=) (select intP_intM_a_9_20 (shift a_9 i_35))
        (select intP_intM_a_9_20 (select !int_xP_int_xM_min2_22 min2)))
       /\
       (Int32.(=) (select intP_intM_a_9_20 (shift a_9 i_35))
       (select intP_intM_a_9_20 (select !int_xP_int_xM_min1_21 min1))))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 17 15 131#
     "expl:Ensures clause"
     (not
     (exists i_36 : int.
      (exists j_18 : int.
       (((<=) (0) i_36) /\
       (((<) i_36 (Uint32.to_int size_7)) /\
       (((<=) (0) j_18) /\
       (((<) j_18 (Uint32.to_int size_7)) /\
       (((<>) i_36 j_18) /\
       ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 i_36))
        (select intP_intM_a_9_20 (select !int_xP_int_xM_min2_22 min2)))
       /\
       ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 j_18))
        (select intP_intM_a_9_20 (select !int_xP_int_xM_min2_22 min2)))
       /\
       (Int32.(<) (select intP_intM_a_9_20 (shift a_9 i_36))
       (select intP_intM_a_9_20 (shift a_9 j_18)))))))))))))))))))))))))))))))
     } diverges  ->
   'Init:
   try
    begin
    (); ();
     (let i_9_0 = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 24 7 15#
     (Unsafe_uint32.(>)  size_7
      (#"whole_program.jc" 1382 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_541 =
       (shift_  a_9
        (Unsafe_int32.to_int 
         (#"whole_program.jc" 1383 62 74# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_542 = min1 in
       (let _jessie_543 = (0) in
       (let _jessie_544 = _jessie_542 in
       (upd  int_xP_int_xM_min1_21 _jessie_544 _jessie_541 )))));
        begin
        (let _jessie_536 = (acc  !int_xP_int_xM_min1_21 min1 ) in
        (let _jessie_537 = min2 in
        (let _jessie_538 = (0) in
        (let _jessie_539 = _jessie_537 in
        (upd  int_xP_int_xM_min2_22 _jessie_539 _jessie_536 )))));
         begin
         (i_9_0 :=
          (#"whole_program.jc" 1385 26 39# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_25:
          loop
          invariant
            { (#"whole_program.jc" 1387 9 3372#
              ((#"whole_program.jc" 1320 10 36# "expl:Assigns clause"
               (not_assigns int_xP_min1_21_alloc_table
               int_xP_min1_21_alloc_table (at !int_xP_int_xM_min1_21 'Init)
               !int_xP_int_xM_min1_21 (pset_singleton min1)))
              /\
              (#"whole_program.jc" 1320 10 36# "expl:Assigns clause"
              (not_assigns int_xP_min2_22_alloc_table
              int_xP_min2_22_alloc_table (at !int_xP_int_xM_min2_22 'Init)
              !int_xP_int_xM_min2_22 (pset_singleton min2))))) } 
           begin
           any unit
           requires { true } reads { a_9, int_xP_int_xM_min1_21,
           int_xP_int_xM_min2_22, min1, min2, size_7 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 36 25 135#
              (not
              (exists j_17 : int.
               (exists k_2 : int.
                (((<=) (0) j_17) /\
                (((<) j_17 (Uint32.to_int !i_9_0)) /\
                (((<=) (0) k_2) /\
                (((<) k_2 (Uint32.to_int !i_9_0)) /\
                (((<>) j_17 k_2) /\
                ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 j_17))
                 (select intP_intM_a_9_20
                 (select !int_xP_int_xM_min2_22 min2)))
                /\
                ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 k_2))
                 (select intP_intM_a_9_20
                 (select !int_xP_int_xM_min2_22 min2)))
                /\
                (Int32.(<) (select intP_intM_a_9_20 (shift a_9 k_2))
                (select intP_intM_a_9_20 (shift a_9 j_17))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 35 25 90#
              (exists j_16 : int.
               (((<=) (0) j_16) /\
               (((<) j_16 (Uint32.to_int !i_9_0)) /\
               ((Int32.(<=) (select intP_intM_a_9_20 (shift a_9 j_16))
                (select intP_intM_a_9_20
                (select !int_xP_int_xM_min2_22 min2)))
               /\
               (Int32.(=) (select intP_intM_a_9_20 (shift a_9 j_16))
               (select intP_intM_a_9_20 (select !int_xP_int_xM_min1_21 min1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 34 25 73#
              (forall j_15 : int.
               ((((<=) (0) j_15) /\ ((<) j_15 (Uint32.to_int !i_9_0))) ->
                (Int32.(>=) (select intP_intM_a_9_20 (shift a_9 j_15))
                (select intP_intM_a_9_20
                (select !int_xP_int_xM_min1_21 min1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 33 25 41#
              (Int32.(<=)
              (select intP_intM_a_9_20 (select !int_xP_int_xM_min1_21 min1))
              (select intP_intM_a_9_20 (select !int_xP_int_xM_min2_22 min2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 32 25 74#
              (exists j_14 : int.
               (((<=) (0) j_14) /\
               (((<) j_14 (Uint32.to_int !i_9_0)) /\
               ((=) (shift a_9 j_14) (select !int_xP_int_xM_min2_22 min2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 31 25 74#
              (exists j_13 : int.
               (((<=) (0) j_13) /\
               (((<) j_13 (Uint32.to_int !i_9_0)) /\
               ((=) (shift a_9 j_13) (select !int_xP_int_xM_min1_21 min1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 38#
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 38#
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 30#
              ((<) (0) (Uint32.to_int !i_9_0)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 29 38#
             (Uint32.(<=) !i_9_0 size_7))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 40 17 25#
             (Unsafe_uint32.(<)  !i_9_0 size_7 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./min_min.c" 41 13 26#
              (Unsafe_int32.(<) 
               (acc  intP_intM_a_9_20
                (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) )
               (acc  intP_intM_a_9_20 (acc  !int_xP_int_xM_min1_21 min1 ) ) ))
              then
               begin
               (let _jessie_525 = (acc  !int_xP_int_xM_min1_21 min1 ) in
               (let _jessie_526 = min2 in
               (let _jessie_527 = (0) in
               (let _jessie_528 = _jessie_526 in
               (upd  int_xP_int_xM_min2_22 _jessie_528 _jessie_525 )))));
                (let _jessie_530 =
                (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) in
                (let _jessie_531 = min1 in
                (let _jessie_532 = (0) in
                (let _jessie_533 = _jessie_531 in
                (upd  int_xP_int_xM_min1_21 _jessie_533 _jessie_530 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 44 20 33#
               (Unsafe_int32.(<) 
                (acc  intP_intM_a_9_20
                 (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) )
                (acc  intP_intM_a_9_20 (acc  !int_xP_int_xM_min2_22 min2 ) )
                ))
               then
                (let _jessie_520 =
                (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) in
                (let _jessie_521 = min2 in
                (let _jessie_522 = (0) in
                (let _jessie_523 = _jessie_521 in
                (upd  int_xP_int_xM_min2_22 _jessie_523 _jessie_520 )))))
               else ()));
              (i_9_0 :=
               (Unsafe_uint32.(+)  !i_9_0
                (#"whole_program.jc" 1445 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_37 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_35 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
  let min_min_ensures_zero_size
  #"/home/work/workspace/education/acsl-exam/./min_min.c" 21 5 59#
  "expl:Function min_min, behavior zero_size" =
  fun
   (a_9 : (pointer voidP)) (size_7 : Uint32.t) (min1 : (pointer int_xP))
   (min2 : (pointer int_xP)) (int_xP_int_xM_min1_21 : ref (memory int_xP
   (pointer voidP))) (int_xP_int_xM_min2_22 : ref (memory int_xP (pointer
   voidP))) (int_xP_min1_21_alloc_table : (alloc_table int_xP))
   (int_xP_min2_22_alloc_table : (alloc_table int_xP))
   (voidP_a_9_20_alloc_table : (alloc_table voidP)) (voidP_a_9_20_tag_table :
   (tag_table voidP)) (intP_intM_a_9_20 : (memory voidP Int32.t)) 
   requires {
   (((=) (Uint32.to_int size_7) (0)) /\
   (((allocated voidP_a_9_20_alloc_table a_9) ->
     (((=) (typeof voidP_a_9_20_tag_table a_9) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_9_20_alloc_table a_9) i) /\
       ((<) i (offset_max voidP_a_9_20_alloc_table a_9))) ->
       ((=) (typeof voidP_a_9_20_tag_table (shift a_9 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_7) (1))) then
     (((<=) (offset_min voidP_a_9_20_alloc_table a_9) (0)) /\
     (((>=) (offset_max voidP_a_9_20_alloc_table a_9)
      (Int.(-) (Uint32.to_int size_7) (1)))
     /\
     (forall __framac_tmp20 : int.
      ((((<=) (0) __framac_tmp20) /\
       ((<=) __framac_tmp20 (Int.(-) (Uint32.to_int size_7) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 2 13 25#
    (#"whole_program.jc" 1291 12 1287#
    ((#"whole_program.jc" 1291 12 1287#
     ((<=) (offset_min int_xP_min1_21_alloc_table min1) (0)))
    /\
    (#"whole_program.jc" 1291 12 1287#
    ((#"whole_program.jc" 1291 12 1287#
     ((>=) (offset_max int_xP_min1_21_alloc_table min1) (0)))
    /\ (#"whole_program.jc" 1291 12 1287# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./min_min.c" 2 29 41#
   (#"whole_program.jc" 1291 12 1287#
   ((#"whole_program.jc" 1291 12 1287#
    ((<=) (offset_min int_xP_min2_22_alloc_table min2) (0)))
   /\
   (#"whole_program.jc" 1291 12 1287#
   ((#"whole_program.jc" 1291 12 1287#
    ((>=) (offset_max int_xP_min2_22_alloc_table min2) (0)))
   /\ (#"whole_program.jc" 1291 12 1287# ((=) true true))))))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"whole_program.jc" 1315 10 18# "expl:Assigns clause"
       (not_assigns int_xP_min1_21_alloc_table int_xP_min1_21_alloc_table
       (old !int_xP_int_xM_min1_21) !int_xP_int_xM_min1_21 pset_empty))
      /\
      (#"whole_program.jc" 1315 10 18# "expl:Assigns clause"
      (not_assigns int_xP_min2_22_alloc_table int_xP_min2_22_alloc_table (old
      !int_xP_int_xM_min2_22) !int_xP_int_xM_min2_22 pset_empty)))
     /\
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 6 15 33#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 6 15 33#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 6 15 33#
      "expl:Ensures clause" ((=) min1 min1))
     /\
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 7 15 33#
     "expl:Ensures clause" ((=) min2 min2))))))) } diverges  ->
   'Init:
   try
    begin
    (); ();
     (let i_9_0 = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./min_min.c" 24 7 15#
     (Unsafe_uint32.(>)  size_7
      (#"whole_program.jc" 1382 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_514 =
       (shift_  a_9
        (Unsafe_int32.to_int 
         (#"whole_program.jc" 1383 62 74# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_515 = min1 in
       (let _jessie_516 = (0) in
       (let _jessie_517 = _jessie_515 in
       (upd  int_xP_int_xM_min1_21 _jessie_517 _jessie_514 )))));
        begin
        (let _jessie_509 = (acc  !int_xP_int_xM_min1_21 min1 ) in
        (let _jessie_510 = min2 in
        (let _jessie_511 = (0) in
        (let _jessie_512 = _jessie_510 in
        (upd  int_xP_int_xM_min2_22 _jessie_512 _jessie_509 )))));
         begin
         (i_9_0 :=
          (#"whole_program.jc" 1385 26 39# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_24:
          loop
          invariant
            { (#"whole_program.jc" 1387 9 3372#
              ((#"whole_program.jc" 1315 10 18# "expl:Assigns clause"
               (not_assigns int_xP_min1_21_alloc_table
               int_xP_min1_21_alloc_table (at !int_xP_int_xM_min1_21 'Init)
               !int_xP_int_xM_min1_21 pset_empty))
              /\
              (#"whole_program.jc" 1315 10 18# "expl:Assigns clause"
              (not_assigns int_xP_min2_22_alloc_table
              int_xP_min2_22_alloc_table (at !int_xP_int_xM_min2_22 'Init)
              !int_xP_int_xM_min2_22 pset_empty)))) } 
           begin
           any unit
           requires { true } reads { a_9, int_xP_int_xM_min1_21,
           int_xP_int_xM_min2_22, min1, min2, size_7 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 36 25 135#
              (not
              (exists j_17 : int.
               (exists k_2 : int.
                (((<=) (0) j_17) /\
                (((<) j_17 (Uint32.to_int !i_9_0)) /\
                (((<=) (0) k_2) /\
                (((<) k_2 (Uint32.to_int !i_9_0)) /\
                (((<>) j_17 k_2) /\
                ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 j_17))
                 (select intP_intM_a_9_20
                 (select !int_xP_int_xM_min2_22 min2)))
                /\
                ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 k_2))
                 (select intP_intM_a_9_20
                 (select !int_xP_int_xM_min2_22 min2)))
                /\
                (Int32.(<) (select intP_intM_a_9_20 (shift a_9 k_2))
                (select intP_intM_a_9_20 (shift a_9 j_17))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 35 25 90#
              (exists j_16 : int.
               (((<=) (0) j_16) /\
               (((<) j_16 (Uint32.to_int !i_9_0)) /\
               ((Int32.(<=) (select intP_intM_a_9_20 (shift a_9 j_16))
                (select intP_intM_a_9_20
                (select !int_xP_int_xM_min2_22 min2)))
               /\
               (Int32.(=) (select intP_intM_a_9_20 (shift a_9 j_16))
               (select intP_intM_a_9_20 (select !int_xP_int_xM_min1_21 min1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 34 25 73#
              (forall j_15 : int.
               ((((<=) (0) j_15) /\ ((<) j_15 (Uint32.to_int !i_9_0))) ->
                (Int32.(>=) (select intP_intM_a_9_20 (shift a_9 j_15))
                (select intP_intM_a_9_20
                (select !int_xP_int_xM_min1_21 min1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 33 25 41#
              (Int32.(<=)
              (select intP_intM_a_9_20 (select !int_xP_int_xM_min1_21 min1))
              (select intP_intM_a_9_20 (select !int_xP_int_xM_min2_22 min2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 32 25 74#
              (exists j_14 : int.
               (((<=) (0) j_14) /\
               (((<) j_14 (Uint32.to_int !i_9_0)) /\
               ((=) (shift a_9 j_14) (select !int_xP_int_xM_min2_22 min2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 31 25 74#
              (exists j_13 : int.
               (((<=) (0) j_13) /\
               (((<) j_13 (Uint32.to_int !i_9_0)) /\
               ((=) (shift a_9 j_13) (select !int_xP_int_xM_min1_21 min1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 38#
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 38#
             ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 25 30#
              ((<) (0) (Uint32.to_int !i_9_0)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 30 29 38#
             (Uint32.(<=) !i_9_0 size_7))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./min_min.c" 40 17 25#
             (Unsafe_uint32.(<)  !i_9_0 size_7 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./min_min.c" 41 13 26#
              (Unsafe_int32.(<) 
               (acc  intP_intM_a_9_20
                (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) )
               (acc  intP_intM_a_9_20 (acc  !int_xP_int_xM_min1_21 min1 ) ) ))
              then
               begin
               (let _jessie_498 = (acc  !int_xP_int_xM_min1_21 min1 ) in
               (let _jessie_499 = min2 in
               (let _jessie_500 = (0) in
               (let _jessie_501 = _jessie_499 in
               (upd  int_xP_int_xM_min2_22 _jessie_501 _jessie_498 )))));
                (let _jessie_503 =
                (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) in
                (let _jessie_504 = min1 in
                (let _jessie_505 = (0) in
                (let _jessie_506 = _jessie_504 in
                (upd  int_xP_int_xM_min1_21 _jessie_506 _jessie_503 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 44 20 33#
               (Unsafe_int32.(<) 
                (acc  intP_intM_a_9_20
                 (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) )
                (acc  intP_intM_a_9_20 (acc  !int_xP_int_xM_min2_22 min2 ) )
                ))
               then
                (let _jessie_493 =
                (shift_  a_9 (Unsafe_uint32.to_int  !i_9_0 ) ) in
                (let _jessie_494 = min2 in
                (let _jessie_495 = (0) in
                (let _jessie_496 = _jessie_494 in
                (upd  int_xP_int_xM_min2_22 _jessie_496 _jessie_493 )))))
               else ()));
              (i_9_0 :=
               (Unsafe_uint32.(+)  !i_9_0
                (#"whole_program.jc" 1445 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_37 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_35 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
end

module Function_palindrome_safety

  use enum.Uint32 
  
  use import Struct_intP 
  
  use Safe_uint32 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let palindrome
  #"/home/work/workspace/education/acsl-exam/./palindrome.c" 18 4 38#
  "expl:Function palindrome, safety" =
  fun
   (a_10 : (pointer voidP)) (size_8 : Uint32.t) (voidP_a_10_23_alloc_table :
   (alloc_table voidP)) (voidP_a_10_23_tag_table : (tag_table voidP))
   (intP_intM_a_10_23 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_10_23_alloc_table a_10) ->
     (((=) (typeof voidP_a_10_23_tag_table a_10) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_10_23_alloc_table a_10) i) /\
       ((<) i (offset_max voidP_a_10_23_alloc_table a_10))) ->
       ((=) (typeof voidP_a_10_23_tag_table (shift a_10 i)) intP_tag)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 1 13 34#
   (if ((<=) (0) (Int.(-) (Uint32.to_int size_8) (1))) then
    (((<=) (offset_min voidP_a_10_23_alloc_table a_10) (0)) /\
    (((>=) (offset_max voidP_a_10_23_alloc_table a_10)
     (Int.(-) (Uint32.to_int size_8) (1)))
    /\
    (forall __framac_tmp23 : int.
     ((((<=) (0) __framac_tmp23) /\
      ((<=) __framac_tmp23 (Int.(-) (Uint32.to_int size_8) (1)))) ->
      ((=) true true))))) else ((=) true true)))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let res_0 = ref (Safe_int32.any_  () ) in
     (let i_10_2 = ref (Safe_uint32.any_  () ) in
     try
      begin
      (res_0 :=
       (let _jessie_595 =
       (#"whole_program.jc" 1545 25 37# "expl:Integer cast"
       (Safe_int32.of_int (1))) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 20 3 6#
       "expl:Pointer index bounds" true) }); _jessie_595 end));
       begin
       (i_10_2 :=
        (let _jessie_592 =
        (#"whole_program.jc" 1546 24 37# "expl:Integer cast"
        (Safe_uint32.of_int (0))) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 30 7 12#
        "expl:Pointer index bounds" true) }); _jessie_592 end));
        'Loop_31:
        loop
        invariant { (#"whole_program.jc" 1548 6 2005# true) }
          variant {
            (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 28 20 28#
            (Int.(-) (Uint32.to_int size_8) (Uint32.to_int !i_10_2))) }
         begin
         any unit
         requires { true } reads { a_10, size_8 }
         ensures {
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 26 22 42#
            ((Int32.(=) !res_0 (#"whole_program.jc" 1561 39 51#
             "expl:Integer cast" (Int32.of_int (0))))
            \/
            (Int32.(=) !res_0 (#"whole_program.jc" 1562 40 52#
            "expl:Integer cast" (Int32.of_int (1))))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 24 22 97#
            ((forall j_19 : int.
              ((((<=) (0) j_19) /\ ((<) j_19 (Uint32.to_int !i_10_2))) ->
               (Int32.(=) (select intP_intM_a_10_23 (shift a_10 j_19))
               (select intP_intM_a_10_23
               (shift a_10
               (Int.(-) (Int.(-) (Uint32.to_int size_8) j_19) (1)))))))
            <->
            (Int32.(=) !res_0 (#"whole_program.jc" 1559 40 52#
            "expl:Integer cast" (Int32.of_int (1))))))
           /\
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 40#
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 40#
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 28#
            ((<=) (0) (Uint32.to_int !i_10_2)))
           /\
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 27 40#
           ((<=) (Uint32.to_int !i_10_2)
           (ComputerDivision.div (Uint32.to_int size_8) (2))))))))) } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 30 14 26#
           (Safe_uint32.(<)  !i_10_2
            (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 30 18 26#
            "expl:Division by zero"
            (Safe_uint32.(/)  size_8
             (#"whole_program.jc" 1570 59 72# "expl:Integer cast"
             (Safe_uint32.of_int (2))) )) )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 31 10 33#
            (Safe_int32.(<>) 
             (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 31 10 14#
             "expl:Pointer dereference"
             (acc_offset_typesafe  voidP_a_10_23_alloc_table
              intP_intM_a_10_23 a_10 (Safe_uint32.to_int  !i_10_2 ) ))
             (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 31 18 33#
             "expl:Pointer dereference"
             (acc_offset_typesafe  voidP_a_10_23_alloc_table
              intP_intM_a_10_23 a_10
              (Safe_uint32.to_int 
               (Safe_uint32.(-)  (Safe_uint32.(-)  size_8 !i_10_2 )
                (#"whole_program.jc" 1580 66 79# "expl:Integer cast"
                (Safe_uint32.of_int (1))) ) ) )) ))
            then
             begin
             (res_0 :=
              (let _jessie_593 =
              (#"whole_program.jc" 1581 37 49# "expl:Integer cast"
              (Safe_int32.of_int (0))) in
              begin
              (assert {
              (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 32 9 16#
              "expl:Pointer index bounds" true) }); _jessie_593 end));
              (raise (Goto_while_0_break_exc ())) end else ());
            (i_10_2 :=
             (let _jessie_594 =
             (Safe_uint32.(+)  !i_10_2
              (#"whole_program.jc" 1586 59 72# "expl:Integer cast"
              (Safe_uint32.of_int (1))) ) in
             begin
             (assert {
             (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 30 28 31#
             "expl:Pointer index bounds" true) }); _jessie_594 end)) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_40 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end end with Goto_while_0_break_exc _jessie_38 ->
      'While_0_break:
      'While_0_break:
      begin
      ();
       begin
       (return :=
        (let _jessie_596 = !res_0 in
        begin
        (assert {
        (#"whole_program.jc" 1591 7 19# "expl:Pointer index bounds" true) });
         _jessie_596 end)); (raise Return) end end end)); absurd  end with
    Return -> !return end)
  
end

module Function_palindrome_behaviors

  use Unsafe_uint32 
  
  use Unsafe_int32 
  
  use enum.Uint32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let palindrome_ensures_default
  #"/home/work/workspace/education/acsl-exam/./palindrome.c" 18 4 38#
  "expl:Function palindrome, default behavior" =
  fun
   (a_10 : (pointer voidP)) (size_8 : Uint32.t) (voidP_a_10_23_alloc_table :
   (alloc_table voidP)) (voidP_a_10_23_tag_table : (tag_table voidP))
   (intP_intM_a_10_23 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a_10_23_alloc_table a_10) ->
     (((=) (typeof voidP_a_10_23_tag_table a_10) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_10_23_alloc_table a_10) i) /\
       ((<) i (offset_max voidP_a_10_23_alloc_table a_10))) ->
       ((=) (typeof voidP_a_10_23_tag_table (shift a_10 i)) intP_tag)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 1 13 34#
   (if ((<=) (0) (Int.(-) (Uint32.to_int size_8) (1))) then
    (((<=) (offset_min voidP_a_10_23_alloc_table a_10) (0)) /\
    (((>=) (offset_max voidP_a_10_23_alloc_table a_10)
     (Int.(-) (Uint32.to_int size_8) (1)))
    /\
    (forall __framac_tmp23 : int.
     ((((<=) (0) __framac_tmp23) /\
      ((<=) __framac_tmp23 (Int.(-) (Uint32.to_int size_8) (1)))) ->
      ((=) true true))))) else ((=) true true)))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 3 12 40#
     "expl:Ensures clause"
     ((Int32.(=) result (#"whole_program.jc" 1468 33 45# "expl:Integer cast"
      (Int32.of_int (0))))
     \/
     (Int32.(=) result (#"whole_program.jc" 1468 62 74# "expl:Integer cast"
     (Int32.of_int (1))))))) } diverges  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (check {
    (#"whole_program.jc" 1487 10 1046# "expl:Behavior disjointness check"
    (not
    (((>) (Uint32.to_int size_8) (0)) /\
    ((forall i_38_0 : int.
      ((((<=) (0) i_38_0) /\ ((<) i_38_0 (Uint32.to_int size_8))) ->
       (Int32.(=) (select intP_intM_a_10_23 (shift a_10 i_38_0))
       (select intP_intM_a_10_23
       (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_38_0) (1)))))))
    /\
    (((>) (Uint32.to_int size_8) (0)) /\
    (exists i_37_0 : int.
     (((<=) (0) i_37_0) /\
     (((<) i_37_0 (Uint32.to_int size_8)) /\
     (Int32.(<>) (select intP_intM_a_10_23 (shift a_10 i_37_0))
     (select intP_intM_a_10_23
     (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_37_0) (1)))))))))))))
    });
     (check {
     (#"whole_program.jc" 1504 10 593# "expl:Behavior disjointness check"
     (not
     (((=) (Uint32.to_int size_8) (0)) /\
     (((>) (Uint32.to_int size_8) (0)) /\
     (forall i_38_1 : int.
      ((((<=) (0) i_38_1) /\ ((<) i_38_1 (Uint32.to_int size_8))) ->
       (Int32.(=) (select intP_intM_a_10_23 (shift a_10 i_38_1))
       (select intP_intM_a_10_23
       (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_38_1) (1)))))))))))
     });
     (check {
     (#"whole_program.jc" 1514 10 592# "expl:Behavior disjointness check"
     (not
     (((=) (Uint32.to_int size_8) (0)) /\
     (((>) (Uint32.to_int size_8) (0)) /\
     (exists i_37_1 : int.
      (((<=) (0) i_37_1) /\
      (((<) i_37_1 (Uint32.to_int size_8)) /\
      (Int32.(<>) (select intP_intM_a_10_23 (shift a_10 i_37_1))
      (select intP_intM_a_10_23
      (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_37_1) (1))))))))))))
     });
     (check {
     (#"whole_program.jc" 1524 10 1027# "expl:Behavior completeness check"
     ((((>) (Uint32.to_int size_8) (0)) /\
      (exists i_37_2 : int.
       (((<=) (0) i_37_2) /\
       (((<) i_37_2 (Uint32.to_int size_8)) /\
       (Int32.(<>) (select intP_intM_a_10_23 (shift a_10 i_37_2))
       (select intP_intM_a_10_23
       (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_37_2) (1)))))))))
     \/
     ((((>) (Uint32.to_int size_8) (0)) /\
      (forall i_38_2 : int.
       ((((<=) (0) i_38_2) /\ ((<) i_38_2 (Uint32.to_int size_8))) ->
        (Int32.(=) (select intP_intM_a_10_23 (shift a_10 i_38_2))
        (select intP_intM_a_10_23
        (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_38_2) (1))))))))
     \/ ((=) (Uint32.to_int size_8) (0))))) });
     (let res_0 = ref (Unsafe_int32.any_  () ) in
     (let i_10_2 = ref (Unsafe_uint32.any_  () ) in
     try
      begin
      (res_0 :=
       (#"whole_program.jc" 1545 25 37# "expl:Integer cast"
       (Unsafe_int32.of_int (1))));
       begin
       (i_10_2 :=
        (#"whole_program.jc" 1546 24 37# "expl:Integer cast"
        (Unsafe_uint32.of_int (0))));
        'Loop_27:
        loop
        invariant
          { ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 40#
             (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 40#
             ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 28#
              ((<=) (0) (Uint32.to_int !i_10_2)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 27 40#
             ((<=) (Uint32.to_int !i_10_2)
             (ComputerDivision.div (Uint32.to_int size_8) (2)))))))
            &&
            ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 24 22 97#
             ((forall j_19 : int.
               ((((<=) (0) j_19) /\ ((<) j_19 (Uint32.to_int !i_10_2))) ->
                (Int32.(=) (select intP_intM_a_10_23 (shift a_10 j_19))
                (select intP_intM_a_10_23
                (shift a_10
                (Int.(-) (Int.(-) (Uint32.to_int size_8) j_19) (1)))))))
             <->
             (Int32.(=) !res_0 (#"whole_program.jc" 1559 40 52#
             "expl:Integer cast" (Int32.of_int (1))))))
            &&
            (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 26 22 42#
            ((Int32.(=) !res_0 (#"whole_program.jc" 1561 39 51#
             "expl:Integer cast" (Int32.of_int (0))))
            \/
            (Int32.(=) !res_0 (#"whole_program.jc" 1562 40 52#
            "expl:Integer cast" (Int32.of_int (1)))))))) } 
         begin
         any unit requires { true } ensures { true } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 30 14 26#
           (Unsafe_uint32.(<)  !i_10_2
            (Unsafe_uint32.(/)  size_8
             (#"whole_program.jc" 1570 59 72# "expl:Integer cast"
             (Unsafe_uint32.of_int (2))) ) )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 31 10 33#
            (Unsafe_int32.(<>) 
             (acc  intP_intM_a_10_23
              (shift_  a_10 (Unsafe_uint32.to_int  !i_10_2 ) ) )
             (acc  intP_intM_a_10_23
              (shift_  a_10
               (Unsafe_uint32.to_int 
                (Unsafe_uint32.(-)  (Unsafe_uint32.(-)  size_8 !i_10_2 )
                 (#"whole_program.jc" 1580 66 79# "expl:Integer cast"
                 (Unsafe_uint32.of_int (1))) ) ) ) ) ))
            then
             begin
             (res_0 :=
              (#"whole_program.jc" 1581 37 49# "expl:Integer cast"
              (Unsafe_int32.of_int (0))));
              (raise (Goto_while_0_break_exc ())) end else ());
            (i_10_2 :=
             (Unsafe_uint32.(+)  !i_10_2
              (#"whole_program.jc" 1586 59 72# "expl:Integer cast"
              (Unsafe_uint32.of_int (1))) )) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_40 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end end with Goto_while_0_break_exc _jessie_38 ->
      'While_0_break:
      'While_0_break:
      begin (); begin (return := !res_0); (raise Return) end end end));
     absurd  end with Return -> !return end)
  
  let palindrome_ensures_nil
  #"/home/work/workspace/education/acsl-exam/./palindrome.c" 18 4 38#
  "expl:Function palindrome, behavior nil" =
  fun
   (a_10 : (pointer voidP)) (size_8 : Uint32.t) (voidP_a_10_23_alloc_table :
   (alloc_table voidP)) (voidP_a_10_23_tag_table : (tag_table voidP))
   (intP_intM_a_10_23 : (memory voidP Int32.t)) 
   requires {
   (((=) (Uint32.to_int size_8) (0)) /\
   (((allocated voidP_a_10_23_alloc_table a_10) ->
     (((=) (typeof voidP_a_10_23_tag_table a_10) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_10_23_alloc_table a_10) i) /\
       ((<) i (offset_max voidP_a_10_23_alloc_table a_10))) ->
       ((=) (typeof voidP_a_10_23_tag_table (shift a_10 i)) intP_tag)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 1 13 34#
   (if ((<=) (0) (Int.(-) (Uint32.to_int size_8) (1))) then
    (((<=) (offset_min voidP_a_10_23_alloc_table a_10) (0)) /\
    (((>=) (offset_max voidP_a_10_23_alloc_table a_10)
     (Int.(-) (Uint32.to_int size_8) (1)))
    /\
    (forall __framac_tmp23 : int.
     ((((<=) (0) __framac_tmp23) /\
      ((<=) __framac_tmp23 (Int.(-) (Uint32.to_int size_8) (1)))) ->
      ((=) true true))))) else ((=) true true))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 6 15 27#
     "expl:Ensures clause"
     (Int32.(=) result (#"whole_program.jc" 1471 32 44# "expl:Integer cast"
     (Int32.of_int (1)))))) } diverges  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let res_0 = ref (Unsafe_int32.any_  () ) in
     (let i_10_2 = ref (Unsafe_uint32.any_  () ) in
     try
      begin
      (res_0 :=
       (#"whole_program.jc" 1545 25 37# "expl:Integer cast"
       (Unsafe_int32.of_int (1))));
       begin
       (i_10_2 :=
        (#"whole_program.jc" 1546 24 37# "expl:Integer cast"
        (Unsafe_uint32.of_int (0))));
        'Loop_28:
        loop
        invariant { (#"whole_program.jc" 1548 6 2005# true) } 
         begin
         any unit
         requires { true } reads { a_10, size_8 }
         ensures {
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 26 22 42#
            ((Int32.(=) !res_0 (#"whole_program.jc" 1561 39 51#
             "expl:Integer cast" (Int32.of_int (0))))
            \/
            (Int32.(=) !res_0 (#"whole_program.jc" 1562 40 52#
            "expl:Integer cast" (Int32.of_int (1))))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 24 22 97#
            ((forall j_19 : int.
              ((((<=) (0) j_19) /\ ((<) j_19 (Uint32.to_int !i_10_2))) ->
               (Int32.(=) (select intP_intM_a_10_23 (shift a_10 j_19))
               (select intP_intM_a_10_23
               (shift a_10
               (Int.(-) (Int.(-) (Uint32.to_int size_8) j_19) (1)))))))
            <->
            (Int32.(=) !res_0 (#"whole_program.jc" 1559 40 52#
            "expl:Integer cast" (Int32.of_int (1))))))
           /\
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 40#
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 40#
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 28#
            ((<=) (0) (Uint32.to_int !i_10_2)))
           /\
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 27 40#
           ((<=) (Uint32.to_int !i_10_2)
           (ComputerDivision.div (Uint32.to_int size_8) (2))))))))) } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 30 14 26#
           (Unsafe_uint32.(<)  !i_10_2
            (Unsafe_uint32.(/)  size_8
             (#"whole_program.jc" 1570 59 72# "expl:Integer cast"
             (Unsafe_uint32.of_int (2))) ) )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 31 10 33#
            (Unsafe_int32.(<>) 
             (acc  intP_intM_a_10_23
              (shift_  a_10 (Unsafe_uint32.to_int  !i_10_2 ) ) )
             (acc  intP_intM_a_10_23
              (shift_  a_10
               (Unsafe_uint32.to_int 
                (Unsafe_uint32.(-)  (Unsafe_uint32.(-)  size_8 !i_10_2 )
                 (#"whole_program.jc" 1580 66 79# "expl:Integer cast"
                 (Unsafe_uint32.of_int (1))) ) ) ) ) ))
            then
             begin
             (res_0 :=
              (#"whole_program.jc" 1581 37 49# "expl:Integer cast"
              (Unsafe_int32.of_int (0))));
              (raise (Goto_while_0_break_exc ())) end else ());
            (i_10_2 :=
             (Unsafe_uint32.(+)  !i_10_2
              (#"whole_program.jc" 1586 59 72# "expl:Integer cast"
              (Unsafe_uint32.of_int (1))) )) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_40 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end end with Goto_while_0_break_exc _jessie_38 ->
      'While_0_break:
      'While_0_break:
      begin (); begin (return := !res_0); (raise Return) end end end));
     absurd  end with Return -> !return end)
  
  let palindrome_ensures_non_palindrome
  #"/home/work/workspace/education/acsl-exam/./palindrome.c" 18 4 38#
  "expl:Function palindrome, behavior non_palindrome" =
  fun
   (a_10 : (pointer voidP)) (size_8 : Uint32.t) (voidP_a_10_23_alloc_table :
   (alloc_table voidP)) (voidP_a_10_23_tag_table : (tag_table voidP))
   (intP_intM_a_10_23 : (memory voidP Int32.t)) 
   requires {
   ((((>) (Uint32.to_int size_8) (0)) /\
    (exists i_37 : int.
     (((<=) (0) i_37) /\
     (((<) i_37 (Uint32.to_int size_8)) /\
     (Int32.(<>) (select intP_intM_a_10_23 (shift a_10 i_37))
     (select intP_intM_a_10_23
     (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_37) (1)))))))))
   /\
   (((allocated voidP_a_10_23_alloc_table a_10) ->
     (((=) (typeof voidP_a_10_23_tag_table a_10) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_10_23_alloc_table a_10) i) /\
       ((<) i (offset_max voidP_a_10_23_alloc_table a_10))) ->
       ((=) (typeof voidP_a_10_23_tag_table (shift a_10 i)) intP_tag)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 1 13 34#
   (if ((<=) (0) (Int.(-) (Uint32.to_int size_8) (1))) then
    (((<=) (offset_min voidP_a_10_23_alloc_table a_10) (0)) /\
    (((>=) (offset_max voidP_a_10_23_alloc_table a_10)
     (Int.(-) (Uint32.to_int size_8) (1)))
    /\
    (forall __framac_tmp23 : int.
     ((((<=) (0) __framac_tmp23) /\
      ((<=) __framac_tmp23 (Int.(-) (Uint32.to_int size_8) (1)))) ->
      ((=) true true))))) else ((=) true true))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 14 15 27#
     "expl:Ensures clause"
     (Int32.(=) result (#"whole_program.jc" 1485 32 44# "expl:Integer cast"
     (Int32.of_int (0)))))) } diverges  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let res_0 = ref (Unsafe_int32.any_  () ) in
     (let i_10_2 = ref (Unsafe_uint32.any_  () ) in
     try
      begin
      (res_0 :=
       (#"whole_program.jc" 1545 25 37# "expl:Integer cast"
       (Unsafe_int32.of_int (1))));
       begin
       (i_10_2 :=
        (#"whole_program.jc" 1546 24 37# "expl:Integer cast"
        (Unsafe_uint32.of_int (0))));
        'Loop_30:
        loop
        invariant { (#"whole_program.jc" 1548 6 2005# true) } 
         begin
         any unit
         requires { true } reads { a_10, size_8 }
         ensures {
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 26 22 42#
            ((Int32.(=) !res_0 (#"whole_program.jc" 1561 39 51#
             "expl:Integer cast" (Int32.of_int (0))))
            \/
            (Int32.(=) !res_0 (#"whole_program.jc" 1562 40 52#
            "expl:Integer cast" (Int32.of_int (1))))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 24 22 97#
            ((forall j_19 : int.
              ((((<=) (0) j_19) /\ ((<) j_19 (Uint32.to_int !i_10_2))) ->
               (Int32.(=) (select intP_intM_a_10_23 (shift a_10 j_19))
               (select intP_intM_a_10_23
               (shift a_10
               (Int.(-) (Int.(-) (Uint32.to_int size_8) j_19) (1)))))))
            <->
            (Int32.(=) !res_0 (#"whole_program.jc" 1559 40 52#
            "expl:Integer cast" (Int32.of_int (1))))))
           /\
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 40#
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 40#
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 28#
            ((<=) (0) (Uint32.to_int !i_10_2)))
           /\
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 27 40#
           ((<=) (Uint32.to_int !i_10_2)
           (ComputerDivision.div (Uint32.to_int size_8) (2))))))))) } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 30 14 26#
           (Unsafe_uint32.(<)  !i_10_2
            (Unsafe_uint32.(/)  size_8
             (#"whole_program.jc" 1570 59 72# "expl:Integer cast"
             (Unsafe_uint32.of_int (2))) ) )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 31 10 33#
            (Unsafe_int32.(<>) 
             (acc  intP_intM_a_10_23
              (shift_  a_10 (Unsafe_uint32.to_int  !i_10_2 ) ) )
             (acc  intP_intM_a_10_23
              (shift_  a_10
               (Unsafe_uint32.to_int 
                (Unsafe_uint32.(-)  (Unsafe_uint32.(-)  size_8 !i_10_2 )
                 (#"whole_program.jc" 1580 66 79# "expl:Integer cast"
                 (Unsafe_uint32.of_int (1))) ) ) ) ) ))
            then
             begin
             (res_0 :=
              (#"whole_program.jc" 1581 37 49# "expl:Integer cast"
              (Unsafe_int32.of_int (0))));
              (raise (Goto_while_0_break_exc ())) end else ());
            (i_10_2 :=
             (Unsafe_uint32.(+)  !i_10_2
              (#"whole_program.jc" 1586 59 72# "expl:Integer cast"
              (Unsafe_uint32.of_int (1))) )) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_40 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end end with Goto_while_0_break_exc _jessie_38 ->
      'While_0_break:
      'While_0_break:
      begin (); begin (return := !res_0); (raise Return) end end end));
     absurd  end with Return -> !return end)
  
  let palindrome_ensures_palindrome
  #"/home/work/workspace/education/acsl-exam/./palindrome.c" 18 4 38#
  "expl:Function palindrome, behavior palindrome" =
  fun
   (a_10 : (pointer voidP)) (size_8 : Uint32.t) (voidP_a_10_23_alloc_table :
   (alloc_table voidP)) (voidP_a_10_23_tag_table : (tag_table voidP))
   (intP_intM_a_10_23 : (memory voidP Int32.t)) 
   requires {
   ((((>) (Uint32.to_int size_8) (0)) /\
    (forall i_38 : int.
     ((((<=) (0) i_38) /\ ((<) i_38 (Uint32.to_int size_8))) ->
      (Int32.(=) (select intP_intM_a_10_23 (shift a_10 i_38))
      (select intP_intM_a_10_23
      (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_38) (1))))))))
   /\
   (((allocated voidP_a_10_23_alloc_table a_10) ->
     (((=) (typeof voidP_a_10_23_tag_table a_10) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_10_23_alloc_table a_10) i) /\
       ((<) i (offset_max voidP_a_10_23_alloc_table a_10))) ->
       ((=) (typeof voidP_a_10_23_tag_table (shift a_10 i)) intP_tag)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 1 13 34#
   (if ((<=) (0) (Int.(-) (Uint32.to_int size_8) (1))) then
    (((<=) (offset_min voidP_a_10_23_alloc_table a_10) (0)) /\
    (((>=) (offset_max voidP_a_10_23_alloc_table a_10)
     (Int.(-) (Uint32.to_int size_8) (1)))
    /\
    (forall __framac_tmp23 : int.
     ((((<=) (0) __framac_tmp23) /\
      ((<=) __framac_tmp23 (Int.(-) (Uint32.to_int size_8) (1)))) ->
      ((=) true true))))) else ((=) true true))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 10 15 27#
     "expl:Ensures clause"
     (Int32.(=) result (#"whole_program.jc" 1478 32 44# "expl:Integer cast"
     (Int32.of_int (1)))))) } diverges  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let res_0 = ref (Unsafe_int32.any_  () ) in
     (let i_10_2 = ref (Unsafe_uint32.any_  () ) in
     try
      begin
      (res_0 :=
       (#"whole_program.jc" 1545 25 37# "expl:Integer cast"
       (Unsafe_int32.of_int (1))));
       begin
       (i_10_2 :=
        (#"whole_program.jc" 1546 24 37# "expl:Integer cast"
        (Unsafe_uint32.of_int (0))));
        'Loop_29:
        loop
        invariant { (#"whole_program.jc" 1548 6 2005# true) } 
         begin
         any unit
         requires { true } reads { a_10, size_8 }
         ensures {
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 26 22 42#
            ((Int32.(=) !res_0 (#"whole_program.jc" 1561 39 51#
             "expl:Integer cast" (Int32.of_int (0))))
            \/
            (Int32.(=) !res_0 (#"whole_program.jc" 1562 40 52#
            "expl:Integer cast" (Int32.of_int (1))))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 24 22 97#
            ((forall j_19 : int.
              ((((<=) (0) j_19) /\ ((<) j_19 (Uint32.to_int !i_10_2))) ->
               (Int32.(=) (select intP_intM_a_10_23 (shift a_10 j_19))
               (select intP_intM_a_10_23
               (shift a_10
               (Int.(-) (Int.(-) (Uint32.to_int size_8) j_19) (1)))))))
            <->
            (Int32.(=) !res_0 (#"whole_program.jc" 1559 40 52#
            "expl:Integer cast" (Int32.of_int (1))))))
           /\
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 40#
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 40#
           ((#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 22 28#
            ((<=) (0) (Uint32.to_int !i_10_2)))
           /\
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 23 27 40#
           ((<=) (Uint32.to_int !i_10_2)
           (ComputerDivision.div (Uint32.to_int size_8) (2))))))))) } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 30 14 26#
           (Unsafe_uint32.(<)  !i_10_2
            (Unsafe_uint32.(/)  size_8
             (#"whole_program.jc" 1570 59 72# "expl:Integer cast"
             (Unsafe_uint32.of_int (2))) ) )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 31 10 33#
            (Unsafe_int32.(<>) 
             (acc  intP_intM_a_10_23
              (shift_  a_10 (Unsafe_uint32.to_int  !i_10_2 ) ) )
             (acc  intP_intM_a_10_23
              (shift_  a_10
               (Unsafe_uint32.to_int 
                (Unsafe_uint32.(-)  (Unsafe_uint32.(-)  size_8 !i_10_2 )
                 (#"whole_program.jc" 1580 66 79# "expl:Integer cast"
                 (Unsafe_uint32.of_int (1))) ) ) ) ) ))
            then
             begin
             (res_0 :=
              (#"whole_program.jc" 1581 37 49# "expl:Integer cast"
              (Unsafe_int32.of_int (0))));
              (raise (Goto_while_0_break_exc ())) end else ());
            (i_10_2 :=
             (Unsafe_uint32.(+)  !i_10_2
              (#"whole_program.jc" 1586 59 72# "expl:Integer cast"
              (Unsafe_uint32.of_int (1))) )) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_40 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end end with Goto_while_0_break_exc _jessie_38 ->
      'While_0_break:
      'While_0_break:
      begin (); begin (return := !res_0); (raise Return) end end end));
     absurd  end with Return -> !return end)
  
end

module Function_reverse_safety

  use import Struct_intP 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_offset_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let reverse #"/home/work/workspace/education/acsl-exam/./reverse.c" 8 5 42#
  "expl:Function reverse, safety" =
  fun
   (a_11 : (pointer voidP)) (res : (pointer voidP)) (size_9 : Int32.t)
   (intP_intM_res_25 : ref (memory voidP Int32.t)) (voidP_a_11_24_alloc_table
   : (alloc_table voidP)) (voidP_res_25_alloc_table : (alloc_table voidP))
   (voidP_res_25_tag_table : (tag_table voidP)) (voidP_a_11_24_tag_table :
   (tag_table voidP)) (intP_intM_a_11_24 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_res_25_alloc_table res) ->
     (((=) (typeof voidP_res_25_tag_table res) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_res_25_alloc_table res) i) /\
       ((<) i (offset_max voidP_res_25_alloc_table res))) ->
       ((=) (typeof voidP_res_25_tag_table (shift res i)) intP_tag)))))
   /\
   (((allocated voidP_a_11_24_alloc_table a_11) ->
     (((=) (typeof voidP_a_11_24_tag_table a_11) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_11_24_alloc_table a_11) i) /\
       ((<) i (offset_max voidP_a_11_24_alloc_table a_11))) ->
       ((=) (typeof voidP_a_11_24_tag_table (shift a_11 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1596 12 1392#
   ((#"/home/work/workspace/education/acsl-exam/./reverse.c" 2 13 22#
    (Int32.(>=) size_9 (#"whole_program.jc" 1596 33 45# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 1596 12 1392#
   ((#"/home/work/workspace/education/acsl-exam/./reverse.c" 3 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_9) (1))) then
     (((<=) (offset_min voidP_a_11_24_alloc_table a_11) (0)) /\
     (((>=) (offset_max voidP_a_11_24_alloc_table a_11)
      (Int.(-) (Int32.to_int size_9) (1)))
     /\
     (forall __framac_tmp24 : int.
      ((((<=) (0) __framac_tmp24) /\
       ((<=) __framac_tmp24 (Int.(-) (Int32.to_int size_9) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./reverse.c" 4 13 36#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_9) (1))) then
    (((<=) (offset_min voidP_res_25_alloc_table res) (0)) /\
    (((>=) (offset_max voidP_res_25_alloc_table res)
     (Int.(-) (Int32.to_int size_9) (1)))
    /\
    (forall __framac_tmp25 : int.
     ((((<=) (0) __framac_tmp25) /\
      ((<=) __framac_tmp25 (Int.(-) (Int32.to_int size_9) (1)))) ->
      ((=) true true))))) else ((=) true true))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let i_11_0 = ref (Safe_int32.any_  () ) in
    try
     begin
     (i_11_0 :=
      (let _jessie_604 =
      (Safe_int32.(-)  size_9
       (#"whole_program.jc" 1627 55 67# "expl:Integer cast"
       (Safe_int32.of_int (1))) ) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./reverse.c" 16 7 19#
      "expl:Pointer index bounds" true) }); _jessie_604 end));
      'Loop_33:
      loop
      invariant { (#"whole_program.jc" 1629 6 1698# true) }
        variant {
          (#"/home/work/workspace/education/acsl-exam/./reverse.c" 14 20 21#
          (Int32.to_int
          (#"/home/work/workspace/education/acsl-exam/./reverse.c" 14 20 21#
          !i_11_0))) }
       begin
       any unit
       requires { true } reads { a_11, intP_intM_res_25, res, size_9 }
       ensures {
         ((#"/home/work/workspace/education/acsl-exam/./reverse.c" 12 22 83#
          (forall j_20 : int.
           ((((<) (Int32.to_int !i_11_0) j_20) /\
            ((<) j_20 (Int32.to_int size_9))) ->
            (Int32.(=) (select !intP_intM_res_25 (shift res j_20))
            (select intP_intM_a_11_24
            (shift a_11 (Int.(-) (Int.(-) (Int32.to_int size_9) j_20) (1))))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./reverse.c" 11 22 36#
         (#"/home/work/workspace/education/acsl-exam/./reverse.c" 11 22 36#
         ((#"/home/work/workspace/education/acsl-exam/./reverse.c" 11 22 29#
          ((<=) (Int.(-_) (1)) (Int32.to_int !i_11_0)))
         /\
         (#"/home/work/workspace/education/acsl-exam/./reverse.c" 11 28 36#
         (Int32.(<) !i_11_0 size_9)))))) } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./reverse.c" 16 21 27#
         (Safe_int32.(>=)  !i_11_0
          (#"whole_program.jc" 1646 35 47# "expl:Integer cast"
          (Safe_int32.of_int (0))) )) then ()
         else (raise (Goto_while_0_break_exc ())));
          begin
          (let _jessie_606 =
          (let _jessie_605 =
          (#"/home/work/workspace/education/acsl-exam/./reverse.c" 17 15 30#
          "expl:Pointer dereference"
          (acc_offset_typesafe  voidP_a_11_24_alloc_table intP_intM_a_11_24
           a_11
           (Safe_int32.to_int 
            (Safe_int32.(-)  (Safe_int32.(-)  size_9 !i_11_0 )
             (#"whole_program.jc" 1657 68 80# "expl:Integer cast"
             (Safe_int32.of_int (1))) ) ) )) in
          begin
          (assert {
          (#"/home/work/workspace/education/acsl-exam/./reverse.c" 17 6 30#
          "expl:Pointer index bounds" true) }); _jessie_605 end) in
          (let _jessie_607 = res in
          (let _jessie_608 = (Safe_int32.to_int  !i_11_0 ) in
          (let _jessie_609 = (shift_typesafe  _jessie_607 _jessie_608 ) in
          (#"/home/work/workspace/education/acsl-exam/./reverse.c" 17 6 30#
          "expl:Pointer dereference"
          (upd_offset_typesafe  voidP_res_25_alloc_table intP_intM_res_25
           _jessie_607 _jessie_608 _jessie_606 ))))));
           (i_11_0 :=
            (let _jessie_610 =
            (Safe_int32.(-)  !i_11_0
             (#"whole_program.jc" 1658 59 71# "expl:Integer cast"
             (Safe_int32.of_int (1))) ) in
            begin
            (assert {
            (#"/home/work/workspace/education/acsl-exam/./reverse.c" 16 29 32#
            "expl:Pointer index bounds" true) }); _jessie_610 end)) end end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_43 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_41 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_reverse_behaviors

  use Unsafe_int32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let reverse_ensures_default
  #"/home/work/workspace/education/acsl-exam/./reverse.c" 8 5 42#
  "expl:Function reverse, default behavior" =
  fun
   (a_11 : (pointer voidP)) (res : (pointer voidP)) (size_9 : Int32.t)
   (intP_intM_res_25 : ref (memory voidP Int32.t)) (voidP_a_11_24_alloc_table
   : (alloc_table voidP)) (voidP_res_25_alloc_table : (alloc_table voidP))
   (voidP_res_25_tag_table : (tag_table voidP)) (voidP_a_11_24_tag_table :
   (tag_table voidP)) (intP_intM_a_11_24 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_res_25_alloc_table res) ->
     (((=) (typeof voidP_res_25_tag_table res) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_res_25_alloc_table res) i) /\
       ((<) i (offset_max voidP_res_25_alloc_table res))) ->
       ((=) (typeof voidP_res_25_tag_table (shift res i)) intP_tag)))))
   /\
   (((allocated voidP_a_11_24_alloc_table a_11) ->
     (((=) (typeof voidP_a_11_24_tag_table a_11) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_11_24_alloc_table a_11) i) /\
       ((<) i (offset_max voidP_a_11_24_alloc_table a_11))) ->
       ((=) (typeof voidP_a_11_24_tag_table (shift a_11 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1596 12 1392#
   ((#"/home/work/workspace/education/acsl-exam/./reverse.c" 2 13 22#
    (Int32.(>=) size_9 (#"whole_program.jc" 1596 33 45# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 1596 12 1392#
   ((#"/home/work/workspace/education/acsl-exam/./reverse.c" 3 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_9) (1))) then
     (((<=) (offset_min voidP_a_11_24_alloc_table a_11) (0)) /\
     (((>=) (offset_max voidP_a_11_24_alloc_table a_11)
      (Int.(-) (Int32.to_int size_9) (1)))
     /\
     (forall __framac_tmp24 : int.
      ((((<=) (0) __framac_tmp24) /\
       ((<=) __framac_tmp24 (Int.(-) (Int32.to_int size_9) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./reverse.c" 4 13 36#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_9) (1))) then
    (((<=) (offset_min voidP_res_25_alloc_table res) (0)) /\
    (((>=) (offset_max voidP_res_25_alloc_table res)
     (Int.(-) (Int32.to_int size_9) (1)))
    /\
    (forall __framac_tmp25 : int.
     ((((<=) (0) __framac_tmp25) /\
      ((<=) __framac_tmp25 (Int.(-) (Int32.to_int size_9) (1)))) ->
      ((=) true true))))) else ((=) true true))))))))) }
   ensures {
     ("expl:Postcondition"
     ((#"whole_program.jc" 1618 10 53# "expl:Assigns clause"
      (not_assigns voidP_res_25_alloc_table voidP_res_25_alloc_table (old
      !intP_intM_res_25) !intP_intM_res_25
      (pset_range (pset_singleton res) (0)
      (Int.(-) (Int32.to_int size_9) (1)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./reverse.c" 6 12 74#
     "expl:Ensures clause"
     (forall i_39 : int.
      ((((<=) (0) i_39) /\ ((<) i_39 (Int32.to_int size_9))) ->
       (Int32.(=) (select !intP_intM_res_25 (shift res i_39))
       (select intP_intM_a_11_24
       (shift a_11 (Int.(-) (Int.(-) (Int32.to_int size_9) i_39) (1))))))))))
     } diverges  ->
   'Init:
   try
    begin
    (let i_11_0 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (i_11_0 :=
      (Unsafe_int32.(-)  size_9
       (#"whole_program.jc" 1627 55 67# "expl:Integer cast"
       (Unsafe_int32.of_int (1))) ));
      'Loop_32:
      loop
      invariant
        { (((#"/home/work/workspace/education/acsl-exam/./reverse.c" 11 22 36#
            (#"/home/work/workspace/education/acsl-exam/./reverse.c" 11 22 36#
            ((#"/home/work/workspace/education/acsl-exam/./reverse.c" 11 22 29#
             ((<=) (Int.(-_) (1)) (Int32.to_int !i_11_0)))
            /\
            (#"/home/work/workspace/education/acsl-exam/./reverse.c" 11 28 36#
            (Int32.(<) !i_11_0 size_9)))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./reverse.c" 12 22 83#
           (forall j_20 : int.
            ((((<) (Int32.to_int !i_11_0) j_20) /\
             ((<) j_20 (Int32.to_int size_9))) ->
             (Int32.(=) (select !intP_intM_res_25 (shift res j_20))
             (select intP_intM_a_11_24
             (shift a_11 (Int.(-) (Int.(-) (Int32.to_int size_9) j_20) (1)))))))))
          /\
          ((#"whole_program.jc" 1629 6 1698# "expl:Assigns clause"
           (not_assigns voidP_res_25_alloc_table voidP_res_25_alloc_table (at
           !intP_intM_res_25 'Loop_32) !intP_intM_res_25
           (pset_range (pset_singleton res) (0)
           (Int.(-) (Int32.to_int size_9) (1)))))
          /\
          (#"whole_program.jc" 1618 10 53# "expl:Assigns clause"
          (not_assigns voidP_res_25_alloc_table voidP_res_25_alloc_table (at
          !intP_intM_res_25 'Init) !intP_intM_res_25
          (pset_range (pset_singleton res) (0)
          (Int.(-) (Int32.to_int size_9) (1))))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./reverse.c" 16 21 27#
         (Unsafe_int32.(>=)  !i_11_0
          (#"whole_program.jc" 1646 35 47# "expl:Integer cast"
          (Unsafe_int32.of_int (0))) )) then ()
         else (raise (Goto_while_0_break_exc ())));
          begin
          (let _jessie_599 =
          (acc  intP_intM_a_11_24
           (shift_  a_11
            (Unsafe_int32.to_int 
             (Unsafe_int32.(-)  (Unsafe_int32.(-)  size_9 !i_11_0 )
              (#"whole_program.jc" 1657 68 80# "expl:Integer cast"
              (Unsafe_int32.of_int (1))) ) ) ) ) in
          (let _jessie_600 = res in
          (let _jessie_601 = (Unsafe_int32.to_int  !i_11_0 ) in
          (let _jessie_602 = (shift_  _jessie_600 _jessie_601 ) in
          (upd  intP_intM_res_25 _jessie_602 _jessie_599 )))));
           (i_11_0 :=
            (Unsafe_int32.(-)  !i_11_0
             (#"whole_program.jc" 1658 59 71# "expl:Integer cast"
             (Unsafe_int32.of_int (1))) )) end end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_43 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_41 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

theory
Logic_reverse_struct_intP___attribute______wrapper_____x_integer_integer_integer

  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  predicate
  reverse_struct_intP___attribute______wrapper_____x_integer_integer_integer
  (a_7_0 : (pointer voidP)) (size : int) (i_40 : int) (j_21 : int)
  (intP_intM_a_7_27_at_L2 : (memory voidP Int32.t)) (intP_intM_a_7_27_at_L1 :
  (memory voidP Int32.t))
  =
     (forall k_3 : int.
      ((((<=) i_40 k_3) /\ ((<) k_3 j_21)) ->
       (Int32.(=) (select intP_intM_a_7_27_at_L1 (shift a_7_0 k_3))
       (select intP_intM_a_7_27_at_L2
       (shift a_7_0 (Int.(-) (Int.(-) size k_3) (1)))))))
  
end

module Function_swap_safe

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pset_union 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val swap
  (a_17 : (pointer voidP)) 
   (i_2 : Int32.t) 
    (j : Int32.t) 
     (intP_intM_a_17_26 : ref (memory voidP Int32.t)) 
      (voidP_a_17_26_alloc_table : (alloc_table voidP)) : unit
       requires {
         ("expl:External"
         (#"whole_program.jc" 1668 12 599# "expl:Requires clause"
         ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 1 13 26#
          "expl:Requires clause"
          (#"whole_program.jc" 1668 12 599# "expl:Requires clause"
          ((#"whole_program.jc" 1668 12 599# "expl:Requires clause"
           ((<=)
           (offset_min voidP_a_17_26_alloc_table
           (shift a_17 (Int32.to_int i_2))) (0)))
          /\
          (#"whole_program.jc" 1668 12 599# "expl:Requires clause"
          ((#"whole_program.jc" 1668 12 599# "expl:Requires clause"
           ((>=)
           (offset_max voidP_a_17_26_alloc_table
           (shift a_17 (Int32.to_int i_2))) (0)))
          /\
          (#"whole_program.jc" 1668 12 599# "expl:Requires clause"
          ((=) true true)))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 2 13 26#
         "expl:Requires clause"
         (#"whole_program.jc" 1668 12 599# "expl:Requires clause"
         ((#"whole_program.jc" 1668 12 599# "expl:Requires clause"
          ((<=)
          (offset_min voidP_a_17_26_alloc_table
          (shift a_17 (Int32.to_int j))) (0)))
         /\
         (#"whole_program.jc" 1668 12 599# "expl:Requires clause"
         ((#"whole_program.jc" 1668 12 599# "expl:Requires clause"
          ((>=)
          (offset_max voidP_a_17_26_alloc_table
          (shift a_17 (Int32.to_int j))) (0)))
         /\
         (#"whole_program.jc" 1668 12 599# "expl:Requires clause"
         ((=) true true)))))))))) }
       reads { intP_intM_a_17_26 } writes { intP_intM_a_17_26 }
       ensures {
         ((#"whole_program.jc" 1679 10 72# "expl:Assigns clause"
          (not_assigns voidP_a_17_26_alloc_table voidP_a_17_26_alloc_table
          (old !intP_intM_a_17_26) !intP_intM_a_17_26
          (pset_union (pset_singleton (shift a_17 (Int32.to_int i_2)))
          (pset_singleton (shift a_17 (Int32.to_int j))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 4 12 30#
         "expl:Ensures clause"
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 4 12 30#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 4 12 30#
          "expl:Ensures clause"
          (Int32.(=)
          (select !intP_intM_a_17_26 (shift a_17 (Int32.to_int i_2)))
          (select (old !intP_intM_a_17_26) (shift a_17 (Int32.to_int j)))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 5 12 30#
         "expl:Ensures clause"
         (Int32.(=) (select !intP_intM_a_17_26 (shift a_17 (Int32.to_int j)))
         (select (old !intP_intM_a_17_26) (shift a_17 (Int32.to_int i_2)))))))))
         }
  
end

module Function_reverse_in_place_safety

  use Safe_int32 
  
  use import ref.Ref 
  
  use import
  Logic_reverse_struct_intP___attribute______wrapper_____x_integer_integer_integer
  
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_swap_safe 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let reverse_in_place
  #"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 32 5 40#
  "expl:Function reverse_in_place, safety" =
  fun
   (a_12 : (pointer voidP)) (size_10 : Int32.t) (intP_intM_a_12_29 : ref
   (memory voidP Int32.t)) (voidP_a_12_29_alloc_table : (alloc_table voidP)) 
   requires {
   (#"whole_program.jc" 1698 12 709#
   ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 24 13 22#
    (Int32.(>=) size_10 (#"whole_program.jc" 1698 34 46# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 25 13 34#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_10) (1))) then
    (((<=) (offset_min voidP_a_12_29_alloc_table a_12) (0)) /\
    (((>=) (offset_max voidP_a_12_29_alloc_table a_12)
     (Int.(-) (Int32.to_int size_10) (1)))
    /\
    (forall __framac_tmp28 : int.
     ((((<=) (0) __framac_tmp28) /\
      ((<=) __framac_tmp28 (Int.(-) (Int32.to_int size_10) (1)))) ->
      ((=) true true))))) else ((=) true true))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let i_12_0 = ref (Safe_int32.any_  () ) in
    try
     begin
     (i_12_0 :=
      (let _jessie_616 =
      (#"whole_program.jc" 1725 24 36# "expl:Integer cast"
      (Safe_int32.of_int (0))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 42 7 12#
      "expl:Pointer index bounds" true) }); _jessie_616 end));
      'Loop_35:
      loop
      invariant { (#"whole_program.jc" 1727 6 1973# true) }
        variant {
          (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 40 20 32#
          (Int.(-) (ComputerDivision.div (Int32.to_int size_10) (2))
          (Int32.to_int !i_12_0))) }
       begin
       any unit
       requires { true } reads { a_12, intP_intM_a_12_29, size_10 }
       ensures {
         ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 38 22 64#
          (reverse_struct_intP___attribute______wrapper_____x_integer_integer_integer
          a_12 (Int32.to_int size_10)
          (Int.(-) (Int32.to_int size_10) (Int32.to_int !i_12_0))
          (Int32.to_int size_10) !intP_intM_a_12_29 (at !intP_intM_a_12_29
          'Init)))
         /\
         ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 37 22 94#
          (forall j_22 : int.
           ((((<=) (Int32.to_int !i_12_0) j_22) /\
            ((<) j_22
            (Int.(-) (Int32.to_int size_10) (Int32.to_int !i_12_0)))) ->
            (Int32.(=) (select !intP_intM_a_12_29 (shift a_12 j_22))
            (select (at !intP_intM_a_12_29 'Init) (shift a_12 j_22))))))
         /\
         ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 36 22 54#
          (reverse_struct_intP___attribute______wrapper_____x_integer_integer_integer
          a_12 (Int32.to_int size_10) (0) (Int32.to_int !i_12_0)
          !intP_intM_a_12_29 (at !intP_intM_a_12_29 'Init)))
         /\
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 35 22 40#
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 35 22 40#
         ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 35 22 28#
          (Int32.(<=) (#"whole_program.jc" 1729 40 52# "expl:Integer cast"
          (Int32.of_int (0))) !i_12_0))
         /\
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 35 27 40#
         ((<=) (Int32.to_int !i_12_0)
         (ComputerDivision.div (Int32.to_int size_10) (2)))))))))) } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 42 14 28#
         (Safe_int32.(<)  !i_12_0
          (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 42 19 27#
          "expl:Division by zero"
          (Safe_int32.(/)  size_10
           (#"whole_program.jc" 1755 60 72# "expl:Integer cast"
           (Safe_int32.of_int (2))) )) )) then ()
         else (raise (Goto_while_0_break_exc ())));
          begin
          (let _jessie_619 = a_12 in
          (let _jessie_618 = !i_12_0 in
          (let _jessie_617 =
          (Safe_int32.(-)  (Safe_int32.(-)  size_10 !i_12_0 )
           (#"whole_program.jc" 1761 50 62# "expl:Integer cast"
           (Safe_int32.of_int (1))) ) in
          (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 43 6 30#
          "expl:Precondition for swap"
          (Function_swap_safe.swap  _jessie_619 _jessie_618 _jessie_617
           intP_intM_a_12_29 voidP_a_12_29_alloc_table )))));
           (i_12_0 :=
            (let _jessie_620 =
            (Safe_int32.(+)  !i_12_0
             (#"whole_program.jc" 1762 59 71# "expl:Integer cast"
             (Safe_int32.of_int (1))) ) in
            begin
            (assert {
            (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 42 30 33#
            "expl:Pointer index bounds" true) }); _jessie_620 end)) end end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_46 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_44 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_swap

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pset_union 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val swap
  (a_17 : (pointer voidP)) 
   (i_2 : Int32.t) 
    (j : Int32.t) 
     (intP_intM_a_17_26 : ref (memory voidP Int32.t)) 
      (voidP_a_17_26_alloc_table : (alloc_table voidP)) : unit
       requires { true } reads { intP_intM_a_17_26 } writes {
       intP_intM_a_17_26 }
       ensures {
         ((#"whole_program.jc" 1679 10 72# "expl:Assigns clause"
          (not_assigns voidP_a_17_26_alloc_table voidP_a_17_26_alloc_table
          (old !intP_intM_a_17_26) !intP_intM_a_17_26
          (pset_union (pset_singleton (shift a_17 (Int32.to_int i_2)))
          (pset_singleton (shift a_17 (Int32.to_int j))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 4 12 30#
         "expl:Ensures clause"
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 4 12 30#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 4 12 30#
          "expl:Ensures clause"
          (Int32.(=)
          (select !intP_intM_a_17_26 (shift a_17 (Int32.to_int i_2)))
          (select (old !intP_intM_a_17_26) (shift a_17 (Int32.to_int j)))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 5 12 30#
         "expl:Ensures clause"
         (Int32.(=) (select !intP_intM_a_17_26 (shift a_17 (Int32.to_int j)))
         (select (old !intP_intM_a_17_26) (shift a_17 (Int32.to_int i_2)))))))))
         }
  
end

theory Logic_reverse_0

  use import
  Logic_reverse_struct_intP___attribute______wrapper_____x_integer_integer_integer
  
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  predicate reverse_0 (a_8_0 : (pointer voidP)) (size_0_0 : int)
  (intP_intM_a_8_28_at_L2 : (memory voidP Int32.t)) (intP_intM_a_8_28_at_L1 :
  (memory voidP Int32.t))
  =
     (reverse_struct_intP___attribute______wrapper_____x_integer_integer_integer
     a_8_0 size_0_0 (0) size_0_0 intP_intM_a_8_28_at_L2
     intP_intM_a_8_28_at_L1)
  
end

module Function_reverse_in_place_behaviors

  use Unsafe_int32 
  
  use import ref.Ref 
  
  use import
  Logic_reverse_struct_intP___attribute______wrapper_____x_integer_integer_integer
  
  
  use import Logic_reverse_0 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_swap 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let reverse_in_place_ensures_default
  #"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 32 5 40#
  "expl:Function reverse_in_place, default behavior" =
  fun
   (a_12 : (pointer voidP)) (size_10 : Int32.t) (intP_intM_a_12_29 : ref
   (memory voidP Int32.t)) (voidP_a_12_29_alloc_table : (alloc_table voidP)) 
   requires {
   (#"whole_program.jc" 1698 12 709#
   ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 24 13 22#
    (Int32.(>=) size_10 (#"whole_program.jc" 1698 34 46# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 25 13 34#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_10) (1))) then
    (((<=) (offset_min voidP_a_12_29_alloc_table a_12) (0)) /\
    (((>=) (offset_max voidP_a_12_29_alloc_table a_12)
     (Int.(-) (Int32.to_int size_10) (1)))
    /\
    (forall __framac_tmp28 : int.
     ((((<=) (0) __framac_tmp28) /\
      ((<=) __framac_tmp28 (Int.(-) (Int32.to_int size_10) (1)))) ->
      ((=) true true))))) else ((=) true true))))) }
   ensures {
     ("expl:Postcondition"
     ((#"whole_program.jc" 1710 10 55# "expl:Assigns clause"
      (not_assigns voidP_a_12_29_alloc_table voidP_a_12_29_alloc_table (old
      !intP_intM_a_12_29) !intP_intM_a_12_29
      (pset_range (pset_singleton a_12) (0)
      (Int.(-) (Int32.to_int size_10) (1)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 27 12 38#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 27 12 38#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 27 12 38#
      "expl:Ensures clause"
      (reverse_0 a_12 (Int32.to_int size_10) !intP_intM_a_12_29 (old
      !intP_intM_a_12_29)))
     /\
     (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 28 12 121#
     "expl:Ensures clause"
     (forall i_41 : int.
      ((((<=) (0) i_41) /\ ((<) i_41 (Int32.to_int size_10))) ->
       (exists j_23 : int.
        (((<=) (0) j_23) /\
        (((<) j_23 (Int32.to_int size_10)) /\
        (Int32.(=) (select !intP_intM_a_12_29 (shift a_12 i_41))
        (select !intP_intM_a_12_29 (shift a_12 j_23)))))))))))))) } diverges 
   ->
   'Init:
   try
    begin
    (let i_12_0 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (i_12_0 :=
      (#"whole_program.jc" 1725 24 36# "expl:Integer cast"
      (Unsafe_int32.of_int (0))));
      'Loop_34:
      loop
      invariant
        { (((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 35 22 40#
            (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 35 22 40#
            ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 35 22 28#
             (Int32.(<=) (#"whole_program.jc" 1729 40 52# "expl:Integer cast"
             (Int32.of_int (0))) !i_12_0))
            /\
            (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 35 27 40#
            ((<=) (Int32.to_int !i_12_0)
            (ComputerDivision.div (Int32.to_int size_10) (2)))))))
           &&
           ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 36 22 54#
            (reverse_struct_intP___attribute______wrapper_____x_integer_integer_integer
            a_12 (Int32.to_int size_10) (0) (Int32.to_int !i_12_0)
            !intP_intM_a_12_29 (at !intP_intM_a_12_29 'Init)))
           &&
           ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 37 22 94#
            (forall j_22 : int.
             ((((<=) (Int32.to_int !i_12_0) j_22) /\
              ((<) j_22
              (Int.(-) (Int32.to_int size_10) (Int32.to_int !i_12_0)))) ->
              (Int32.(=) (select !intP_intM_a_12_29 (shift a_12 j_22))
              (select (at !intP_intM_a_12_29 'Init) (shift a_12 j_22))))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 38 22 64#
           (reverse_struct_intP___attribute______wrapper_____x_integer_integer_integer
           a_12 (Int32.to_int size_10)
           (Int.(-) (Int32.to_int size_10) (Int32.to_int !i_12_0))
           (Int32.to_int size_10) !intP_intM_a_12_29 (at !intP_intM_a_12_29
           'Init))))))
          /\
          ((#"whole_program.jc" 1727 6 1973# "expl:Assigns clause"
           (not_assigns voidP_a_12_29_alloc_table voidP_a_12_29_alloc_table
           (at !intP_intM_a_12_29 'Loop_34) !intP_intM_a_12_29
           (pset_range (pset_singleton a_12) (0)
           (Int.(-) (Int32.to_int size_10) (1)))))
          /\
          (#"whole_program.jc" 1710 10 55# "expl:Assigns clause"
          (not_assigns voidP_a_12_29_alloc_table voidP_a_12_29_alloc_table
          (at !intP_intM_a_12_29 'Init) !intP_intM_a_12_29
          (pset_range (pset_singleton a_12) (0)
          (Int.(-) (Int32.to_int size_10) (1))))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 42 14 28#
         (Unsafe_int32.(<)  !i_12_0
          (Unsafe_int32.(/)  size_10
           (#"whole_program.jc" 1755 60 72# "expl:Integer cast"
           (Unsafe_int32.of_int (2))) ) )) then ()
         else (raise (Goto_while_0_break_exc ())));
          begin
          (let _jessie_614 = a_12 in
          (let _jessie_613 = !i_12_0 in
          (let _jessie_612 =
          (Unsafe_int32.(-)  (Unsafe_int32.(-)  size_10 !i_12_0 )
           (#"whole_program.jc" 1761 50 62# "expl:Integer cast"
           (Unsafe_int32.of_int (1))) ) in
          (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 43 6 30#
          "expl:Precondition for swap"
          (Function_swap.swap  _jessie_614 _jessie_613 _jessie_612
           intP_intM_a_12_29 voidP_a_12_29_alloc_table )))));
           (i_12_0 :=
            (Unsafe_int32.(+)  !i_12_0
             (#"whole_program.jc" 1762 59 71# "expl:Integer cast"
             (Unsafe_int32.of_int (1))) )) end end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_46 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_44 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_set_even_safety

  use import Struct_intP 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_offset_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let set_even
  #"/home/work/workspace/education/acsl-exam/./set_even.c" 7 5 40#
  "expl:Function set_even, safety" =
  fun
   (p_0 : (pointer voidP)) (size_11 : Int32.t) (val_1 : Int32.t)
   (intP_intM_p_30 : ref (memory voidP Int32.t)) (voidP_p_30_alloc_table :
   (alloc_table voidP)) (voidP_p_30_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_p_30_alloc_table p_0) ->
     (((=) (typeof voidP_p_30_tag_table p_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_p_30_alloc_table p_0) i) /\
       ((<) i (offset_max voidP_p_30_alloc_table p_0))) ->
       ((=) (typeof voidP_p_30_tag_table (shift p_0 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1772 12 703#
   ((#"/home/work/workspace/education/acsl-exam/./set_even.c" 1 13 22#
    (Int32.(>=) size_11 (#"whole_program.jc" 1772 34 46# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./set_even.c" 2 13 34#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_11) (1))) then
    (((<=) (offset_min voidP_p_30_alloc_table p_0) (0)) /\
    (((>=) (offset_max voidP_p_30_alloc_table p_0)
     (Int.(-) (Int32.to_int size_11) (1)))
    /\
    (forall __framac_tmp29 : int.
     ((((<=) (0) __framac_tmp29) /\
      ((<=) __framac_tmp29 (Int.(-) (Int32.to_int size_11) (1)))) ->
      ((=) true true))))) else ((=) true true)))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let i_13_0 = ref (Safe_int32.any_  () ) in
    try
     begin
     (i_13_0 :=
      (let _jessie_628 =
      (#"whole_program.jc" 1800 24 36# "expl:Integer cast"
      (Safe_int32.of_int (0))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./set_even.c" 17 7 12#
      "expl:Pointer index bounds" true) }); _jessie_628 end));
      'Loop_37:
      loop
      invariant { (#"whole_program.jc" 1802 6 1598# true) }
        variant {
          (#"/home/work/workspace/education/acsl-exam/./set_even.c" 15 20 28#
          (Int.(-) (Int32.to_int size_11) (Int32.to_int !i_13_0))) }
       begin
       any unit
       requires { true } reads { intP_intM_p_30, p_0, size_11, val_1 }
       ensures {
         ((#"/home/work/workspace/education/acsl-exam/./set_even.c" 12 22 112#
          (forall j_25 : int.
           ((((<=) (0) j_25) /\
            (((<) j_25 (Int32.to_int !i_13_0)) /\
            ((<>) (ComputerDivision.mod j_25 (2)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_30 (shift p_0 j_25))
            (select (at !intP_intM_p_30 'Init) (shift p_0 j_25))))))
         /\
         ((#"/home/work/workspace/education/acsl-exam/./set_even.c" 11 22 81#
          (forall j_24 : int.
           ((((<=) (0) j_24) /\
            (((<) j_24 (Int32.to_int !i_13_0)) /\
            ((=) (ComputerDivision.mod j_24 (2)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_30 (shift p_0 j_24)) val_1))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_even.c" 10 22 36#
         (#"/home/work/workspace/education/acsl-exam/./set_even.c" 10 22 36#
         ((#"/home/work/workspace/education/acsl-exam/./set_even.c" 10 22 28#
          (Int32.(<=) (#"whole_program.jc" 1804 40 52# "expl:Integer cast"
          (Int32.of_int (0))) !i_13_0))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_even.c" 10 27 36#
         (Int32.(<=) !i_13_0 size_11))))))) } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./set_even.c" 17 14 22#
         (Safe_int32.(<)  !i_13_0 size_11 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          (if
          (#"/home/work/workspace/education/acsl-exam/./set_even.c" 18 10 20#
          (Safe_int32.(=) 
           (#"/home/work/workspace/education/acsl-exam/./set_even.c" 18 10 15#
           "expl:Division by zero"
           (Safe_int32.(%)  !i_13_0
            (#"whole_program.jc" 1827 59 71# "expl:Integer cast"
            (Safe_int32.of_int (2))) ))
           (#"whole_program.jc" 1828 31 43# "expl:Integer cast"
           (Safe_int32.of_int (0))) ))
          then
           (let _jessie_630 =
           (let _jessie_629 = val_1 in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./set_even.c" 19 9 19#
           "expl:Pointer index bounds" true) }); _jessie_629 end) in
           (let _jessie_631 = p_0 in
           (let _jessie_632 = (Safe_int32.to_int  !i_13_0 ) in
           (let _jessie_633 = (shift_typesafe  _jessie_631 _jessie_632 ) in
           (#"/home/work/workspace/education/acsl-exam/./set_even.c" 19 9 19#
           "expl:Pointer dereference"
           (upd_offset_typesafe  voidP_p_30_alloc_table intP_intM_p_30
            _jessie_631 _jessie_632 _jessie_630 )))))) else ());
          (i_13_0 :=
           (let _jessie_634 =
           (Safe_int32.(+)  !i_13_0
            (#"whole_program.jc" 1833 59 71# "expl:Integer cast"
            (Safe_int32.of_int (1))) ) in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./set_even.c" 17 24 27#
           "expl:Pointer index bounds" true) }); _jessie_634 end)) end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_49 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_47 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_set_even_behaviors

  use Unsafe_int32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let set_even_ensures_default
  #"/home/work/workspace/education/acsl-exam/./set_even.c" 7 5 40#
  "expl:Function set_even, default behavior" =
  fun
   (p_0 : (pointer voidP)) (size_11 : Int32.t) (val_1 : Int32.t)
   (intP_intM_p_30 : ref (memory voidP Int32.t)) (voidP_p_30_alloc_table :
   (alloc_table voidP)) (voidP_p_30_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_p_30_alloc_table p_0) ->
     (((=) (typeof voidP_p_30_tag_table p_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_p_30_alloc_table p_0) i) /\
       ((<) i (offset_max voidP_p_30_alloc_table p_0))) ->
       ((=) (typeof voidP_p_30_tag_table (shift p_0 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1772 12 703#
   ((#"/home/work/workspace/education/acsl-exam/./set_even.c" 1 13 22#
    (Int32.(>=) size_11 (#"whole_program.jc" 1772 34 46# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./set_even.c" 2 13 34#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_11) (1))) then
    (((<=) (offset_min voidP_p_30_alloc_table p_0) (0)) /\
    (((>=) (offset_max voidP_p_30_alloc_table p_0)
     (Int.(-) (Int32.to_int size_11) (1)))
    /\
    (forall __framac_tmp29 : int.
     ((((<=) (0) __framac_tmp29) /\
      ((<=) __framac_tmp29 (Int.(-) (Int32.to_int size_11) (1)))) ->
      ((=) true true))))) else ((=) true true)))))) }
   ensures {
     ("expl:Postcondition"
     ((#"whole_program.jc" 1784 10 52# "expl:Assigns clause"
      (not_assigns voidP_p_30_alloc_table voidP_p_30_alloc_table (old
      !intP_intM_p_30) !intP_intM_p_30
      (pset_range (pset_singleton p_0) (0)
      (Int.(-) (Int32.to_int size_11) (1)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./set_even.c" 4 12 74#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./set_even.c" 4 12 74#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./set_even.c" 4 12 74#
      "expl:Ensures clause"
      (forall j_26 : int.
       ((((<=) (0) j_26) /\
        (((<) j_26 (Int32.to_int size_11)) /\
        ((=) (ComputerDivision.mod j_26 (2)) (0)))) ->
        (Int32.(=) (select !intP_intM_p_30 (shift p_0 j_26)) val_1))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./set_even.c" 5 12 81#
     "expl:Ensures clause"
     (forall j_27 : int.
      ((((<=) (0) j_27) /\
       (((<) j_27 (Int32.to_int size_11)) /\
       ((<>) (ComputerDivision.mod j_27 (2)) (0)))) ->
       (Int32.(=) (select !intP_intM_p_30 (shift p_0 j_27))
       (select (old !intP_intM_p_30) (shift p_0 j_27))))))))))) } diverges 
   ->
   'Init:
   try
    begin
    (let i_13_0 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (i_13_0 :=
      (#"whole_program.jc" 1800 24 36# "expl:Integer cast"
      (Unsafe_int32.of_int (0))));
      'Loop_36:
      loop
      invariant
        { (((#"/home/work/workspace/education/acsl-exam/./set_even.c" 10 22 36#
            (#"/home/work/workspace/education/acsl-exam/./set_even.c" 10 22 36#
            ((#"/home/work/workspace/education/acsl-exam/./set_even.c" 10 22 28#
             (Int32.(<=) (#"whole_program.jc" 1804 40 52# "expl:Integer cast"
             (Int32.of_int (0))) !i_13_0))
            /\
            (#"/home/work/workspace/education/acsl-exam/./set_even.c" 10 27 36#
            (Int32.(<=) !i_13_0 size_11)))))
           &&
           ((#"/home/work/workspace/education/acsl-exam/./set_even.c" 11 22 81#
            (forall j_24 : int.
             ((((<=) (0) j_24) /\
              (((<) j_24 (Int32.to_int !i_13_0)) /\
              ((=) (ComputerDivision.mod j_24 (2)) (0)))) ->
              (Int32.(=) (select !intP_intM_p_30 (shift p_0 j_24)) val_1))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./set_even.c" 12 22 112#
           (forall j_25 : int.
            ((((<=) (0) j_25) /\
             (((<) j_25 (Int32.to_int !i_13_0)) /\
             ((<>) (ComputerDivision.mod j_25 (2)) (0)))) ->
             (Int32.(=) (select !intP_intM_p_30 (shift p_0 j_25))
             (select (at !intP_intM_p_30 'Init) (shift p_0 j_25))))))))
          /\
          ((#"whole_program.jc" 1802 6 1598# "expl:Assigns clause"
           (not_assigns voidP_p_30_alloc_table voidP_p_30_alloc_table (at
           !intP_intM_p_30 'Loop_36) !intP_intM_p_30
           (pset_range (pset_singleton p_0) (0)
           (Int.(-) (Int32.to_int !i_13_0) (1)))))
          /\
          (#"whole_program.jc" 1784 10 52# "expl:Assigns clause"
          (not_assigns voidP_p_30_alloc_table voidP_p_30_alloc_table (at
          !intP_intM_p_30 'Init) !intP_intM_p_30
          (pset_range (pset_singleton p_0) (0)
          (Int.(-) (Int32.to_int size_11) (1))))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./set_even.c" 17 14 22#
         (Unsafe_int32.(<)  !i_13_0 size_11 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          (if
          (#"/home/work/workspace/education/acsl-exam/./set_even.c" 18 10 20#
          (Unsafe_int32.(=) 
           (Unsafe_int32.(%)  !i_13_0
            (#"whole_program.jc" 1827 59 71# "expl:Integer cast"
            (Unsafe_int32.of_int (2))) )
           (#"whole_program.jc" 1828 31 43# "expl:Integer cast"
           (Unsafe_int32.of_int (0))) ))
          then
           (let _jessie_623 = val_1 in
           (let _jessie_624 = p_0 in
           (let _jessie_625 = (Unsafe_int32.to_int  !i_13_0 ) in
           (let _jessie_626 = (shift_  _jessie_624 _jessie_625 ) in
           (upd  intP_intM_p_30 _jessie_626 _jessie_623 ))))) else ());
          (i_13_0 :=
           (Unsafe_int32.(+)  !i_13_0
            (#"whole_program.jc" 1833 59 71# "expl:Integer cast"
            (Unsafe_int32.of_int (1))) )) end; (raise (Loop_continue_exc ()))
         end with Loop_continue_exc _jessie_49 -> () end end end;
      (raise (Goto_while_0_break_exc ())) end with Goto_while_0_break_exc
     _jessie_47 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_set_odd_safety

  use import Struct_intP 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_offset_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let set_odd #"/home/work/workspace/education/acsl-exam/./set_odd.c" 7 5 39#
  "expl:Function set_odd, safety" =
  fun
   (p_0_0 : (pointer voidP)) (size_12 : Int32.t) (val_2 : Int32.t)
   (intP_intM_p_0_31 : ref (memory voidP Int32.t)) (voidP_p_0_31_alloc_table
   : (alloc_table voidP)) (voidP_p_0_31_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_p_0_31_alloc_table p_0_0) ->
     (((=) (typeof voidP_p_0_31_tag_table p_0_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_p_0_31_alloc_table p_0_0) i) /\
       ((<) i (offset_max voidP_p_0_31_alloc_table p_0_0))) ->
       ((=) (typeof voidP_p_0_31_tag_table (shift p_0_0 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1843 12 707#
   ((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 1 13 22#
    (Int32.(>=) size_12 (#"whole_program.jc" 1843 34 46# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 2 13 34#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_12) (1))) then
    (((<=) (offset_min voidP_p_0_31_alloc_table p_0_0) (0)) /\
    (((>=) (offset_max voidP_p_0_31_alloc_table p_0_0)
     (Int.(-) (Int32.to_int size_12) (1)))
    /\
    (forall __framac_tmp30 : int.
     ((((<=) (0) __framac_tmp30) /\
      ((<=) __framac_tmp30 (Int.(-) (Int32.to_int size_12) (1)))) ->
      ((=) true true))))) else ((=) true true)))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let i_14_0 = ref (Safe_int32.any_  () ) in
    try
     begin
     (i_14_0 :=
      (let _jessie_642 =
      (#"whole_program.jc" 1871 24 36# "expl:Integer cast"
      (Safe_int32.of_int (0))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 17 7 12#
      "expl:Pointer index bounds" true) }); _jessie_642 end));
      'Loop_39:
      loop
      invariant { (#"whole_program.jc" 1873 6 1608# true) }
        variant {
          (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 15 20 28#
          (Int.(-) (Int32.to_int size_12) (Int32.to_int !i_14_0))) }
       begin
       any unit
       requires { true } reads { intP_intM_p_0_31, p_0_0, size_12, val_2 }
       ensures {
         ((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 12 22 112#
          (forall j_29 : int.
           ((((<=) (0) j_29) /\
            (((<) j_29 (Int32.to_int !i_14_0)) /\
            ((=) (ComputerDivision.mod j_29 (2)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_0_31 (shift p_0_0 j_29))
            (select (at !intP_intM_p_0_31 'Init) (shift p_0_0 j_29))))))
         /\
         ((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 11 22 81#
          (forall j_28 : int.
           ((((<=) (0) j_28) /\
            (((<) j_28 (Int32.to_int !i_14_0)) /\
            ((<>) (ComputerDivision.mod j_28 (2)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_0_31 (shift p_0_0 j_28)) val_2))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 10 22 36#
         (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 10 22 36#
         ((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 10 22 28#
          (Int32.(<=) (#"whole_program.jc" 1875 40 52# "expl:Integer cast"
          (Int32.of_int (0))) !i_14_0))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 10 27 36#
         (Int32.(<=) !i_14_0 size_12))))))) } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 17 14 22#
         (Safe_int32.(<)  !i_14_0 size_12 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          (if
          (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 18 10 20#
          (Safe_int32.(<>) 
           (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 18 10 15#
           "expl:Division by zero"
           (Safe_int32.(%)  !i_14_0
            (#"whole_program.jc" 1898 59 71# "expl:Integer cast"
            (Safe_int32.of_int (2))) ))
           (#"whole_program.jc" 1899 31 43# "expl:Integer cast"
           (Safe_int32.of_int (0))) ))
          then
           (let _jessie_644 =
           (let _jessie_643 = val_2 in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 19 9 19#
           "expl:Pointer index bounds" true) }); _jessie_643 end) in
           (let _jessie_645 = p_0_0 in
           (let _jessie_646 = (Safe_int32.to_int  !i_14_0 ) in
           (let _jessie_647 = (shift_typesafe  _jessie_645 _jessie_646 ) in
           (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 19 9 19#
           "expl:Pointer dereference"
           (upd_offset_typesafe  voidP_p_0_31_alloc_table intP_intM_p_0_31
            _jessie_645 _jessie_646 _jessie_644 )))))) else ());
          (i_14_0 :=
           (let _jessie_648 =
           (Safe_int32.(+)  !i_14_0
            (#"whole_program.jc" 1904 59 71# "expl:Integer cast"
            (Safe_int32.of_int (1))) ) in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 17 24 27#
           "expl:Pointer index bounds" true) }); _jessie_648 end)) end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_52 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_50 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_set_odd_behaviors

  use Unsafe_int32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let set_odd_ensures_default
  #"/home/work/workspace/education/acsl-exam/./set_odd.c" 7 5 39#
  "expl:Function set_odd, default behavior" =
  fun
   (p_0_0 : (pointer voidP)) (size_12 : Int32.t) (val_2 : Int32.t)
   (intP_intM_p_0_31 : ref (memory voidP Int32.t)) (voidP_p_0_31_alloc_table
   : (alloc_table voidP)) (voidP_p_0_31_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_p_0_31_alloc_table p_0_0) ->
     (((=) (typeof voidP_p_0_31_tag_table p_0_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_p_0_31_alloc_table p_0_0) i) /\
       ((<) i (offset_max voidP_p_0_31_alloc_table p_0_0))) ->
       ((=) (typeof voidP_p_0_31_tag_table (shift p_0_0 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 1843 12 707#
   ((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 1 13 22#
    (Int32.(>=) size_12 (#"whole_program.jc" 1843 34 46# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 2 13 34#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_12) (1))) then
    (((<=) (offset_min voidP_p_0_31_alloc_table p_0_0) (0)) /\
    (((>=) (offset_max voidP_p_0_31_alloc_table p_0_0)
     (Int.(-) (Int32.to_int size_12) (1)))
    /\
    (forall __framac_tmp30 : int.
     ((((<=) (0) __framac_tmp30) /\
      ((<=) __framac_tmp30 (Int.(-) (Int32.to_int size_12) (1)))) ->
      ((=) true true))))) else ((=) true true)))))) }
   ensures {
     ("expl:Postcondition"
     ((#"whole_program.jc" 1855 10 54# "expl:Assigns clause"
      (not_assigns voidP_p_0_31_alloc_table voidP_p_0_31_alloc_table (old
      !intP_intM_p_0_31) !intP_intM_p_0_31
      (pset_range (pset_singleton p_0_0) (0)
      (Int.(-) (Int32.to_int size_12) (1)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 4 12 74#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 4 12 74#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 4 12 74#
      "expl:Ensures clause"
      (forall j_30 : int.
       ((((<=) (0) j_30) /\
        (((<) j_30 (Int32.to_int size_12)) /\
        ((<>) (ComputerDivision.mod j_30 (2)) (0)))) ->
        (Int32.(=) (select !intP_intM_p_0_31 (shift p_0_0 j_30)) val_2))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 5 12 81#
     "expl:Ensures clause"
     (forall j_31 : int.
      ((((<=) (0) j_31) /\
       (((<) j_31 (Int32.to_int size_12)) /\
       ((=) (ComputerDivision.mod j_31 (2)) (0)))) ->
       (Int32.(=) (select !intP_intM_p_0_31 (shift p_0_0 j_31))
       (select (old !intP_intM_p_0_31) (shift p_0_0 j_31))))))))))) }
   diverges  ->
   'Init:
   try
    begin
    (let i_14_0 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (i_14_0 :=
      (#"whole_program.jc" 1871 24 36# "expl:Integer cast"
      (Unsafe_int32.of_int (0))));
      'Loop_38:
      loop
      invariant
        { (((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 10 22 36#
            (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 10 22 36#
            ((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 10 22 28#
             (Int32.(<=) (#"whole_program.jc" 1875 40 52# "expl:Integer cast"
             (Int32.of_int (0))) !i_14_0))
            /\
            (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 10 27 36#
            (Int32.(<=) !i_14_0 size_12)))))
           &&
           ((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 11 22 81#
            (forall j_28 : int.
             ((((<=) (0) j_28) /\
              (((<) j_28 (Int32.to_int !i_14_0)) /\
              ((<>) (ComputerDivision.mod j_28 (2)) (0)))) ->
              (Int32.(=) (select !intP_intM_p_0_31 (shift p_0_0 j_28)) val_2))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 12 22 112#
           (forall j_29 : int.
            ((((<=) (0) j_29) /\
             (((<) j_29 (Int32.to_int !i_14_0)) /\
             ((=) (ComputerDivision.mod j_29 (2)) (0)))) ->
             (Int32.(=) (select !intP_intM_p_0_31 (shift p_0_0 j_29))
             (select (at !intP_intM_p_0_31 'Init) (shift p_0_0 j_29))))))))
          /\
          ((#"whole_program.jc" 1873 6 1608# "expl:Assigns clause"
           (not_assigns voidP_p_0_31_alloc_table voidP_p_0_31_alloc_table (at
           !intP_intM_p_0_31 'Loop_38) !intP_intM_p_0_31
           (pset_range (pset_singleton p_0_0) (0)
           (Int.(-) (Int32.to_int !i_14_0) (1)))))
          /\
          (#"whole_program.jc" 1855 10 54# "expl:Assigns clause"
          (not_assigns voidP_p_0_31_alloc_table voidP_p_0_31_alloc_table (at
          !intP_intM_p_0_31 'Init) !intP_intM_p_0_31
          (pset_range (pset_singleton p_0_0) (0)
          (Int.(-) (Int32.to_int size_12) (1))))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 17 14 22#
         (Unsafe_int32.(<)  !i_14_0 size_12 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          (if
          (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 18 10 20#
          (Unsafe_int32.(<>) 
           (Unsafe_int32.(%)  !i_14_0
            (#"whole_program.jc" 1898 59 71# "expl:Integer cast"
            (Unsafe_int32.of_int (2))) )
           (#"whole_program.jc" 1899 31 43# "expl:Integer cast"
           (Unsafe_int32.of_int (0))) ))
          then
           (let _jessie_637 = val_2 in
           (let _jessie_638 = p_0_0 in
           (let _jessie_639 = (Unsafe_int32.to_int  !i_14_0 ) in
           (let _jessie_640 = (shift_  _jessie_638 _jessie_639 ) in
           (upd  intP_intM_p_0_31 _jessie_640 _jessie_637 ))))) else ());
          (i_14_0 :=
           (Unsafe_int32.(+)  !i_14_0
            (#"whole_program.jc" 1904 59 71# "expl:Integer cast"
            (Unsafe_int32.of_int (1))) )) end; (raise (Loop_continue_exc ()))
         end with Loop_continue_exc _jessie_52 -> () end end end;
      (raise (Goto_while_0_break_exc ())) end with Goto_while_0_break_exc
     _jessie_50 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_set_odd_even_skip_safety

  use enum.Uint32 
  
  use import Struct_intP 
  
  use Safe_uint32 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_offset_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let set_odd_even_skip
  #"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 8 5 43#
  "expl:Function set_odd_even_skip, safety" =
  fun
   (a_13 : (pointer voidP)) (n_11 : Uint32.t) (intP_intM_a_13_32 : ref
   (memory voidP Int32.t)) (voidP_a_13_32_alloc_table : (alloc_table voidP))
   (voidP_a_13_32_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_a_13_32_alloc_table a_13) ->
     (((=) (typeof voidP_a_13_32_tag_table a_13) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_13_32_alloc_table a_13) i) /\
       ((<) i (offset_max voidP_a_13_32_alloc_table a_13))) ->
       ((=) (typeof voidP_a_13_32_tag_table (shift a_13 i)) intP_tag)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 2 13 31#
   (if ((<=) (0) (Int.(-) (Uint32.to_int n_11) (1))) then
    (((<=) (offset_min voidP_a_13_32_alloc_table a_13) (0)) /\
    (((>=) (offset_max voidP_a_13_32_alloc_table a_13)
     (Int.(-) (Uint32.to_int n_11) (1)))
    /\
    (forall __framac_tmp31 : int.
     ((((<=) (0) __framac_tmp31) /\
      ((<=) __framac_tmp31 (Int.(-) (Uint32.to_int n_11) (1)))) ->
      ((=) true true))))) else ((=) true true)))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let i_15_0 = ref (Safe_uint32.any_  () ) in
    try
     begin
     (i_15_0 :=
      (let _jessie_661 =
      (#"whole_program.jc" 1949 24 37# "expl:Integer cast"
      (Safe_uint32.of_int (0))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 18 7 12#
      "expl:Pointer index bounds" true) }); _jessie_661 end));
      'Loop_41:
      loop
      invariant { (#"whole_program.jc" 1951 6 2467# true) }
        variant {
          (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 16 20 25#
          (Int.(-) (Uint32.to_int n_11) (Uint32.to_int !i_15_0))) }
       begin
       any unit
       requires { true } reads { a_13, intP_intM_a_13_32, n_11 }
       ensures {
         ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 14 22 102#
          (forall j_34 : int.
           ((((<=) (0) j_34) /\
            (((<) j_34 (Uint32.to_int !i_15_0)) /\
            ((=) (ComputerDivision.mod j_34 (3)) (0)))) ->
            (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 j_34))
            (select (at !intP_intM_a_13_32 'Init) (shift a_13 j_34))))))
         /\
         ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 13 22 93#
          (forall j_33 : int.
           ((((<=) (0) j_33) /\
            (((<) j_33 (Uint32.to_int !i_15_0)) /\
            (((=) (ComputerDivision.mod j_33 (2)) (1)) /\
            ((<>) (ComputerDivision.mod j_33 (3)) (0))))) ->
            (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 j_33))
            (#"whole_program.jc" 1966 55 67# "expl:Integer cast"
            (Int32.of_int (0)))))))
         /\
         ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 12 22 93#
          (forall j_32 : int.
           ((((<=) (0) j_32) /\
            (((<) j_32 (Uint32.to_int !i_15_0)) /\
            (((=) (ComputerDivision.mod j_32 (2)) (0)) /\
            ((<>) (ComputerDivision.mod j_32 (3)) (0))))) ->
            (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 j_32))
            (#"whole_program.jc" 1960 55 67# "expl:Integer cast"
            (Int32.of_int (1)))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 11 22 33#
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 11 22 33#
         ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 11 22 28#
          ((<=) (0) (Uint32.to_int !i_15_0)))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 11 27 33#
         (Uint32.(<=) !i_15_0 n_11)))))))) } ;
        try
         begin
         try
          begin
          (if
          (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 18 14 19#
          (Safe_uint32.(<)  !i_15_0 n_11 )) then ()
          else (raise (Goto_while_0_break_exc ())));
           (if
           (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 19 10 20#
           (Safe_uint32.(=) 
            (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 19 10 15#
            "expl:Division by zero"
            (Safe_uint32.(%)  !i_15_0
             (#"whole_program.jc" 1982 59 72# "expl:Integer cast"
             (Safe_uint32.of_int (3))) ))
            (#"whole_program.jc" 1983 31 44# "expl:Integer cast"
            (Safe_uint32.of_int (0))) )) then (raise (Goto___Cont_exc ()))
           else
            (if
            (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 21 17 27#
            (Safe_uint32.(=) 
             (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 21 17 22#
             "expl:Division by zero"
             (Safe_uint32.(%)  !i_15_0
              (#"whole_program.jc" 1986 62 75# "expl:Integer cast"
              (Safe_uint32.of_int (2))) ))
             (#"whole_program.jc" 1987 50 63# "expl:Integer cast"
             (Safe_uint32.of_int (0))) ))
            then
             (let _jessie_668 =
             (let _jessie_667 =
             (#"whole_program.jc" 1989 82 94# "expl:Integer cast"
             (Safe_int32.of_int (1))) in
             begin
             (assert {
             (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 22 9 17#
             "expl:Pointer index bounds" true) }); _jessie_667 end) in
             (let _jessie_669 = a_13 in
             (let _jessie_670 = (Safe_uint32.to_int  !i_15_0 ) in
             (let _jessie_671 = (shift_typesafe  _jessie_669 _jessie_670 ) in
             (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 22 9 17#
             "expl:Pointer dereference"
             (upd_offset_typesafe  voidP_a_13_32_alloc_table
              intP_intM_a_13_32 _jessie_669 _jessie_670 _jessie_668 ))))))
            else
             (let _jessie_663 =
             (let _jessie_662 =
             (#"whole_program.jc" 1991 82 94# "expl:Integer cast"
             (Safe_int32.of_int (0))) in
             begin
             (assert {
             (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 24 9 17#
             "expl:Pointer index bounds" true) }); _jessie_662 end) in
             (let _jessie_664 = a_13 in
             (let _jessie_665 = (Safe_uint32.to_int  !i_15_0 ) in
             (let _jessie_666 = (shift_typesafe  _jessie_664 _jessie_665 ) in
             (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 24 9 17#
             "expl:Pointer dereference"
             (upd_offset_typesafe  voidP_a_13_32_alloc_table
              intP_intM_a_13_32 _jessie_664 _jessie_665 _jessie_663 ))))))));
           (raise (Goto___Cont_exc ())) end with Goto___Cont_exc _jessie_53
          ->
          'U___Cont:
          'U___Cont:
          (i_15_0 :=
           (let _jessie_672 =
           (Safe_uint32.(+)  !i_15_0
            (#"whole_program.jc" 1994 63 76# "expl:Integer cast"
            (Safe_uint32.of_int (1))) ) in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 18 21 24#
           "expl:Pointer index bounds" true) }); _jessie_672 end)) end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_56 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_54 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_set_odd_even_skip_behaviors

  use Unsafe_uint32 
  
  use Unsafe_int32 
  
  use enum.Uint32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let set_odd_even_skip_ensures_default
  #"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 8 5 43#
  "expl:Function set_odd_even_skip, default behavior" =
  fun
   (a_13 : (pointer voidP)) (n_11 : Uint32.t) (intP_intM_a_13_32 : ref
   (memory voidP Int32.t)) (voidP_a_13_32_alloc_table : (alloc_table voidP))
   (voidP_a_13_32_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_a_13_32_alloc_table a_13) ->
     (((=) (typeof voidP_a_13_32_tag_table a_13) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_13_32_alloc_table a_13) i) /\
       ((<) i (offset_max voidP_a_13_32_alloc_table a_13))) ->
       ((=) (typeof voidP_a_13_32_tag_table (shift a_13 i)) intP_tag)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 2 13 31#
   (if ((<=) (0) (Int.(-) (Uint32.to_int n_11) (1))) then
    (((<=) (offset_min voidP_a_13_32_alloc_table a_13) (0)) /\
    (((>=) (offset_max voidP_a_13_32_alloc_table a_13)
     (Int.(-) (Uint32.to_int n_11) (1)))
    /\
    (forall __framac_tmp31 : int.
     ((((<=) (0) __framac_tmp31) /\
      ((<=) __framac_tmp31 (Int.(-) (Uint32.to_int n_11) (1)))) ->
      ((=) true true))))) else ((=) true true)))) }
   ensures {
     ("expl:Postcondition"
     ((#"whole_program.jc" 1925 10 52# "expl:Assigns clause"
      (not_assigns voidP_a_13_32_alloc_table voidP_a_13_32_alloc_table (old
      !intP_intM_a_13_32) !intP_intM_a_13_32
      (pset_range (pset_singleton a_13) (0)
      (Int.(-) (Uint32.to_int n_11) (1)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
      "expl:Ensures clause"
      (forall i_42 : int.
       ((((<=) (0) i_42) /\
        (((<) i_42 (Uint32.to_int n_11)) /\
        (((=) (ComputerDivision.mod i_42 (2)) (0)) /\
        ((<>) (ComputerDivision.mod i_42 (3)) (0))))) ->
        (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 i_42))
        (#"whole_program.jc" 1932 37 49# "expl:Integer cast" (Int32.of_int
        (1)))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 5 12 87#
      "expl:Ensures clause"
      (forall i_43 : int.
       ((((<=) (0) i_43) /\
        (((<) i_43 (Uint32.to_int n_11)) /\
        (((=) (ComputerDivision.mod i_43 (2)) (1)) /\
        ((<>) (ComputerDivision.mod i_43 (3)) (0))))) ->
        (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 i_43))
        (#"whole_program.jc" 1939 39 51# "expl:Integer cast" (Int32.of_int
        (0)))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 6 12 80#
     "expl:Ensures clause"
     (forall i_44 : int.
      ((((<=) (0) i_44) /\
       (((<) i_44 (Uint32.to_int n_11)) /\
       ((=) (ComputerDivision.mod i_44 (3)) (0)))) ->
       (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 i_44))
       (select (old !intP_intM_a_13_32) (shift a_13 i_44))))))))))))) }
   diverges  ->
   'Init:
   try
    begin
    (let i_15_0 = ref (Unsafe_uint32.any_  () ) in
    try
     begin
     (i_15_0 :=
      (#"whole_program.jc" 1949 24 37# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))));
      'Loop_40:
      loop
      invariant
        { (((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 11 22 33#
            (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 11 22 33#
            ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 11 22 28#
             ((<=) (0) (Uint32.to_int !i_15_0)))
            /\
            (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 11 27 33#
            (Uint32.(<=) !i_15_0 n_11)))))
           &&
           ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 12 22 93#
            (forall j_32 : int.
             ((((<=) (0) j_32) /\
              (((<) j_32 (Uint32.to_int !i_15_0)) /\
              (((=) (ComputerDivision.mod j_32 (2)) (0)) /\
              ((<>) (ComputerDivision.mod j_32 (3)) (0))))) ->
              (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 j_32))
              (#"whole_program.jc" 1960 55 67# "expl:Integer cast"
              (Int32.of_int (1)))))))
           &&
           ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 13 22 93#
            (forall j_33 : int.
             ((((<=) (0) j_33) /\
              (((<) j_33 (Uint32.to_int !i_15_0)) /\
              (((=) (ComputerDivision.mod j_33 (2)) (1)) /\
              ((<>) (ComputerDivision.mod j_33 (3)) (0))))) ->
              (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 j_33))
              (#"whole_program.jc" 1966 55 67# "expl:Integer cast"
              (Int32.of_int (0)))))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 14 22 102#
           (forall j_34 : int.
            ((((<=) (0) j_34) /\
             (((<) j_34 (Uint32.to_int !i_15_0)) /\
             ((=) (ComputerDivision.mod j_34 (3)) (0)))) ->
             (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 j_34))
             (select (at !intP_intM_a_13_32 'Init) (shift a_13 j_34)))))))))
          /\
          ((#"whole_program.jc" 1951 6 2467# "expl:Assigns clause"
           (not_assigns voidP_a_13_32_alloc_table voidP_a_13_32_alloc_table
           (at !intP_intM_a_13_32 'Loop_40) !intP_intM_a_13_32
           (pset_range (pset_singleton a_13) (0)
           (Int.(-) (Uint32.to_int !i_15_0) (1)))))
          /\
          (#"whole_program.jc" 1925 10 52# "expl:Assigns clause"
          (not_assigns voidP_a_13_32_alloc_table voidP_a_13_32_alloc_table
          (at !intP_intM_a_13_32 'Init) !intP_intM_a_13_32
          (pset_range (pset_singleton a_13) (0)
          (Int.(-) (Uint32.to_int n_11) (1))))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         try
          begin
          (if
          (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 18 14 19#
          (Unsafe_uint32.(<)  !i_15_0 n_11 )) then ()
          else (raise (Goto_while_0_break_exc ())));
           (if
           (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 19 10 20#
           (Unsafe_uint32.(=) 
            (Unsafe_uint32.(%)  !i_15_0
             (#"whole_program.jc" 1982 59 72# "expl:Integer cast"
             (Unsafe_uint32.of_int (3))) )
            (#"whole_program.jc" 1983 31 44# "expl:Integer cast"
            (Unsafe_uint32.of_int (0))) )) then (raise (Goto___Cont_exc ()))
           else
            (if
            (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 21 17 27#
            (Unsafe_uint32.(=) 
             (Unsafe_uint32.(%)  !i_15_0
              (#"whole_program.jc" 1986 62 75# "expl:Integer cast"
              (Unsafe_uint32.of_int (2))) )
             (#"whole_program.jc" 1987 50 63# "expl:Integer cast"
             (Unsafe_uint32.of_int (0))) ))
            then
             (let _jessie_656 =
             (#"whole_program.jc" 1989 82 94# "expl:Integer cast"
             (Unsafe_int32.of_int (1))) in
             (let _jessie_657 = a_13 in
             (let _jessie_658 = (Unsafe_uint32.to_int  !i_15_0 ) in
             (let _jessie_659 = (shift_  _jessie_657 _jessie_658 ) in
             (upd  intP_intM_a_13_32 _jessie_659 _jessie_656 )))))
            else
             (let _jessie_651 =
             (#"whole_program.jc" 1991 82 94# "expl:Integer cast"
             (Unsafe_int32.of_int (0))) in
             (let _jessie_652 = a_13 in
             (let _jessie_653 = (Unsafe_uint32.to_int  !i_15_0 ) in
             (let _jessie_654 = (shift_  _jessie_652 _jessie_653 ) in
             (upd  intP_intM_a_13_32 _jessie_654 _jessie_651 )))))));
           (raise (Goto___Cont_exc ())) end with Goto___Cont_exc _jessie_53
          ->
          'U___Cont:
          'U___Cont:
          (i_15_0 :=
           (Unsafe_uint32.(+)  !i_15_0
            (#"whole_program.jc" 1994 63 76# "expl:Integer cast"
            (Unsafe_uint32.of_int (1))) )) end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_56 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_54 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_set_only_third_safety

  use import Struct_intP 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_offset_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let set_only_third
  #"/home/work/workspace/education/acsl-exam/./set_only_third.c" 7 5 46#
  "expl:Function set_only_third, safety" =
  fun
   (p_1 : (pointer voidP)) (size_13 : Int32.t) (val_3 : Int32.t)
   (intP_intM_p_1_33 : ref (memory voidP Int32.t)) (voidP_p_1_33_alloc_table
   : (alloc_table voidP)) (voidP_p_1_33_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_p_1_33_alloc_table p_1) ->
     (((=) (typeof voidP_p_1_33_tag_table p_1) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_p_1_33_alloc_table p_1) i) /\
       ((<) i (offset_max voidP_p_1_33_alloc_table p_1))) ->
       ((=) (typeof voidP_p_1_33_tag_table (shift p_1 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 2004 12 707#
   ((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 1 13 22#
    (Int32.(>=) size_13 (#"whole_program.jc" 2004 34 46# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 2 13 34#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_13) (1))) then
    (((<=) (offset_min voidP_p_1_33_alloc_table p_1) (0)) /\
    (((>=) (offset_max voidP_p_1_33_alloc_table p_1)
     (Int.(-) (Int32.to_int size_13) (1)))
    /\
    (forall __framac_tmp32 : int.
     ((((<=) (0) __framac_tmp32) /\
      ((<=) __framac_tmp32 (Int.(-) (Int32.to_int size_13) (1)))) ->
      ((=) true true))))) else ((=) true true)))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let i_16_0 = ref (Safe_int32.any_  () ) in
    try
     begin
     (i_16_0 :=
      (let _jessie_680 =
      (#"whole_program.jc" 2032 24 36# "expl:Integer cast"
      (Safe_int32.of_int (0))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 16 7 12#
      "expl:Pointer index bounds" true) }); _jessie_680 end));
      'Loop_43:
      loop
      invariant { (#"whole_program.jc" 2034 6 1608# true) }
        variant {
          (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 14 20 28#
          (Int.(-) (Int32.to_int size_13) (Int32.to_int !i_16_0))) }
       begin
       any unit
       requires { true } reads { intP_intM_p_1_33, p_1, size_13, val_3 }
       ensures {
         ((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 12 22 102#
          (forall j_36 : int.
           ((((<=) (0) j_36) /\
            (((<) j_36 (Int32.to_int !i_16_0)) /\
            ((<>) (ComputerDivision.mod j_36 (3)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_1_33 (shift p_1 j_36))
            (select (at !intP_intM_p_1_33 'Init) (shift p_1 j_36))))))
         /\
         ((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 11 22 81#
          (forall j_35 : int.
           ((((<=) (0) j_35) /\
            (((<) j_35 (Int32.to_int !i_16_0)) /\
            ((=) (ComputerDivision.mod j_35 (3)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_1_33 (shift p_1 j_35)) val_3))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 10 22 36#
         (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 10 22 36#
         ((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 10 22 28#
          (Int32.(<=) (#"whole_program.jc" 2036 40 52# "expl:Integer cast"
          (Int32.of_int (0))) !i_16_0))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 10 27 36#
         (Int32.(<=) !i_16_0 size_13))))))) } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 16 14 22#
         (Safe_int32.(<)  !i_16_0 size_13 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          (if
          (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 17 10 20#
          (Safe_int32.(=) 
           (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 17 10 15#
           "expl:Division by zero"
           (Safe_int32.(%)  !i_16_0
            (#"whole_program.jc" 2059 59 71# "expl:Integer cast"
            (Safe_int32.of_int (3))) ))
           (#"whole_program.jc" 2060 31 43# "expl:Integer cast"
           (Safe_int32.of_int (0))) ))
          then
           (let _jessie_682 =
           (let _jessie_681 = val_3 in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 18 9 19#
           "expl:Pointer index bounds" true) }); _jessie_681 end) in
           (let _jessie_683 = p_1 in
           (let _jessie_684 = (Safe_int32.to_int  !i_16_0 ) in
           (let _jessie_685 = (shift_typesafe  _jessie_683 _jessie_684 ) in
           (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 18 9 19#
           "expl:Pointer dereference"
           (upd_offset_typesafe  voidP_p_1_33_alloc_table intP_intM_p_1_33
            _jessie_683 _jessie_684 _jessie_682 )))))) else ());
          (i_16_0 :=
           (let _jessie_686 =
           (Safe_int32.(+)  !i_16_0
            (#"whole_program.jc" 2065 59 71# "expl:Integer cast"
            (Safe_int32.of_int (1))) ) in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 16 24 27#
           "expl:Pointer index bounds" true) }); _jessie_686 end)) end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_59 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_57 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_set_only_third_behaviors

  use Unsafe_int32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let set_only_third_ensures_default
  #"/home/work/workspace/education/acsl-exam/./set_only_third.c" 7 5 46#
  "expl:Function set_only_third, default behavior" =
  fun
   (p_1 : (pointer voidP)) (size_13 : Int32.t) (val_3 : Int32.t)
   (intP_intM_p_1_33 : ref (memory voidP Int32.t)) (voidP_p_1_33_alloc_table
   : (alloc_table voidP)) (voidP_p_1_33_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_p_1_33_alloc_table p_1) ->
     (((=) (typeof voidP_p_1_33_tag_table p_1) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_p_1_33_alloc_table p_1) i) /\
       ((<) i (offset_max voidP_p_1_33_alloc_table p_1))) ->
       ((=) (typeof voidP_p_1_33_tag_table (shift p_1 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 2004 12 707#
   ((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 1 13 22#
    (Int32.(>=) size_13 (#"whole_program.jc" 2004 34 46# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 2 13 34#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_13) (1))) then
    (((<=) (offset_min voidP_p_1_33_alloc_table p_1) (0)) /\
    (((>=) (offset_max voidP_p_1_33_alloc_table p_1)
     (Int.(-) (Int32.to_int size_13) (1)))
    /\
    (forall __framac_tmp32 : int.
     ((((<=) (0) __framac_tmp32) /\
      ((<=) __framac_tmp32 (Int.(-) (Int32.to_int size_13) (1)))) ->
      ((=) true true))))) else ((=) true true)))))) }
   ensures {
     ("expl:Postcondition"
     ((#"whole_program.jc" 2016 10 54# "expl:Assigns clause"
      (not_assigns voidP_p_1_33_alloc_table voidP_p_1_33_alloc_table (old
      !intP_intM_p_1_33) !intP_intM_p_1_33
      (pset_range (pset_singleton p_1) (0)
      (Int.(-) (Int32.to_int size_13) (1)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 4 12 74#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 4 12 74#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 4 12 74#
      "expl:Ensures clause"
      (forall j_37 : int.
       ((((<=) (0) j_37) /\
        (((<) j_37 (Int32.to_int size_13)) /\
        ((=) (ComputerDivision.mod j_37 (3)) (0)))) ->
        (Int32.(=) (select !intP_intM_p_1_33 (shift p_1 j_37)) val_3))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 5 12 81#
     "expl:Ensures clause"
     (forall j_38 : int.
      ((((<=) (0) j_38) /\
       (((<) j_38 (Int32.to_int size_13)) /\
       ((<>) (ComputerDivision.mod j_38 (3)) (0)))) ->
       (Int32.(=) (select !intP_intM_p_1_33 (shift p_1 j_38))
       (select (old !intP_intM_p_1_33) (shift p_1 j_38))))))))))) } diverges 
   ->
   'Init:
   try
    begin
    (let i_16_0 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (i_16_0 :=
      (#"whole_program.jc" 2032 24 36# "expl:Integer cast"
      (Unsafe_int32.of_int (0))));
      'Loop_42:
      loop
      invariant
        { (((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 10 22 36#
            (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 10 22 36#
            ((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 10 22 28#
             (Int32.(<=) (#"whole_program.jc" 2036 40 52# "expl:Integer cast"
             (Int32.of_int (0))) !i_16_0))
            /\
            (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 10 27 36#
            (Int32.(<=) !i_16_0 size_13)))))
           &&
           ((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 11 22 81#
            (forall j_35 : int.
             ((((<=) (0) j_35) /\
              (((<) j_35 (Int32.to_int !i_16_0)) /\
              ((=) (ComputerDivision.mod j_35 (3)) (0)))) ->
              (Int32.(=) (select !intP_intM_p_1_33 (shift p_1 j_35)) val_3))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 12 22 102#
           (forall j_36 : int.
            ((((<=) (0) j_36) /\
             (((<) j_36 (Int32.to_int !i_16_0)) /\
             ((<>) (ComputerDivision.mod j_36 (3)) (0)))) ->
             (Int32.(=) (select !intP_intM_p_1_33 (shift p_1 j_36))
             (select (at !intP_intM_p_1_33 'Init) (shift p_1 j_36))))))))
          /\
          ((#"whole_program.jc" 2034 6 1608# "expl:Assigns clause"
           (not_assigns voidP_p_1_33_alloc_table voidP_p_1_33_alloc_table (at
           !intP_intM_p_1_33 'Loop_42) !intP_intM_p_1_33
           (pset_range (pset_singleton p_1) (0)
           (Int.(-) (Int32.to_int !i_16_0) (1)))))
          /\
          (#"whole_program.jc" 2016 10 54# "expl:Assigns clause"
          (not_assigns voidP_p_1_33_alloc_table voidP_p_1_33_alloc_table (at
          !intP_intM_p_1_33 'Init) !intP_intM_p_1_33
          (pset_range (pset_singleton p_1) (0)
          (Int.(-) (Int32.to_int size_13) (1))))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 16 14 22#
         (Unsafe_int32.(<)  !i_16_0 size_13 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          (if
          (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 17 10 20#
          (Unsafe_int32.(=) 
           (Unsafe_int32.(%)  !i_16_0
            (#"whole_program.jc" 2059 59 71# "expl:Integer cast"
            (Unsafe_int32.of_int (3))) )
           (#"whole_program.jc" 2060 31 43# "expl:Integer cast"
           (Unsafe_int32.of_int (0))) ))
          then
           (let _jessie_675 = val_3 in
           (let _jessie_676 = p_1 in
           (let _jessie_677 = (Unsafe_int32.to_int  !i_16_0 ) in
           (let _jessie_678 = (shift_  _jessie_676 _jessie_677 ) in
           (upd  intP_intM_p_1_33 _jessie_678 _jessie_675 ))))) else ());
          (i_16_0 :=
           (Unsafe_int32.(+)  !i_16_0
            (#"whole_program.jc" 2065 59 71# "expl:Integer cast"
            (Unsafe_int32.of_int (1))) )) end; (raise (Loop_continue_exc ()))
         end with Loop_continue_exc _jessie_59 -> () end end end;
      (raise (Goto_while_0_break_exc ())) end with Goto_while_0_break_exc
     _jessie_57 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_set_skip_third_safety

  use import Struct_intP 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_offset_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let set_skip_third
  #"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 10 5 46#
  "expl:Function set_skip_third, safety" =
  fun
   (p_2 : (pointer voidP)) (size_14 : Int32.t) (val_4 : Int32.t)
   (intP_intM_p_2_34 : ref (memory voidP Int32.t)) (voidP_p_2_34_alloc_table
   : (alloc_table voidP)) (voidP_p_2_34_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_p_2_34_alloc_table p_2) ->
     (((=) (typeof voidP_p_2_34_tag_table p_2) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_p_2_34_alloc_table p_2) i) /\
       ((<) i (offset_max voidP_p_2_34_alloc_table p_2))) ->
       ((=) (typeof voidP_p_2_34_tag_table (shift p_2 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 2075 12 782#
   ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 3 13 22#
    (Int32.(>=) size_14 (#"whole_program.jc" 2075 34 46# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 2075 12 782#
   ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 4 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_14) (1))) then
     (((<=) (offset_min voidP_p_2_34_alloc_table p_2) (0)) /\
     (((>=) (offset_max voidP_p_2_34_alloc_table p_2)
      (Int.(-) (Int32.to_int size_14) (1)))
     /\
     (forall __framac_tmp33 : int.
      ((((<=) (0) __framac_tmp33) /\
       ((<=) __framac_tmp33 (Int.(-) (Int32.to_int size_14) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 5 13 28#
   ((<) (Int.(+) (Int32.to_int val_4) (2)) (32767)))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let i_17_0 = ref (Safe_int32.any_  () ) in
    try
     begin
     (i_17_0 :=
      (let _jessie_694 =
      (#"whole_program.jc" 2105 24 36# "expl:Integer cast"
      (Safe_int32.of_int (0))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 19 7 12#
      "expl:Pointer index bounds" true) }); _jessie_694 end));
      'Loop_45:
      loop
      invariant { (#"whole_program.jc" 2107 6 2150# true) }
        variant {
          (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 17 20 28#
          (Int.(-) (Int32.to_int size_14) (Int32.to_int !i_17_0))) }
       begin
       any unit
       requires { true } reads { intP_intM_p_2_34, p_2, size_14, val_4 }
       ensures {
         ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 15 22 102#
          (forall j_40 : int.
           ((((<=) (0) j_40) /\
            (((<) j_40 (Int32.to_int !i_17_0)) /\
            ((=) (ComputerDivision.mod j_40 (3)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_2_34 (shift p_2 j_40))
            (select (at !intP_intM_p_2_34 'Init) (shift p_2 j_40))))))
         /\
         ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 14 22 89#
          (forall j_39 : int.
           ((((<=) (0) j_39) /\
            (((<) j_39 (Int32.to_int !i_17_0)) /\
            ((<>) (ComputerDivision.mod j_39 (3)) (0)))) ->
            ((=) (Int32.to_int (select !intP_intM_p_2_34 (shift p_2 j_39)))
            (Int.(+) (Int32.to_int val_4) (ComputerDivision.mod j_39 (3)))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 13 22 36#
         (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 13 22 36#
         ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 13 22 28#
          (Int32.(<=) (#"whole_program.jc" 2109 40 52# "expl:Integer cast"
          (Int32.of_int (0))) !i_17_0))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 13 27 36#
         (Int32.(<=) !i_17_0 size_14))))))) } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 19 14 22#
         (Safe_int32.(<)  !i_17_0 size_14 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          (if
          (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 20 10 20#
          (Safe_int32.(<>) 
           (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 20 10 15#
           "expl:Division by zero"
           (Safe_int32.(%)  !i_17_0
            (#"whole_program.jc" 2133 59 71# "expl:Integer cast"
            (Safe_int32.of_int (3))) ))
           (#"whole_program.jc" 2134 31 43# "expl:Integer cast"
           (Safe_int32.of_int (0))) ))
          then
           (let _jessie_696 =
           (let _jessie_695 =
           (Safe_int32.(+)  val_4
            (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 21 22 27#
            "expl:Division by zero"
            (Safe_int32.(%)  !i_17_0
             (#"whole_program.jc" 2143 66 78# "expl:Integer cast"
             (Safe_int32.of_int (3))) )) ) in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 21 9 27#
           "expl:Pointer index bounds" true) }); _jessie_695 end) in
           (let _jessie_697 = p_2 in
           (let _jessie_698 = (Safe_int32.to_int  !i_17_0 ) in
           (let _jessie_699 = (shift_typesafe  _jessie_697 _jessie_698 ) in
           (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 21 9 27#
           "expl:Pointer dereference"
           (upd_offset_typesafe  voidP_p_2_34_alloc_table intP_intM_p_2_34
            _jessie_697 _jessie_698 _jessie_696 )))))) else ());
          (i_17_0 :=
           (let _jessie_700 =
           (Safe_int32.(+)  !i_17_0
            (#"whole_program.jc" 2145 59 71# "expl:Integer cast"
            (Safe_int32.of_int (1))) ) in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 19 24 27#
           "expl:Pointer index bounds" true) }); _jessie_700 end)) end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_62 -> () end end end; (raise (Goto_while_0_break_exc ()))
     end with Goto_while_0_break_exc _jessie_60 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_set_skip_third_behaviors

  use Unsafe_int32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let set_skip_third_ensures_default
  #"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 10 5 46#
  "expl:Function set_skip_third, default behavior" =
  fun
   (p_2 : (pointer voidP)) (size_14 : Int32.t) (val_4 : Int32.t)
   (intP_intM_p_2_34 : ref (memory voidP Int32.t)) (voidP_p_2_34_alloc_table
   : (alloc_table voidP)) (voidP_p_2_34_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_p_2_34_alloc_table p_2) ->
     (((=) (typeof voidP_p_2_34_tag_table p_2) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_p_2_34_alloc_table p_2) i) /\
       ((<) i (offset_max voidP_p_2_34_alloc_table p_2))) ->
       ((=) (typeof voidP_p_2_34_tag_table (shift p_2 i)) intP_tag)))))
   /\
   (#"whole_program.jc" 2075 12 782#
   ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 3 13 22#
    (Int32.(>=) size_14 (#"whole_program.jc" 2075 34 46# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 2075 12 782#
   ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 4 13 34#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_14) (1))) then
     (((<=) (offset_min voidP_p_2_34_alloc_table p_2) (0)) /\
     (((>=) (offset_max voidP_p_2_34_alloc_table p_2)
      (Int.(-) (Int32.to_int size_14) (1)))
     /\
     (forall __framac_tmp33 : int.
      ((((<=) (0) __framac_tmp33) /\
       ((<=) __framac_tmp33 (Int.(-) (Int32.to_int size_14) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 5 13 28#
   ((<) (Int.(+) (Int32.to_int val_4) (2)) (32767)))))))) }
   ensures {
     ("expl:Postcondition"
     ((#"whole_program.jc" 2088 10 54# "expl:Assigns clause"
      (not_assigns voidP_p_2_34_alloc_table voidP_p_2_34_alloc_table (old
      !intP_intM_p_2_34) !intP_intM_p_2_34
      (pset_range (pset_singleton p_2) (0)
      (Int.(-) (Int32.to_int size_14) (1)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 7 12 82#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 7 12 82#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 7 12 82#
      "expl:Ensures clause"
      (forall j_41 : int.
       ((((<=) (0) j_41) /\
        (((<) j_41 (Int32.to_int size_14)) /\
        ((<>) (ComputerDivision.mod j_41 (3)) (0)))) ->
        ((=) (Int32.to_int (select !intP_intM_p_2_34 (shift p_2 j_41)))
        (Int.(+) (Int32.to_int val_4) (ComputerDivision.mod j_41 (3)))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 8 12 81#
     "expl:Ensures clause"
     (forall j_42 : int.
      ((((<=) (0) j_42) /\
       (((<) j_42 (Int32.to_int size_14)) /\
       ((=) (ComputerDivision.mod j_42 (3)) (0)))) ->
       (Int32.(=) (select !intP_intM_p_2_34 (shift p_2 j_42))
       (select (old !intP_intM_p_2_34) (shift p_2 j_42))))))))))) } diverges 
   ->
   'Init:
   try
    begin
    (let i_17_0 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (i_17_0 :=
      (#"whole_program.jc" 2105 24 36# "expl:Integer cast"
      (Unsafe_int32.of_int (0))));
      'Loop_44:
      loop
      invariant
        { (((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 13 22 36#
            (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 13 22 36#
            ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 13 22 28#
             (Int32.(<=) (#"whole_program.jc" 2109 40 52# "expl:Integer cast"
             (Int32.of_int (0))) !i_17_0))
            /\
            (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 13 27 36#
            (Int32.(<=) !i_17_0 size_14)))))
           &&
           ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 14 22 89#
            (forall j_39 : int.
             ((((<=) (0) j_39) /\
              (((<) j_39 (Int32.to_int !i_17_0)) /\
              ((<>) (ComputerDivision.mod j_39 (3)) (0)))) ->
              ((=) (Int32.to_int (select !intP_intM_p_2_34 (shift p_2 j_39)))
              (Int.(+) (Int32.to_int val_4) (ComputerDivision.mod j_39 (3)))))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 15 22 102#
           (forall j_40 : int.
            ((((<=) (0) j_40) /\
             (((<) j_40 (Int32.to_int !i_17_0)) /\
             ((=) (ComputerDivision.mod j_40 (3)) (0)))) ->
             (Int32.(=) (select !intP_intM_p_2_34 (shift p_2 j_40))
             (select (at !intP_intM_p_2_34 'Init) (shift p_2 j_40))))))))
          /\
          ((#"whole_program.jc" 2107 6 2150# "expl:Assigns clause"
           (not_assigns voidP_p_2_34_alloc_table voidP_p_2_34_alloc_table (at
           !intP_intM_p_2_34 'Loop_44) !intP_intM_p_2_34
           (pset_range (pset_singleton p_2) (0)
           (Int.(-) (Int32.to_int !i_17_0) (1)))))
          /\
          (#"whole_program.jc" 2088 10 54# "expl:Assigns clause"
          (not_assigns voidP_p_2_34_alloc_table voidP_p_2_34_alloc_table (at
          !intP_intM_p_2_34 'Init) !intP_intM_p_2_34
          (pset_range (pset_singleton p_2) (0)
          (Int.(-) (Int32.to_int size_14) (1))))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         begin
         (if
         (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 19 14 22#
         (Unsafe_int32.(<)  !i_17_0 size_14 )) then ()
         else (raise (Goto_while_0_break_exc ())));
          (if
          (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 20 10 20#
          (Unsafe_int32.(<>) 
           (Unsafe_int32.(%)  !i_17_0
            (#"whole_program.jc" 2133 59 71# "expl:Integer cast"
            (Unsafe_int32.of_int (3))) )
           (#"whole_program.jc" 2134 31 43# "expl:Integer cast"
           (Unsafe_int32.of_int (0))) ))
          then
           (let _jessie_689 =
           (Unsafe_int32.(+)  val_4
            (Unsafe_int32.(%)  !i_17_0
             (#"whole_program.jc" 2143 66 78# "expl:Integer cast"
             (Unsafe_int32.of_int (3))) ) ) in
           (let _jessie_690 = p_2 in
           (let _jessie_691 = (Unsafe_int32.to_int  !i_17_0 ) in
           (let _jessie_692 = (shift_  _jessie_690 _jessie_691 ) in
           (upd  intP_intM_p_2_34 _jessie_692 _jessie_689 ))))) else ());
          (i_17_0 :=
           (Unsafe_int32.(+)  !i_17_0
            (#"whole_program.jc" 2145 59 71# "expl:Integer cast"
            (Unsafe_int32.of_int (1))) )) end; (raise (Loop_continue_exc ()))
         end with Loop_continue_exc _jessie_62 -> () end end end;
      (raise (Goto_while_0_break_exc ())) end with Goto_while_0_break_exc
     _jessie_60 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end);
     (raise Return) end with Return -> () end
  
end

module Function_spec_sign_safety

  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let spec_sign #"/home/work/workspace/education/acsl-exam/./sign.c" 16 4 20#
  "expl:Function spec_sign, safety" =
  fun (x : Int32.t) 
   requires { (true) } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let __retres_3 = ref (Safe_int32.any_  () ) in
     begin
     (__retres_3 :=
      (let _jessie_709 =
      (Safe_int32.(-) 
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 18 11 16#
       "expl:Integer cast"
       (Safe_int32.of_int 
        (if
        (#"whole_program.jc" 2182 68 152#
        (Safe_int32.(>)  x
         (#"whole_program.jc" 2183 68 80# "expl:Integer cast"
         (Safe_int32.of_int (0))) )) then (1) else (0)) ))
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 18 21 26#
       "expl:Integer cast"
       (Safe_int32.of_int 
        (if
        (#"whole_program.jc" 2184 69 153#
        (Safe_int32.(<)  x
         (#"whole_program.jc" 2185 68 80# "expl:Integer cast"
         (Safe_int32.of_int (0))) )) then (1) else (0)) )) ) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./sign.c" 18 3 28#
      "expl:Pointer index bounds" true) }); _jessie_709 end));
      begin
      (return :=
       (let _jessie_710 = !__retres_3 in
       begin
       (assert {
       (#"whole_program.jc" 2187 7 24# "expl:Pointer index bounds" true) });
        _jessie_710 end)); (raise Return) end end); absurd  end with Return
    -> !return end)
  
end

module Function_spec_sign_behaviors

  use Unsafe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let spec_sign_ensures_default
  #"/home/work/workspace/education/acsl-exam/./sign.c" 16 4 20#
  "expl:Function spec_sign, default behavior" =
  fun (x : Int32.t) 
   requires { (true) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./sign.c" 3 12 57#
     "expl:Ensures clause"
     ((Int32.(=) result (#"whole_program.jc" 2157 34 46# "expl:Integer cast"
      (Int32.of_int (0))))
     \/
     ((Int32.(=) result (#"whole_program.jc" 2157 63 75# "expl:Integer cast"
      (Int32.of_int (1))))
     \/ ((=) (Int32.to_int result) (Int.(-_) (1))))))) }  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (check {
    (#"whole_program.jc" 2169 10 117# "expl:Behavior disjointness check"
    (not
    ((Int32.(=) x (#"whole_program.jc" 2169 42 54# "expl:Integer cast"
     (Int32.of_int (0))))
    /\
    (Int32.(<) x (#"whole_program.jc" 2170 42 54# "expl:Integer cast"
    (Int32.of_int (0))))))) });
     (check {
     (#"whole_program.jc" 2172 10 117# "expl:Behavior disjointness check"
     (not
     ((Int32.(>) x (#"whole_program.jc" 2172 41 53# "expl:Integer cast"
      (Int32.of_int (0))))
     /\
     (Int32.(=) x (#"whole_program.jc" 2173 43 55# "expl:Integer cast"
     (Int32.of_int (0))))))) });
     (check {
     (#"whole_program.jc" 2175 10 79# "expl:Behavior disjointness check"
     (not
     ((Int32.(>) x (#"whole_program.jc" 2175 41 53# "expl:Integer cast"
      (Int32.of_int (0))))
     /\
     (Int32.(<) x (#"whole_program.jc" 2175 63 75# "expl:Integer cast"
     (Int32.of_int (0))))))) });
     (check {
     (#"whole_program.jc" 2177 10 134# "expl:Behavior completeness check"
     ((Int32.(<) x (#"whole_program.jc" 2177 38 50# "expl:Integer cast"
      (Int32.of_int (0))))
     \/
     ((Int32.(=) x (#"whole_program.jc" 2178 41 53# "expl:Integer cast"
      (Int32.of_int (0))))
     \/
     (Int32.(>) x (#"whole_program.jc" 2178 63 75# "expl:Integer cast"
     (Int32.of_int (0))))))) });
     (let __retres_3 = ref (Unsafe_int32.any_  () ) in
     begin
     (__retres_3 :=
      (Unsafe_int32.(-) 
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 18 11 16#
       "expl:Integer cast"
       (Unsafe_int32.of_int 
        (if
        (#"whole_program.jc" 2182 68 152#
        (Unsafe_int32.(>)  x
         (#"whole_program.jc" 2183 68 80# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) )) then (1) else (0)) ))
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 18 21 26#
       "expl:Integer cast"
       (Unsafe_int32.of_int 
        (if
        (#"whole_program.jc" 2184 69 153#
        (Unsafe_int32.(<)  x
         (#"whole_program.jc" 2185 68 80# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) )) then (1) else (0)) )) ));
      begin (return := !__retres_3); (raise Return) end end); absurd  end
    with Return -> !return end)
  
  let spec_sign_ensures_negative
  #"/home/work/workspace/education/acsl-exam/./sign.c" 16 4 20#
  "expl:Function spec_sign, behavior negative" =
  fun (x : Int32.t) 
   requires {
   (Int32.(<) x (#"whole_program.jc" 2166 15 27# "expl:Integer cast"
   (Int32.of_int (0)))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./sign.c" 12 15 28#
     "expl:Ensures clause" ((=) (Int32.to_int result) (Int.(-_) (1))))) }  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let __retres_3 = ref (Unsafe_int32.any_  () ) in
     begin
     (__retres_3 :=
      (Unsafe_int32.(-) 
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 18 11 16#
       "expl:Integer cast"
       (Unsafe_int32.of_int 
        (if
        (#"whole_program.jc" 2182 68 152#
        (Unsafe_int32.(>)  x
         (#"whole_program.jc" 2183 68 80# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) )) then (1) else (0)) ))
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 18 21 26#
       "expl:Integer cast"
       (Unsafe_int32.of_int 
        (if
        (#"whole_program.jc" 2184 69 153#
        (Unsafe_int32.(<)  x
         (#"whole_program.jc" 2185 68 80# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) )) then (1) else (0)) )) ));
      begin (return := !__retres_3); (raise Return) end end); absurd  end
    with Return -> !return end)
  
  let spec_sign_ensures_positive
  #"/home/work/workspace/education/acsl-exam/./sign.c" 16 4 20#
  "expl:Function spec_sign, behavior positive" =
  fun (x : Int32.t) 
   requires {
   (Int32.(>) x (#"whole_program.jc" 2160 15 27# "expl:Integer cast"
   (Int32.of_int (0)))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./sign.c" 6 15 27#
     "expl:Ensures clause"
     (Int32.(=) result (#"whole_program.jc" 2161 32 44# "expl:Integer cast"
     (Int32.of_int (1)))))) }  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let __retres_3 = ref (Unsafe_int32.any_  () ) in
     begin
     (__retres_3 :=
      (Unsafe_int32.(-) 
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 18 11 16#
       "expl:Integer cast"
       (Unsafe_int32.of_int 
        (if
        (#"whole_program.jc" 2182 68 152#
        (Unsafe_int32.(>)  x
         (#"whole_program.jc" 2183 68 80# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) )) then (1) else (0)) ))
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 18 21 26#
       "expl:Integer cast"
       (Unsafe_int32.of_int 
        (if
        (#"whole_program.jc" 2184 69 153#
        (Unsafe_int32.(<)  x
         (#"whole_program.jc" 2185 68 80# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) )) then (1) else (0)) )) ));
      begin (return := !__retres_3); (raise Return) end end); absurd  end
    with Return -> !return end)
  
  let spec_sign_ensures_zero
  #"/home/work/workspace/education/acsl-exam/./sign.c" 16 4 20#
  "expl:Function spec_sign, behavior zero" =
  fun (x : Int32.t) 
   requires {
   (Int32.(=) x (#"whole_program.jc" 2163 16 28# "expl:Integer cast"
   (Int32.of_int (0)))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./sign.c" 9 15 27#
     "expl:Ensures clause"
     (Int32.(=) result (#"whole_program.jc" 2164 32 44# "expl:Integer cast"
     (Int32.of_int (0)))))) }  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let __retres_3 = ref (Unsafe_int32.any_  () ) in
     begin
     (__retres_3 :=
      (Unsafe_int32.(-) 
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 18 11 16#
       "expl:Integer cast"
       (Unsafe_int32.of_int 
        (if
        (#"whole_program.jc" 2182 68 152#
        (Unsafe_int32.(>)  x
         (#"whole_program.jc" 2183 68 80# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) )) then (1) else (0)) ))
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 18 21 26#
       "expl:Integer cast"
       (Unsafe_int32.of_int 
        (if
        (#"whole_program.jc" 2184 69 153#
        (Unsafe_int32.(<)  x
         (#"whole_program.jc" 2185 68 80# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) )) then (1) else (0)) )) ));
      begin (return := !__retres_3); (raise Return) end end); absurd  end
    with Return -> !return end)
  
end

theory Axiomatic_Sum

  use import int.Int 
  
  use why3.Bool.Bool 
  
  function sum int int : int
  
  axiom Sum_init #"/home/work/workspace/education/acsl-exam/./sum.c" 5 7 76#
  "expl:Axiom sum_init" :
  (#"/home/work/workspace/education/acsl-exam/./sum.c" 5 7 76#
  (forall a_10_0 : int.
   (forall b_17 : int.
    ((((>=) a_10_0 (0)) /\ (((>=) b_17 (0)) /\ ((<=) b_17 a_10_0))) ->
     ((=) (sum a_10_0 b_17) a_10_0)))))
  
  axiom Sum_step_dec
  #"/home/work/workspace/education/acsl-exam/./sum.c" 8 7 91#
  "expl:Axiom sum_step_dec" :
  (#"/home/work/workspace/education/acsl-exam/./sum.c" 8 7 91#
  (forall a_11_0 : int.
   (forall b_18 : int.
    ((((>=) a_11_0 (0)) /\ (((>=) b_18 (0)) /\ ((>) b_18 a_11_0))) ->
     ((=) (sum a_11_0 b_18) (Int.(+) (sum a_11_0 (Int.(-) b_18 (1))) b_18))))))
  
  lemma Sum_lower_bound
  #"/home/work/workspace/education/acsl-exam/./sum.c" 11 7 64#
  "expl:Lemma sum_lower_bound" :
  (#"/home/work/workspace/education/acsl-exam/./sum.c" 11 7 64#
  (forall a_12_0 : int.
   (forall b_19 : int.
    ((((>=) a_12_0 (0)) /\ ((>=) b_19 (0))) ->
     ((>=) (sum a_12_0 b_19) a_12_0)))))
  
  lemma Sum_increases
  #"/home/work/workspace/education/acsl-exam/./sum.c" 14 7 101#
  "expl:Lemma sum_increases" :
  (#"/home/work/workspace/education/acsl-exam/./sum.c" 14 7 101#
  (forall i_45 : int.
   (forall a_13_0 : int.
    (forall b_20 : int.
     ((((>=) a_13_0 (0)) /\
      (((>=) b_20 (0)) /\
      (((>) b_20 a_13_0) /\ (((<=) a_13_0 i_45) /\ ((<=) i_45 b_20))))) ->
      ((<=) (sum a_13_0 i_45) (sum a_13_0 b_20)))))))
  
end

module Function_sum_0_safety

  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_Sum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let sum_0 #"/home/work/workspace/education/acsl-exam/./sum.c" 26 4 21#
  "expl:Function sum, safety" =
  fun (a_16 : Int32.t) (b_4 : Int32.t) 
   requires {
   (#"whole_program.jc" 2224 12 242#
   ((#"/home/work/workspace/education/acsl-exam/./sum.c" 20 13 18#
    (Int32.(<) a_16 b_4))
   /\
   (#"whole_program.jc" 2224 12 242#
   ((#"/home/work/workspace/education/acsl-exam/./sum.c" 21 13 19#
    (Int32.(>=) a_16 (#"whole_program.jc" 2225 44 56# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 2224 12 242#
   ((#"/home/work/workspace/education/acsl-exam/./sum.c" 21 23 29#
    (Int32.(>=) b_4 (#"whole_program.jc" 2226 44 56# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./sum.c" 22 13 30#
   ((<) (sum (Int32.to_int a_16) (Int32.to_int b_4)) (32767))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_int32.any_  () ) in
   try
    begin
    (let i_18_0 = ref (Safe_int32.any_  () ) in
    (let sum_0_1 = ref (Safe_int32.any_  () ) in
    try
     begin
     (sum_0_1 :=
      (let _jessie_719 = a_16 in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./sum.c" 29 3 6#
      "expl:Pointer index bounds" true) }); _jessie_719 end));
      begin
      (i_18_0 :=
       (let _jessie_716 =
       (Safe_int32.(+)  a_16
        (#"whole_program.jc" 2239 53 65# "expl:Integer cast"
        (Safe_int32.of_int (1))) ) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./sum.c" 36 7 16#
       "expl:Pointer index bounds" true) }); _jessie_716 end));
       'Loop_47:
       loop
       invariant { (#"whole_program.jc" 2241 6 758# true) }
         variant {
           (#"/home/work/workspace/education/acsl-exam/./sum.c" 34 20 25#
           (Int.(-) (Int32.to_int b_4) (Int32.to_int !i_18_0))) }
        begin
        any unit
        requires { true } reads { a_16, b_4 }
        ensures {
          ((#"/home/work/workspace/education/acsl-exam/./sum.c" 32 22 42#
           ((=) (Int32.to_int !sum_0_1)
           (sum (Int32.to_int a_16) (Int.(-) (Int32.to_int !i_18_0) (1)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./sum.c" 31 22 36#
          (#"/home/work/workspace/education/acsl-exam/./sum.c" 31 22 36#
          ((#"/home/work/workspace/education/acsl-exam/./sum.c" 31 22 27#
           (Int32.(<) a_16 !i_18_0))
          /\
          (#"/home/work/workspace/education/acsl-exam/./sum.c" 31 26 36#
          ((<=) (Int32.to_int !i_18_0) (Int.(+) (Int32.to_int b_4) (1))))))))
          } ;
         try
          begin
          begin
          (if
          (#"/home/work/workspace/education/acsl-exam/./sum.c" 36 18 24#
          (Safe_int32.(<=)  !i_18_0 b_4 )) then ()
          else (raise (Goto_while_0_break_exc ())));
           begin
           (sum_0_1 :=
            (let _jessie_717 = (Safe_int32.(+)  !sum_0_1 !i_18_0 ) in
            begin
            (assert {
            (#"/home/work/workspace/education/acsl-exam/./sum.c" 37 6 14#
            "expl:Pointer index bounds" true) }); _jessie_717 end));
            (i_18_0 :=
             (let _jessie_718 =
             (Safe_int32.(+)  !i_18_0
              (#"whole_program.jc" 2255 59 71# "expl:Integer cast"
              (Safe_int32.of_int (1))) ) in
             begin
             (assert {
             (#"/home/work/workspace/education/acsl-exam/./sum.c" 36 26 29#
             "expl:Pointer index bounds" true) }); _jessie_718 end)) end end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_65 -> () end end end; (raise (Goto_while_0_break_exc ()))
      end end with Goto_while_0_break_exc _jessie_63 ->
     'While_0_break:
     'While_0_break:
     begin
     ();
      begin
      (return :=
       (let _jessie_720 = !sum_0_1 in
       begin
       (assert {
       (#"whole_program.jc" 2260 7 21# "expl:Pointer index bounds" true) });
        _jessie_720 end)); (raise Return) end end end)); absurd  end with
    Return -> !return end)
  
end

module Function_sum_0_behaviors

  use Unsafe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_return 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_Sum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  let sum_ensures_default
  #"/home/work/workspace/education/acsl-exam/./sum.c" 26 4 21#
  "expl:Function sum, default behavior" =
  fun (a_16 : Int32.t) (b_4 : Int32.t) 
   requires {
   (#"whole_program.jc" 2224 12 242#
   ((#"/home/work/workspace/education/acsl-exam/./sum.c" 20 13 18#
    (Int32.(<) a_16 b_4))
   /\
   (#"whole_program.jc" 2224 12 242#
   ((#"/home/work/workspace/education/acsl-exam/./sum.c" 21 13 19#
    (Int32.(>=) a_16 (#"whole_program.jc" 2225 44 56# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"whole_program.jc" 2224 12 242#
   ((#"/home/work/workspace/education/acsl-exam/./sum.c" 21 23 29#
    (Int32.(>=) b_4 (#"whole_program.jc" 2226 44 56# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./sum.c" 22 13 30#
   ((<) (sum (Int32.to_int a_16) (Int32.to_int b_4)) (32767))))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/./sum.c" 24 12 32#
     "expl:Ensures clause"
     ((=) (Int32.to_int result) (sum (Int32.to_int a_16) (Int32.to_int b_4)))))
     } diverges  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (let i_18_0 = ref (Unsafe_int32.any_  () ) in
    (let sum_0_1 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (sum_0_1 := a_16);
      begin
      (i_18_0 :=
       (Unsafe_int32.(+)  a_16
        (#"whole_program.jc" 2239 53 65# "expl:Integer cast"
        (Unsafe_int32.of_int (1))) ));
       'Loop_46:
       loop
       invariant
         { ((#"/home/work/workspace/education/acsl-exam/./sum.c" 31 22 36#
            (#"/home/work/workspace/education/acsl-exam/./sum.c" 31 22 36#
            ((#"/home/work/workspace/education/acsl-exam/./sum.c" 31 22 27#
             (Int32.(<) a_16 !i_18_0))
            /\
            (#"/home/work/workspace/education/acsl-exam/./sum.c" 31 26 36#
            ((<=) (Int32.to_int !i_18_0) (Int.(+) (Int32.to_int b_4) (1)))))))
           &&
           (#"/home/work/workspace/education/acsl-exam/./sum.c" 32 22 42#
           ((=) (Int32.to_int !sum_0_1)
           (sum (Int32.to_int a_16) (Int.(-) (Int32.to_int !i_18_0) (1)))))) }
         
        begin
        any unit requires { true } ensures { true } ;
         try
          begin
          begin
          (if
          (#"/home/work/workspace/education/acsl-exam/./sum.c" 36 18 24#
          (Unsafe_int32.(<=)  !i_18_0 b_4 )) then ()
          else (raise (Goto_while_0_break_exc ())));
           begin
           (sum_0_1 := (Unsafe_int32.(+)  !sum_0_1 !i_18_0 ));
            (i_18_0 :=
             (Unsafe_int32.(+)  !i_18_0
              (#"whole_program.jc" 2255 59 71# "expl:Integer cast"
              (Unsafe_int32.of_int (1))) )) end end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_65 -> () end end end; (raise (Goto_while_0_break_exc ()))
      end end with Goto_while_0_break_exc _jessie_63 ->
     'While_0_break:
     'While_0_break:
     begin (); begin (return := !sum_0_1); (raise Return) end end end));
     absurd  end with Return -> !return end)
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_charP

  use import Struct_voidP 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

module Struct_intP_unsafe

  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_intP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_intP p (old !voidP_alloc_table) !voidP_alloc_table)
      /\ (fresh_alloc_struct_intP p !voidP_alloc_table))) }
  
  val allocate_struct_intP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_intP result (old !voidP_tag_table)) /\
       ((typeof_struct_intP result (0) n !voidP_tag_table) /\
       (container_of_struct_intP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_intP_safe

  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_intP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_intP p (old !voidP_alloc_table) !voidP_alloc_table)
      /\ (fresh_alloc_struct_intP p !voidP_alloc_table))) }
  
  val allocate_struct_intP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_intP result (old !voidP_tag_table)) /\
       ((typeof_struct_intP result (0) n !voidP_tag_table) /\
       (container_of_struct_intP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_intP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_intP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_intP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_intP result (old !voidP_tag_table) !voidP_tag_table)
      /\
      ((fresh_alloc_struct_intP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_intP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_intP result !voidP_tag_table) /\
      (container_of_singleton_struct_intP result !voidP_tag_table))))))) }
  
end

theory Struct_int_xP

  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function int_xP_tag  : (tag_id int_xP)
  
  axiom Int_xP_parenttag_bottom :
  (parenttag int_xP_tag bottom_tag)
  
  axiom Int_xP_is_final :
  (forall int_xP_tag_table : (tag_table int_xP).
   (forall p : (pointer int_xP).
    ((instanceof int_xP_tag_table p int_xP_tag) ->
     ((=) (typeof int_xP_tag_table p) int_xP_tag))))
  
  predicate frame_tag_struct_int_xP (p : (pointer int_xP))
  (old_int_xP_tag_table : (tag_table int_xP)) (int_xP_tag_table : (tag_table
  int_xP))
  =
     ((tag_extends old_int_xP_tag_table int_xP_tag_table) /\
     (alloc_tag_block old_int_xP_tag_table int_xP_tag_table p))
  
  predicate frame_free_struct_int_xP (p : (pointer int_xP))
  (old_int_xP_alloc_table : (alloc_table int_xP)) (int_xP_alloc_table :
  (alloc_table int_xP))
  =
     ((free_extends old_int_xP_alloc_table int_xP_alloc_table) /\
     (free_block old_int_xP_alloc_table int_xP_alloc_table p))
  
  predicate frame_alloc_struct_int_xP (p : (pointer int_xP)) (n : int)
  (old_int_xP_alloc_table : (alloc_table int_xP)) (int_xP_alloc_table :
  (alloc_table int_xP))
  =
     ((alloc_extends old_int_xP_alloc_table int_xP_alloc_table) /\
     (alloc_block old_int_xP_alloc_table int_xP_alloc_table p n))
  
  predicate fresh_tag_struct_int_xP (p : (pointer int_xP)) (int_xP_tag_table
  : (tag_table int_xP)) = (tag_fresh int_xP_tag_table p)
  
  predicate fresh_alloc_struct_int_xP (p : (pointer int_xP))
  (int_xP_alloc_table : (alloc_table int_xP))
  = (alloc_fresh int_xP_alloc_table p)
  
  predicate container_of_singleton_struct_int_xP (p : (pointer int_xP))
  (int_xP_tag_table : (tag_table int_xP)) = true
  
  predicate container_of_struct_int_xP (p : (pointer int_xP)) (l : int) (r :
  int) (int_xP_tag_table : (tag_table int_xP)) = true
  
  predicate typeof_singleton_struct_int_xP (p : (pointer int_xP))
  (int_xP_tag_table : (tag_table int_xP))
  = ((=) (typeof int_xP_tag_table p) int_xP_tag)
  
  predicate typeof_struct_int_xP (p : (pointer int_xP)) (l : int) (r : int)
  (int_xP_tag_table : (tag_table int_xP))
  =
     (((=) (typeof int_xP_tag_table p) int_xP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof int_xP_tag_table (shift p i)) int_xP_tag))))
  
  predicate instanceof_singleton_struct_int_xP (p : (pointer int_xP))
  (int_xP_tag_table : (tag_table int_xP))
  = (instanceof int_xP_tag_table p int_xP_tag)
  
  predicate instanceof_struct_int_xP (p : (pointer int_xP)) (l : int) (r :
  int) (int_xP_tag_table : (tag_table int_xP))
  =
     ((instanceof int_xP_tag_table p int_xP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof int_xP_tag_table (shift p i) int_xP_tag))))
  
  predicate right_valid_struct_int_xP (p : (pointer int_xP)) (b : int)
  (int_xP_alloc_table : (alloc_table int_xP))
  = ((>=) (offset_max int_xP_alloc_table p) b)
  
  predicate left_valid_struct_int_xP (p : (pointer int_xP)) (a : int)
  (int_xP_alloc_table : (alloc_table int_xP))
  = ((<=) (offset_min int_xP_alloc_table p) a)
  
  predicate valid_struct_int_xP (p : (pointer int_xP)) (a : int) (b : int)
  (int_xP_alloc_table : (alloc_table int_xP))
  =
     (((<=) (offset_min int_xP_alloc_table p) a) /\
     ((>=) (offset_max int_xP_alloc_table p) b))
  
  predicate strict_valid_struct_int_xP (p : (pointer int_xP)) (a : int) (b :
  int) (int_xP_alloc_table : (alloc_table int_xP))
  =
     (((=) (offset_min int_xP_alloc_table p) a) /\
     ((=) (offset_max int_xP_alloc_table p) b))
  
  axiom Int_xP_int : ((=) (int_of_tag int_xP_tag) (5))
  
end

module Struct_int_xP_unsafe

  use import Struct_int_xP 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_int_xP
  (p : (pointer int_xP)) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !int_xP_alloc_table p)) }
    writes { int_xP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !int_xP_alloc_table (old !int_xP_alloc_table)))
      \/
      ((frame_free_struct_int_xP p (old !int_xP_alloc_table)
       !int_xP_alloc_table)
      /\ (fresh_alloc_struct_int_xP p !int_xP_alloc_table))) }
  
  val allocate_struct_int_xP_requires
  (n : int) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) 
    (int_xP_tag_table : ref (tag_table int_xP)) : (pointer int_xP)
     requires { ((>=) n (0)) } writes { int_xP_alloc_table, int_xP_tag_table
     }
     ensures {
       ((strict_valid_struct_int_xP result (0) (Int.(-) n (1))
        !int_xP_alloc_table)
       /\
       ((frame_alloc_struct_int_xP result n (old !int_xP_alloc_table)
        !int_xP_alloc_table)
       /\
       ((frame_tag_struct_int_xP result (old !int_xP_tag_table)
        !int_xP_tag_table)
       /\
       ((fresh_alloc_struct_int_xP result (old !int_xP_alloc_table)) /\
       ((fresh_tag_struct_int_xP result (old !int_xP_tag_table)) /\
       ((typeof_struct_int_xP result (0) n !int_xP_tag_table) /\
       (container_of_struct_int_xP result (0) n !int_xP_tag_table))))))) }
  
end

module Struct_int_xP_safe

  use import Struct_int_xP 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_int_xP
  (p : (pointer int_xP)) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) : unit
    requires { true } writes { int_xP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !int_xP_alloc_table (old !int_xP_alloc_table)))
      \/
      ((frame_free_struct_int_xP p (old !int_xP_alloc_table)
       !int_xP_alloc_table)
      /\ (fresh_alloc_struct_int_xP p !int_xP_alloc_table))) }
  
  val allocate_struct_int_xP
  (n : int) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) 
    (int_xP_tag_table : ref (tag_table int_xP)) : (pointer int_xP)
     requires { true } writes { int_xP_alloc_table, int_xP_tag_table }
     ensures {
       ((strict_valid_struct_int_xP result (0) (Int.(-) n (1))
        !int_xP_alloc_table)
       /\
       ((frame_alloc_struct_int_xP result n (old !int_xP_alloc_table)
        !int_xP_alloc_table)
       /\
       ((frame_tag_struct_int_xP result (old !int_xP_tag_table)
        !int_xP_tag_table)
       /\
       ((fresh_alloc_struct_int_xP result (old !int_xP_alloc_table)) /\
       ((fresh_tag_struct_int_xP result (old !int_xP_tag_table)) /\
       ((typeof_struct_int_xP result (0) n !int_xP_tag_table) /\
       (container_of_struct_int_xP result (0) n !int_xP_tag_table))))))) }
  
  val allocate_singleton_struct_int_xP
  (int_xP_alloc_table : ref (alloc_table int_xP)) 
   (int_xP_tag_table : ref (tag_table int_xP)) : (pointer int_xP)
    requires { true } writes { int_xP_alloc_table, int_xP_tag_table }
    ensures {
      ((strict_valid_struct_int_xP result (0) (0) !int_xP_alloc_table) /\
      ((frame_alloc_struct_int_xP result (1) (old !int_xP_alloc_table)
       !int_xP_alloc_table)
      /\
      ((frame_tag_struct_int_xP result (old !int_xP_tag_table)
       !int_xP_tag_table)
      /\
      ((fresh_alloc_struct_int_xP result (old !int_xP_alloc_table)) /\
      ((fresh_tag_struct_int_xP result (old !int_xP_tag_table)) /\
      ((typeof_singleton_struct_int_xP result !int_xP_tag_table) /\
      (container_of_singleton_struct_int_xP result !int_xP_tag_table))))))) }
  
end

theory Root_unsigned_charP

  use why3.Bool.Bool 
  
  type unsigned_charP 
  
end

theory Struct_unsigned_charP

  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function unsigned_charP_tag  : (tag_id
  unsigned_charP)
  
  axiom Unsigned_charP_parenttag_bottom :
  (parenttag unsigned_charP_tag bottom_tag)
  
  axiom Unsigned_charP_is_final :
  (forall unsigned_charP_tag_table : (tag_table unsigned_charP).
   (forall p : (pointer unsigned_charP).
    ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) ->
     ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag))))
  
  predicate frame_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_tag_table : (tag_table unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((tag_extends old_unsigned_charP_tag_table unsigned_charP_tag_table) /\
     (alloc_tag_block old_unsigned_charP_tag_table unsigned_charP_tag_table
     p))
  
  predicate frame_free_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((free_extends old_unsigned_charP_alloc_table unsigned_charP_alloc_table)
     /\
     (free_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p))
  
  predicate frame_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (n : int) (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((alloc_extends old_unsigned_charP_alloc_table
      unsigned_charP_alloc_table)
     /\
     (alloc_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p
     n))
  
  predicate fresh_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (tag_fresh unsigned_charP_tag_table p)
  
  predicate fresh_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = (alloc_fresh unsigned_charP_alloc_table p)
  
  predicate container_of_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate container_of_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate typeof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag)
  
  predicate typeof_struct_unsigned_charP (p : (pointer unsigned_charP)) (l :
  int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     (((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof unsigned_charP_tag_table (shift p i)) unsigned_charP_tag))))
  
  predicate instanceof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (instanceof unsigned_charP_tag_table p unsigned_charP_tag)
  
  predicate instanceof_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof unsigned_charP_tag_table (shift p i) unsigned_charP_tag))))
  
  predicate right_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((>=) (offset_max unsigned_charP_alloc_table p) b)
  
  predicate left_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((<=) (offset_min unsigned_charP_alloc_table p) a)
  
  predicate valid_struct_unsigned_charP (p : (pointer unsigned_charP)) (a :
  int) (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     (((<=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((>=) (offset_max unsigned_charP_alloc_table p) b))
  
  predicate strict_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (b : int) (unsigned_charP_alloc_table : (alloc_table
  unsigned_charP))
  =
     (((=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((=) (offset_max unsigned_charP_alloc_table p) b))
  
  axiom Unsigned_charP_int : ((=) (int_of_tag unsigned_charP_tag) (6))
  
end

module Struct_unsigned_charP_unsafe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !unsigned_charP_alloc_table p)) }
    writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP_requires
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { ((>=) n (0)) } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
end

module Struct_unsigned_charP_safe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires { true } writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { true } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
  val allocate_singleton_struct_unsigned_charP
  (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
   (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
    unsigned_charP)
    requires { true } writes { unsigned_charP_alloc_table,
    unsigned_charP_tag_table }
    ensures {
      ((strict_valid_struct_unsigned_charP result (0) (0)
       !unsigned_charP_alloc_table)
      /\
      ((frame_alloc_struct_unsigned_charP result (1) (old
       !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
      /\
      ((frame_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table) !unsigned_charP_tag_table)
      /\
      ((fresh_alloc_struct_unsigned_charP result (old
       !unsigned_charP_alloc_table))
      /\
      ((fresh_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table))
      /\
      ((typeof_singleton_struct_unsigned_charP result
       !unsigned_charP_tag_table)
      /\
      (container_of_singleton_struct_unsigned_charP result
      !unsigned_charP_tag_table))))))) }
  
end

module Struct_unsigned_intP_unsafe

  use import Struct_unsigned_intP 
  
  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_unsigned_intP
  (p : (pointer unsigned_intP)) 
   (unsigned_intP_alloc_table : ref (alloc_table unsigned_intP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !unsigned_intP_alloc_table p)) }
    writes { unsigned_intP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_intP_alloc_table (old !unsigned_intP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_intP p (old !unsigned_intP_alloc_table)
       !unsigned_intP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_intP p !unsigned_intP_alloc_table))) }
  
  val allocate_struct_unsigned_intP_requires
  (n : int) 
   (unsigned_intP_alloc_table : ref (alloc_table unsigned_intP)) 
    (unsigned_intP_tag_table : ref (tag_table unsigned_intP)) : (pointer
     unsigned_intP)
     requires { ((>=) n (0)) } writes { unsigned_intP_alloc_table,
     unsigned_intP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_intP result (0) (Int.(-) n (1))
        !unsigned_intP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_intP result n (old
        !unsigned_intP_alloc_table) !unsigned_intP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_intP result (old !unsigned_intP_tag_table)
        !unsigned_intP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_intP result (old
        !unsigned_intP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_intP result (old
        !unsigned_intP_tag_table))
       /\
       ((typeof_struct_unsigned_intP result (0) n !unsigned_intP_tag_table)
       /\
       (container_of_struct_unsigned_intP result (0) n
       !unsigned_intP_tag_table))))))) }
  
end

module Struct_unsigned_intP_safe

  use import Struct_unsigned_intP 
  
  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_unsigned_intP
  (p : (pointer unsigned_intP)) 
   (unsigned_intP_alloc_table : ref (alloc_table unsigned_intP)) : unit
    requires { true } writes { unsigned_intP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_intP_alloc_table (old !unsigned_intP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_intP p (old !unsigned_intP_alloc_table)
       !unsigned_intP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_intP p !unsigned_intP_alloc_table))) }
  
  val allocate_struct_unsigned_intP
  (n : int) 
   (unsigned_intP_alloc_table : ref (alloc_table unsigned_intP)) 
    (unsigned_intP_tag_table : ref (tag_table unsigned_intP)) : (pointer
     unsigned_intP)
     requires { true } writes { unsigned_intP_alloc_table,
     unsigned_intP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_intP result (0) (Int.(-) n (1))
        !unsigned_intP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_intP result n (old
        !unsigned_intP_alloc_table) !unsigned_intP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_intP result (old !unsigned_intP_tag_table)
        !unsigned_intP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_intP result (old
        !unsigned_intP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_intP result (old
        !unsigned_intP_tag_table))
       /\
       ((typeof_struct_unsigned_intP result (0) n !unsigned_intP_tag_table)
       /\
       (container_of_struct_unsigned_intP result (0) n
       !unsigned_intP_tag_table))))))) }
  
  val allocate_singleton_struct_unsigned_intP
  (unsigned_intP_alloc_table : ref (alloc_table unsigned_intP)) 
   (unsigned_intP_tag_table : ref (tag_table unsigned_intP)) : (pointer
    unsigned_intP)
    requires { true } writes { unsigned_intP_alloc_table,
    unsigned_intP_tag_table }
    ensures {
      ((strict_valid_struct_unsigned_intP result (0) (0)
       !unsigned_intP_alloc_table)
      /\
      ((frame_alloc_struct_unsigned_intP result (1) (old
       !unsigned_intP_alloc_table) !unsigned_intP_alloc_table)
      /\
      ((frame_tag_struct_unsigned_intP result (old !unsigned_intP_tag_table)
       !unsigned_intP_tag_table)
      /\
      ((fresh_alloc_struct_unsigned_intP result (old
       !unsigned_intP_alloc_table))
      /\
      ((fresh_tag_struct_unsigned_intP result (old !unsigned_intP_tag_table))
      /\
      ((typeof_singleton_struct_unsigned_intP result
       !unsigned_intP_tag_table)
      /\
      (container_of_singleton_struct_unsigned_intP result
      !unsigned_intP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

theory Axiomatic_Jessie_memory_reinterpretation_predicates

  use Uint8_of_Int8 
  
  use enum.Uint8 
  
  use Uint32_of_Int32 
  
  use enum.Uint32 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use enum.Bit_uint8_of_bit_uint32 
  
  use enum.Bit_uint8_of_bit_int32 
  
  use enum.Bit_uint32_of_bit_uint8 
  
  use enum.Bit_int8_of_bit_int32 
  
  use enum.Bit_int32_of_bit_uint8 
  
  use enum.Bit_int32_of_bit_int8 
  
  use why3.Bool.Bool 
  
  predicate uint8_as_uint32 (d0 : Uint32.t) (a0 : Uint8.t) (a1 : Uint8.t) (a2
  : Uint8.t) (a3 : Uint8.t)
  =
     (((=) (Uint32.to_int d0)
      (Int.(+)
      (Int.( *)
      (Int.(+)
      (Int.( *)
      (Int.(+) (Int.( *) (Uint8.to_int a3) (256)) (Uint8.to_int a2)) (256))
      (Uint8.to_int a1)) (256)) (Uint8.to_int a0)))
     /\ (Bit_uint32_of_bit_uint8.bit_uint8_as_bit_uint32 d0 a0 a1 a2 a3))
  
  function complement_to_uint32 (v : Int32.t) : Uint32.t
  =
     (if ((>=) (Int32.to_int v) (0)) then (#"whole_program.jc" 15 20 33#
      "expl:Integer cast" (Uint32_of_Int32.cast v)) else
      (#"whole_program.jc" 15 39 80# "expl:Integer cast"
      (Uint32.of_int (Int.(+) (Int32.to_int v) (4294967296)))))
  
  predicate uint8_as_int32 (d0_0 : Int32.t) (a3_0 : Uint8.t) (a2_0 : Uint8.t)
  (a1_0 : Uint8.t) (a0_0 : Uint8.t)
  =
     ((uint8_as_uint32 (complement_to_uint32 d0_0) a3_0 a2_0 a1_0 a0_0) /\
     (Bit_int32_of_bit_uint8.bit_uint8_as_bit_int32 d0_0 a3_0 a2_0 a1_0 a0_0))
  
  predicate uint32_as_uint8 (d0_1 : Uint32.t) (a0_1 : Uint8.t) (a1_1 :
  Uint8.t) (a2_1 : Uint8.t) (a3_1 : Uint8.t)
  =
     (((=) (Uint8.to_int a0_1)
      (ComputerDivision.mod (Uint32.to_int d0_1) (256)))
     /\
     ((let d1 = (ComputerDivision.div (Uint32.to_int d0_1) (256)) in
       (((=) (Uint8.to_int a1_1) (ComputerDivision.mod d1 (256))) /\
       (let d2 = (ComputerDivision.div d1 (256)) in
        (((=) (Uint8.to_int a2_1) (ComputerDivision.mod d2 (256))) /\
        (let d3 = (ComputerDivision.div d2 (256)) in
         ((=) (Uint8.to_int a3_1) d3))))))
     /\
     (Bit_uint8_of_bit_uint32.bit_uint32_as_bit_uint8 d0_1 a0_1 a1_1 a2_1
     a3_1)))
  
  predicate int32_as_uint8 (d0_2 : Int32.t) (a3_2 : Uint8.t) (a2_2 : Uint8.t)
  (a1_2 : Uint8.t) (a0_2 : Uint8.t)
  =
     ((uint32_as_uint8 (complement_to_uint32 d0_2) a3_2 a2_2 a1_2 a0_2) /\
     (Bit_uint8_of_bit_int32.bit_int32_as_bit_uint8 d0_2 a3_2 a2_2 a1_2 a0_2))
  
  function complement_to_uint8 (v_0 : Int8.t) : Uint8.t
  =
     (if ((>=) (Int8.to_int v_0) (0)) then (#"whole_program.jc" 34 20 32#
      "expl:Integer cast" (Uint8_of_Int8.cast v_0)) else
      (#"whole_program.jc" 34 38 71# "expl:Integer cast"
      (Uint8.of_int (Int.(+) (Int8.to_int v_0) (256)))))
  
  predicate int8_as_int32 (d0_3 : Int32.t) (a3_3 : Int8.t) (a2_3 : Int8.t)
  (a1_3 : Int8.t) (a0_3 : Int8.t)
  =
     ((uint8_as_int32 d0_3 (complement_to_uint8 a3_3)
      (complement_to_uint8 a2_3) (complement_to_uint8 a1_3)
      (complement_to_uint8 a0_3))
     /\
     (Bit_int32_of_bit_int8.bit_int8_as_bit_int32 d0_3 a3_3 a2_3 a1_3 a0_3))
  
  predicate int32_as_int8 (d0_4 : Int32.t) (a3_4 : Int8.t) (a2_4 : Int8.t)
  (a1_4 : Int8.t) (a0_4 : Int8.t)
  =
     ((int32_as_uint8 d0_4 (complement_to_uint8 a3_4)
      (complement_to_uint8 a2_4) (complement_to_uint8 a1_4)
      (complement_to_uint8 a0_4))
     /\
     (Bit_int8_of_bit_int32.bit_int32_as_bit_int8 d0_4 a3_4 a2_4 a1_4 a0_4))
  
end

module Function_spec_abs2

  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val spec_abs2
  (a_15 : Int32.t) : Int32.t
   requires { true }
   ensures {
     (((Int32.(<) a_15 (#"whole_program.jc" 92 18 30# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 17 15 28#
       "expl:Ensures clause"
       ((=) (Int32.to_int result) (Int.(-_) (Int32.to_int a_15)))))
     /\
     (((Int32.(=) a_15 (#"whole_program.jc" 88 19 31# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 13 15 27#
       "expl:Ensures clause"
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 13 15 27#
       "expl:Ensures clause"
       ((#"/home/work/workspace/education/acsl-exam/./abs.c" 13 15 27#
        "expl:Ensures clause"
        (Int32.(=) result (#"whole_program.jc" 89 39 51# "expl:Integer cast"
        (Int32.of_int (0)))))
       /\
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 14 15 27#
       "expl:Ensures clause" (Int32.(=) result a_15))))))
     /\
     (((Int32.(>) a_15 (#"whole_program.jc" 85 18 30# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 10 15 27#
       "expl:Ensures clause" (Int32.(=) result a_15)))
     /\
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 7 12 24#
     "expl:Ensures clause"
     (Int32.(>=) result (#"whole_program.jc" 83 30 42# "expl:Integer cast"
     (Int32.of_int (0)))))))) }
  
end

module Function_spec_abs2_safe

  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val spec_abs2
  (a_15 : Int32.t) : Int32.t
   requires {
     ("expl:Internal"
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 5 13 28#
     "expl:Requires clause"
     ((<) (Int.(-_) (2147483648)) (Int32.to_int a_15)))) }
   ensures {
     (((Int32.(<) a_15 (#"whole_program.jc" 92 18 30# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 17 15 28#
       "expl:Ensures clause"
       ((=) (Int32.to_int result) (Int.(-_) (Int32.to_int a_15)))))
     /\
     (((Int32.(=) a_15 (#"whole_program.jc" 88 19 31# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 13 15 27#
       "expl:Ensures clause"
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 13 15 27#
       "expl:Ensures clause"
       ((#"/home/work/workspace/education/acsl-exam/./abs.c" 13 15 27#
        "expl:Ensures clause"
        (Int32.(=) result (#"whole_program.jc" 89 39 51# "expl:Integer cast"
        (Int32.of_int (0)))))
       /\
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 14 15 27#
       "expl:Ensures clause" (Int32.(=) result a_15))))))
     /\
     (((Int32.(>) a_15 (#"whole_program.jc" 85 18 30# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs.c" 10 15 27#
       "expl:Ensures clause" (Int32.(=) result a_15)))
     /\
     (#"/home/work/workspace/education/acsl-exam/./abs.c" 7 12 24#
     "expl:Ensures clause"
     (Int32.(>=) result (#"whole_program.jc" 83 30 42# "expl:Integer cast"
     (Int32.of_int (0)))))))) }
  
end

module Function_spec_abs1

  use Int64_of_Int32 
  
  use enum.Int64 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val spec_abs1
  (a_14 : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((Int32.(<) a_14 (#"whole_program.jc" 131 18 30# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 15 15 28#
       "expl:Ensures clause"
       ((=) (Int64.to_int result) (Int.(-_) (Int32.to_int a_14)))))
     /\
     (((Int32.(=) a_14 (#"whole_program.jc" 127 19 31# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 11 15 27#
       "expl:Ensures clause"
       (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 11 15 27#
       "expl:Ensures clause"
       ((#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 11 15 27#
        "expl:Ensures clause" ((=) (Int64.to_int result) (0)))
       /\
       (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 12 15 27#
       "expl:Ensures clause"
       (Int64.(=) result (#"whole_program.jc" 129 42 66# "expl:Integer cast"
       (Int64_of_Int32.cast a_14))))))))
     /\
     (((Int32.(>) a_14 (#"whole_program.jc" 124 18 30# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 8 15 27#
       "expl:Ensures clause"
       (Int64.(=) result (#"whole_program.jc" 125 31 55# "expl:Integer cast"
       (Int64_of_Int32.cast a_14)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 5 12 24#
     "expl:Ensures clause" ((>=) (Int64.to_int result) (0)))))) }
  
end

module Function_spec_abs1_safe

  use Int64_of_Int32 
  
  use enum.Int64 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val spec_abs1
  (a_14 : Int32.t) : Int64.t
   requires { (true) }
   ensures {
     (((Int32.(<) a_14 (#"whole_program.jc" 131 18 30# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 15 15 28#
       "expl:Ensures clause"
       ((=) (Int64.to_int result) (Int.(-_) (Int32.to_int a_14)))))
     /\
     (((Int32.(=) a_14 (#"whole_program.jc" 127 19 31# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 11 15 27#
       "expl:Ensures clause"
       (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 11 15 27#
       "expl:Ensures clause"
       ((#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 11 15 27#
        "expl:Ensures clause" ((=) (Int64.to_int result) (0)))
       /\
       (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 12 15 27#
       "expl:Ensures clause"
       (Int64.(=) result (#"whole_program.jc" 129 42 66# "expl:Integer cast"
       (Int64_of_Int32.cast a_14))))))))
     /\
     (((Int32.(>) a_14 (#"whole_program.jc" 124 18 30# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 8 15 27#
       "expl:Ensures clause"
       (Int64.(=) result (#"whole_program.jc" 125 31 55# "expl:Integer cast"
       (Int64_of_Int32.cast a_14)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./abs_impletentation.c" 5 12 24#
     "expl:Ensures clause" ((>=) (Int64.to_int result) (0)))))) }
  
end

module Function_array_average

  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use import Axiomatic_ASum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val array_average
  (a_0 : (pointer voidP)) 
   (size_0 : Int32.t) 
    (voidP_a_3_alloc_table : (alloc_table voidP)) 
     (voidP_a_3_tag_table : (tag_table voidP)) 
      (intP_intM_a_3 : (memory voidP Int32.t)) : Int32.t
       requires { true }
       ensures {
         (#"/home/work/workspace/education/acsl-exam/./array_average.c" 20 12 47#
         "expl:Ensures clause"
         ((=) (Int32.to_int result)
         (ComputerDivision.div
         (asum a_0 (Int.(-) (Int32.to_int size_0) (1)) intP_intM_a_3)
         (Int32.to_int size_0)))) }
  
end

module Function_array_average_safe

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use import Axiomatic_ASum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val array_average
  (a_0 : (pointer voidP)) 
   (size_0 : Int32.t) 
    (voidP_a_3_alloc_table : (alloc_table voidP)) 
     (voidP_a_3_tag_table : (tag_table voidP)) 
      (intP_intM_a_3 : (memory voidP Int32.t)) : Int32.t
       requires {
         ("expl:Internal"
         (#"whole_program.jc" 176 12 965# "expl:Requires clause"
         ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 16 13 21#
          "expl:Requires clause"
          (Int32.(>) size_0 (#"whole_program.jc" 176 31 43#
          "expl:Integer cast" (Int32.of_int (0)))))
         /\
         (#"whole_program.jc" 176 12 965# "expl:Requires clause"
         ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 17 13 34#
          "expl:Requires clause"
          (if ((<=) (0) (Int.(-) (Int32.to_int size_0) (1))) then
           (((<=) (offset_min voidP_a_3_alloc_table a_0) (0)) /\
           (((>=) (offset_max voidP_a_3_alloc_table a_0)
            (Int.(-) (Int32.to_int size_0) (1)))
           /\
           (forall __framac_tmp1 : int.
            ((((<=) (0) __framac_tmp1) /\
             ((<=) __framac_tmp1 (Int.(-) (Int32.to_int size_0) (1)))) ->
             ((=) true true))))) else ((=) true true)))
         /\
         (#"whole_program.jc" 176 12 965# "expl:Requires clause"
         ((#"/home/work/workspace/education/acsl-exam/./array_average.c" 18 13 43#
          "expl:Requires clause"
          ((<=) (Int.(-_) (2147483648))
          (asum a_0 (Int.(-) (Int32.to_int size_0) (1)) intP_intM_a_3)))
         /\
         (#"/home/work/workspace/education/acsl-exam/./array_average.c" 18 28 57#
         "expl:Requires clause"
         ((<=) (asum a_0 (Int.(-) (Int32.to_int size_0) (1)) intP_intM_a_3)
         (2147483647)))))))))) }
       ensures {
         (#"/home/work/workspace/education/acsl-exam/./array_average.c" 20 12 47#
         "expl:Ensures clause"
         ((=) (Int32.to_int result)
         (ComputerDivision.div
         (asum a_0 (Int.(-) (Int32.to_int size_0) (1)) intP_intM_a_3)
         (Int32.to_int size_0)))) }
  
end

module Function_array_sum_0

  use enum.Uint32 
  
  use import Root_unsigned_intP 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use import Axiomatic_Array_Sum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val array_sum_0
  (a_0_0 : (pointer unsigned_intP)) 
   (n_1 : Uint32.t) 
    (unsigned_intP_a_0_5_alloc_table : (alloc_table unsigned_intP)) 
     (unsigned_intP_a_0_5_tag_table : (tag_table unsigned_intP)) 
      (unsigned_intP_unsigned_intM_a_0_5 : (memory unsigned_intP Uint32.t)) :
       Uint32.t
       requires { true }
       ensures {
         (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 23 12 40#
         "expl:Ensures clause"
         ((=) (Uint32.to_int result)
         (array_sum a_0_0 (Int.(-) (Uint32.to_int n_1) (1))
         unsigned_intP_unsigned_intM_a_0_5))) }
  
end

module Function_array_sum_0_safe

  use enum.Uint32 
  
  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use import Axiomatic_Array_Sum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val array_sum_0
  (a_0_0 : (pointer unsigned_intP)) 
   (n_1 : Uint32.t) 
    (unsigned_intP_a_0_5_alloc_table : (alloc_table unsigned_intP)) 
     (unsigned_intP_a_0_5_tag_table : (tag_table unsigned_intP)) 
      (unsigned_intP_unsigned_intM_a_0_5 : (memory unsigned_intP Uint32.t)) :
       Uint32.t
       requires {
         ("expl:Internal"
         (#"whole_program.jc" 264 12 695# "expl:Requires clause"
         ((#"/home/work/workspace/education/acsl-exam/./array_sum.c" 20 13 31#
          "expl:Requires clause"
          (if ((<=) (0) (Int.(-) (Uint32.to_int n_1) (1))) then
           (((<=) (offset_min unsigned_intP_a_0_5_alloc_table a_0_0) (0)) /\
           (((>=) (offset_max unsigned_intP_a_0_5_alloc_table a_0_0)
            (Int.(-) (Uint32.to_int n_1) (1)))
           /\
           (forall __framac_tmp2 : int.
            ((((<=) (0) __framac_tmp2) /\
             ((<=) __framac_tmp2 (Int.(-) (Uint32.to_int n_1) (1)))) ->
             ((=) true true))))) else ((=) true true)))
         /\
         (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 21 13 36#
         "expl:Requires clause"
         ((<)
         (array_sum a_0_0 (Uint32.to_int n_1)
         unsigned_intP_unsigned_intM_a_0_5) (32767)))))) }
       ensures {
         (#"/home/work/workspace/education/acsl-exam/./array_sum.c" 23 12 40#
         "expl:Ensures clause"
         ((=) (Uint32.to_int result)
         (array_sum a_0_0 (Int.(-) (Uint32.to_int n_1) (1))
         unsigned_intP_unsigned_intM_a_0_5))) }
  
end

module Function_arrays_average

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val arrays_average
  (result_0 : (pointer voidP)) 
   (a_1 : (pointer voidP)) 
    (b_0 : (pointer voidP)) 
     (size_1 : Int32.t) 
      (intP_intM_result_6 : ref (memory voidP Int32.t)) 
       (voidP_b_8_alloc_table : (alloc_table voidP)) 
        (voidP_a_1_7_alloc_table : (alloc_table voidP)) 
         (voidP_result_6_alloc_table : (alloc_table voidP)) 
          (voidP_b_8_tag_table : (tag_table voidP)) 
           (voidP_a_1_7_tag_table : (tag_table voidP)) 
            (voidP_result_6_tag_table : (tag_table voidP)) 
             (intP_intM_b_8 : (memory voidP Int32.t)) 
              (intP_intM_a_1_7 : (memory voidP Int32.t)) : unit
               requires { true } reads { intP_intM_result_6 } writes {
               intP_intM_result_6 }
               ensures {
                 ((#"whole_program.jc" 354 10 56# "expl:Assigns clause"
                  (not_assigns voidP_result_6_alloc_table
                  voidP_result_6_alloc_table (old !intP_intM_result_6)
                  !intP_intM_result_6
                  (pset_range (pset_singleton result_0) (0)
                  (Int.(-) (Int32.to_int size_1) (1)))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 10 12 79#
                 "expl:Ensures clause"
                 (forall i_3_0 : int.
                  ((((<=) (0) i_3_0) /\ ((<) i_3_0 (Int32.to_int size_1))) ->
                   ((=)
                   (Int32.to_int
                   (select !intP_intM_result_6 (shift result_0 i_3_0)))
                   (ComputerDivision.div
                   (Int.(+)
                   (Int32.to_int (select intP_intM_a_1_7 (shift a_1 i_3_0)))
                   (Int32.to_int (select intP_intM_b_8 (shift b_0 i_3_0))))
                   (2))))))) }
  
end

module Function_arrays_average_safe

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val arrays_average
  (result_0 : (pointer voidP)) 
   (a_1 : (pointer voidP)) 
    (b_0 : (pointer voidP)) 
     (size_1 : Int32.t) 
      (intP_intM_result_6 : ref (memory voidP Int32.t)) 
       (voidP_b_8_alloc_table : (alloc_table voidP)) 
        (voidP_a_1_7_alloc_table : (alloc_table voidP)) 
         (voidP_result_6_alloc_table : (alloc_table voidP)) 
          (voidP_b_8_tag_table : (tag_table voidP)) 
           (voidP_a_1_7_tag_table : (tag_table voidP)) 
            (voidP_result_6_tag_table : (tag_table voidP)) 
             (intP_intM_b_8 : (memory voidP Int32.t)) 
              (intP_intM_a_1_7 : (memory voidP Int32.t)) : unit
               requires {
                 ("expl:Internal"
                 (#"whole_program.jc" 314 12 2620# "expl:Requires clause"
                 ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 4 13 22#
                  "expl:Requires clause"
                  (Int32.(>=) size_1 (#"whole_program.jc" 314 33 45#
                  "expl:Integer cast" (Int32.of_int (0)))))
                 /\
                 (#"whole_program.jc" 314 12 2620# "expl:Requires clause"
                 ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 5 13 39#
                  "expl:Requires clause"
                  (if ((<=) (0) (Int.(-) (Int32.to_int size_1) (1))) then
                   (((<=) (offset_min voidP_result_6_alloc_table result_0)
                    (0))
                   /\
                   (((>=) (offset_max voidP_result_6_alloc_table result_0)
                    (Int.(-) (Int32.to_int size_1) (1)))
                   /\
                   (forall __framac_tmp3 : int.
                    ((((<=) (0) __framac_tmp3) /\
                     ((<=) __framac_tmp3 (Int.(-) (Int32.to_int size_1) (1))))
                     -> ((=) true true))))) else ((=) true true)))
                 /\
                 (#"whole_program.jc" 314 12 2620# "expl:Requires clause"
                 ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 6 13 34#
                  "expl:Requires clause"
                  (if ((<=) (0) (Int.(-) (Int32.to_int size_1) (1))) then
                   (((<=) (offset_min voidP_a_1_7_alloc_table a_1) (0)) /\
                   (((>=) (offset_max voidP_a_1_7_alloc_table a_1)
                    (Int.(-) (Int32.to_int size_1) (1)))
                   /\
                   (forall __framac_tmp4 : int.
                    ((((<=) (0) __framac_tmp4) /\
                     ((<=) __framac_tmp4 (Int.(-) (Int32.to_int size_1) (1))))
                     -> ((=) true true))))) else ((=) true true)))
                 /\
                 (#"whole_program.jc" 314 12 2620# "expl:Requires clause"
                 ((#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 7 13 34#
                  "expl:Requires clause"
                  (if ((<=) (0) (Int.(-) (Int32.to_int size_1) (1))) then
                   (((<=) (offset_min voidP_b_8_alloc_table b_0) (0)) /\
                   (((>=) (offset_max voidP_b_8_alloc_table b_0)
                    (Int.(-) (Int32.to_int size_1) (1)))
                   /\
                   (forall __framac_tmp5 : int.
                    ((((<=) (0) __framac_tmp5) /\
                     ((<=) __framac_tmp5 (Int.(-) (Int32.to_int size_1) (1))))
                     -> ((=) true true))))) else ((=) true true)))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 8 13 90#
                 "expl:Requires clause"
                 (forall i_2_0 : int.
                  ((((<=) (0) i_2_0) /\ ((<) i_2_0 (Int32.to_int size_1))) ->
                   (((<=) (Int.(-_) (2147483648))
                    (Int.(+)
                    (Int32.to_int (select intP_intM_a_1_7 (shift a_1 i_2_0)))
                    (Int32.to_int (select intP_intM_b_8 (shift b_0 i_2_0)))))
                   /\
                   ((<=)
                   (Int.(+)
                   (Int32.to_int (select intP_intM_a_1_7 (shift a_1 i_2_0)))
                   (Int32.to_int (select intP_intM_b_8 (shift b_0 i_2_0))))
                   (2147483647))))))))))))))) }
               reads { intP_intM_result_6 } writes { intP_intM_result_6 }
               ensures {
                 ((#"whole_program.jc" 354 10 56# "expl:Assigns clause"
                  (not_assigns voidP_result_6_alloc_table
                  voidP_result_6_alloc_table (old !intP_intM_result_6)
                  !intP_intM_result_6
                  (pset_range (pset_singleton result_0) (0)
                  (Int.(-) (Int32.to_int size_1) (1)))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./arrays_average.c" 10 12 79#
                 "expl:Ensures clause"
                 (forall i_3_0 : int.
                  ((((<=) (0) i_3_0) /\ ((<) i_3_0 (Int32.to_int size_1))) ->
                   ((=)
                   (Int32.to_int
                   (select !intP_intM_result_6 (shift result_0 i_3_0)))
                   (ComputerDivision.div
                   (Int.(+)
                   (Int32.to_int (select intP_intM_a_1_7 (shift a_1 i_3_0)))
                   (Int32.to_int (select intP_intM_b_8 (shift b_0 i_3_0))))
                   (2))))))) }
  
end

module Function_arrays_sum

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val arrays_sum
  (result_0_0 : (pointer voidP)) 
   (a_2_0 : (pointer voidP)) 
    (b_0_0 : (pointer voidP)) 
     (size_2 : Int32.t) 
      (intP_intM_result_0_9 : ref (memory voidP Int32.t)) 
       (voidP_b_0_11_alloc_table : (alloc_table voidP)) 
        (voidP_a_2_10_alloc_table : (alloc_table voidP)) 
         (voidP_result_0_9_alloc_table : (alloc_table voidP)) 
          (voidP_b_0_11_tag_table : (tag_table voidP)) 
           (voidP_a_2_10_tag_table : (tag_table voidP)) 
            (voidP_result_0_9_tag_table : (tag_table voidP)) 
             (intP_intM_b_0_11 : (memory voidP Int32.t)) 
              (intP_intM_a_2_10 : (memory voidP Int32.t)) : unit
               requires { true } reads { intP_intM_result_0_9 } writes {
               intP_intM_result_0_9 }
               ensures {
                 ((#"whole_program.jc" 446 10 58# "expl:Assigns clause"
                  (not_assigns voidP_result_0_9_alloc_table
                  voidP_result_0_9_alloc_table (old !intP_intM_result_0_9)
                  !intP_intM_result_0_9
                  (pset_range (pset_singleton result_0_0) (0)
                  (Int.(-) (Int32.to_int size_2) (1)))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 11 12 73#
                 "expl:Ensures clause"
                 (forall i_5_0 : int.
                  ((((<=) (0) i_5_0) /\ ((<) i_5_0 (Int32.to_int size_2))) ->
                   ((=)
                   (Int32.to_int
                   (select !intP_intM_result_0_9 (shift result_0_0 i_5_0)))
                   (Int.(+)
                   (Int32.to_int
                   (select intP_intM_a_2_10 (shift a_2_0 i_5_0)))
                   (Int32.to_int
                   (select intP_intM_b_0_11 (shift b_0_0 i_5_0))))))))) }
  
end

module Function_arrays_sum_safe

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val arrays_sum
  (result_0_0 : (pointer voidP)) 
   (a_2_0 : (pointer voidP)) 
    (b_0_0 : (pointer voidP)) 
     (size_2 : Int32.t) 
      (intP_intM_result_0_9 : ref (memory voidP Int32.t)) 
       (voidP_b_0_11_alloc_table : (alloc_table voidP)) 
        (voidP_a_2_10_alloc_table : (alloc_table voidP)) 
         (voidP_result_0_9_alloc_table : (alloc_table voidP)) 
          (voidP_b_0_11_tag_table : (tag_table voidP)) 
           (voidP_a_2_10_tag_table : (tag_table voidP)) 
            (voidP_result_0_9_tag_table : (tag_table voidP)) 
             (intP_intM_b_0_11 : (memory voidP Int32.t)) 
              (intP_intM_a_2_10 : (memory voidP Int32.t)) : unit
               requires {
                 ("expl:Internal"
                 (#"whole_program.jc" 405 12 2664# "expl:Requires clause"
                 ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 5 13 22#
                  "expl:Requires clause"
                  (Int32.(>=) size_2 (#"whole_program.jc" 405 33 45#
                  "expl:Integer cast" (Int32.of_int (0)))))
                 /\
                 (#"whole_program.jc" 405 12 2664# "expl:Requires clause"
                 ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 6 13 39#
                  "expl:Requires clause"
                  (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
                   (((<=)
                    (offset_min voidP_result_0_9_alloc_table result_0_0) (0))
                   /\
                   (((>=)
                    (offset_max voidP_result_0_9_alloc_table result_0_0)
                    (Int.(-) (Int32.to_int size_2) (1)))
                   /\
                   (forall __framac_tmp6 : int.
                    ((((<=) (0) __framac_tmp6) /\
                     ((<=) __framac_tmp6 (Int.(-) (Int32.to_int size_2) (1))))
                     -> ((=) true true))))) else ((=) true true)))
                 /\
                 (#"whole_program.jc" 405 12 2664# "expl:Requires clause"
                 ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 7 13 34#
                  "expl:Requires clause"
                  (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
                   (((<=) (offset_min voidP_a_2_10_alloc_table a_2_0) (0)) /\
                   (((>=) (offset_max voidP_a_2_10_alloc_table a_2_0)
                    (Int.(-) (Int32.to_int size_2) (1)))
                   /\
                   (forall __framac_tmp7 : int.
                    ((((<=) (0) __framac_tmp7) /\
                     ((<=) __framac_tmp7 (Int.(-) (Int32.to_int size_2) (1))))
                     -> ((=) true true))))) else ((=) true true)))
                 /\
                 (#"whole_program.jc" 405 12 2664# "expl:Requires clause"
                 ((#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 8 13 34#
                  "expl:Requires clause"
                  (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
                   (((<=) (offset_min voidP_b_0_11_alloc_table b_0_0) (0)) /\
                   (((>=) (offset_max voidP_b_0_11_alloc_table b_0_0)
                    (Int.(-) (Int32.to_int size_2) (1)))
                   /\
                   (forall __framac_tmp8 : int.
                    ((((<=) (0) __framac_tmp8) /\
                     ((<=) __framac_tmp8 (Int.(-) (Int32.to_int size_2) (1))))
                     -> ((=) true true))))) else ((=) true true)))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 9 13 90#
                 "expl:Requires clause"
                 (forall i_4_0 : int.
                  ((((<=) (0) i_4_0) /\ ((<) i_4_0 (Int32.to_int size_2))) ->
                   (((<=) (Int.(-_) (2147483648))
                    (Int.(+)
                    (Int32.to_int
                    (select intP_intM_a_2_10 (shift a_2_0 i_4_0)))
                    (Int32.to_int
                    (select intP_intM_b_0_11 (shift b_0_0 i_4_0)))))
                   /\
                   ((<=)
                   (Int.(+)
                   (Int32.to_int
                   (select intP_intM_a_2_10 (shift a_2_0 i_4_0)))
                   (Int32.to_int
                   (select intP_intM_b_0_11 (shift b_0_0 i_4_0))))
                   (2147483647))))))))))))))) }
               reads { intP_intM_result_0_9 } writes { intP_intM_result_0_9 }
               ensures {
                 ((#"whole_program.jc" 446 10 58# "expl:Assigns clause"
                  (not_assigns voidP_result_0_9_alloc_table
                  voidP_result_0_9_alloc_table (old !intP_intM_result_0_9)
                  !intP_intM_result_0_9
                  (pset_range (pset_singleton result_0_0) (0)
                  (Int.(-) (Int32.to_int size_2) (1)))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./arrays_sum.c" 11 12 73#
                 "expl:Ensures clause"
                 (forall i_5_0 : int.
                  ((((<=) (0) i_5_0) /\ ((<) i_5_0 (Int32.to_int size_2))) ->
                   ((=)
                   (Int32.to_int
                   (select !intP_intM_result_0_9 (shift result_0_0 i_5_0)))
                   (Int.(+)
                   (Int32.to_int
                   (select intP_intM_a_2_10 (shift a_2_0 i_5_0)))
                   (Int32.to_int
                   (select intP_intM_b_0_11 (shift b_0_0 i_5_0))))))))) }
  
end

module Function_average

  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val average
  (a_3 : Int32.t) 
   (b_1 : Int32.t) : Int32.t
    requires { true }
    ensures {
      (#"/home/work/workspace/education/acsl-exam/./average.c" 2 12 30#
      "expl:Ensures clause"
      ((=) (Int32.to_int result)
      (ComputerDivision.div (Int.(+) (Int32.to_int a_3) (Int32.to_int b_1))
      (2)))) }
  
end

module Function_average_safe

  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val average
  (a_3 : Int32.t) 
   (b_1 : Int32.t) : Int32.t
    requires { (true) }
    ensures {
      (#"/home/work/workspace/education/acsl-exam/./average.c" 2 12 30#
      "expl:Ensures clause"
      ((=) (Int32.to_int result)
      (ComputerDivision.div (Int.(+) (Int32.to_int a_3) (Int32.to_int b_1))
      (2)))) }
  
end

module Function_bsearch

  use enum.Uint32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val bsearch
  (a_4 : (pointer voidP)) 
   (n_2 : Uint32.t) 
    (key : Int32.t) 
     (voidP_a_4_12_alloc_table : (alloc_table voidP)) 
      (voidP_a_4_12_tag_table : (tag_table voidP)) 
       (intP_intM_a_4_12 : (memory voidP Int32.t)) : (pointer voidP)
        requires { true }
        ensures {
          (((allocated voidP_a_4_12_alloc_table result) ->
            (((=) (typeof voidP_a_4_12_tag_table result) intP_tag) /\
            (forall i : int.
             ((((<=) (offset_min voidP_a_4_12_alloc_table result) i) /\
              ((<) i (offset_max voidP_a_4_12_alloc_table result))) ->
              ((=) (typeof voidP_a_4_12_tag_table (shift result i)) intP_tag)))))
          /\
          (((exists i_8 : int.
             (((<=) (0) i_8) /\
             (((<) i_8 (Uint32.to_int n_2)) /\
             (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_8)) key)))) ->
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 13 15 66#
            "expl:Ensures clause"
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 13 15 66#
            "expl:Ensures clause"
            ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 13 15 66#
             "expl:Ensures clause"
             (exists i_9 : int.
              (((<=) (0) i_9) /\
              (((<) i_9 (Uint32.to_int n_2)) /\ ((=) result (shift a_4 i_9))))))
            /\
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 14 15 32#
            "expl:Ensures clause"
            (Int32.(=) (select intP_intM_a_4_12 result) key))))))
          /\
          ((forall i_10 : int.
            ((((<=) (0) i_10) /\ ((<) i_10 (Uint32.to_int n_2))) ->
             (Int32.(<>) (select intP_intM_a_4_12 (shift a_4 i_10)) key))) ->
           (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 10 15 31#
           "expl:Ensures clause" ((=) result null))))) }
  
end

module Function_bsearch_safe

  use enum.Uint32 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val bsearch
  (a_4 : (pointer voidP)) 
   (n_2 : Uint32.t) 
    (key : Int32.t) 
     (voidP_a_4_12_alloc_table : (alloc_table voidP)) 
      (voidP_a_4_12_tag_table : (tag_table voidP)) 
       (intP_intM_a_4_12 : (memory voidP Int32.t)) : (pointer voidP)
        requires {
          ("expl:Internal"
          (#"whole_program.jc" 564 12 921# "expl:Requires clause"
          ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 5 13 31#
           "expl:Requires clause"
           (if ((<=) (0) (Int.(-) (Uint32.to_int n_2) (1))) then
            (((<=) (offset_min voidP_a_4_12_alloc_table a_4) (0)) /\
            (((>=) (offset_max voidP_a_4_12_alloc_table a_4)
             (Int.(-) (Uint32.to_int n_2) (1)))
            /\
            (forall __framac_tmp9 : int.
             ((((<=) (0) __framac_tmp9) /\
              ((<=) __framac_tmp9 (Int.(-) (Uint32.to_int n_2) (1)))) ->
              ((=) true true))))) else ((=) true true)))
          /\
          (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 6 13 66#
          "expl:Requires clause"
          (forall i_11 : int.
           (forall j_2 : int.
            ((((<=) (0) i_11) /\
             (((<) i_11 j_2) /\ ((<) j_2 (Uint32.to_int n_2)))) ->
             (Int32.(<=) (select intP_intM_a_4_12 (shift a_4 i_11))
             (select intP_intM_a_4_12 (shift a_4 j_2)))))))))) }
        ensures {
          (((allocated voidP_a_4_12_alloc_table result) ->
            (((=) (typeof voidP_a_4_12_tag_table result) intP_tag) /\
            (forall i : int.
             ((((<=) (offset_min voidP_a_4_12_alloc_table result) i) /\
              ((<) i (offset_max voidP_a_4_12_alloc_table result))) ->
              ((=) (typeof voidP_a_4_12_tag_table (shift result i)) intP_tag)))))
          /\
          (((exists i_8 : int.
             (((<=) (0) i_8) /\
             (((<) i_8 (Uint32.to_int n_2)) /\
             (Int32.(=) (select intP_intM_a_4_12 (shift a_4 i_8)) key)))) ->
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 13 15 66#
            "expl:Ensures clause"
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 13 15 66#
            "expl:Ensures clause"
            ((#"/home/work/workspace/education/acsl-exam/./binary_search.c" 13 15 66#
             "expl:Ensures clause"
             (exists i_9 : int.
              (((<=) (0) i_9) /\
              (((<) i_9 (Uint32.to_int n_2)) /\ ((=) result (shift a_4 i_9))))))
            /\
            (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 14 15 32#
            "expl:Ensures clause"
            (Int32.(=) (select intP_intM_a_4_12 result) key))))))
          /\
          ((forall i_10 : int.
            ((((<=) (0) i_10) /\ ((<) i_10 (Uint32.to_int n_2))) ->
             (Int32.(<>) (select intP_intM_a_4_12 (shift a_4 i_10)) key))) ->
           (#"/home/work/workspace/education/acsl-exam/./binary_search.c" 10 15 31#
           "expl:Ensures clause" ((=) result null))))) }
  
end

module Function_distance

  use enum.Uint32 
  
  use int.MinMax 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val distance
  (a_5 : Uint32.t) 
   (b_2_0 : Uint32.t) : Uint32.t
    requires { true }
    ensures {
      (#"/home/work/workspace/education/acsl-exam/./distance.c" 5 12 46#
      "expl:Ensures clause"
      ((=) (Uint32.to_int result)
      (Int.(-) (MinMax.max (Uint32.to_int a_5) (Uint32.to_int b_2_0))
      (MinMax.min (Uint32.to_int a_5) (Uint32.to_int b_2_0))))) }
  
end

module Function_distance_safe

  use enum.Uint32 
  
  use int.MinMax 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val distance
  (a_5 : Uint32.t) 
   (b_2_0 : Uint32.t) : Uint32.t
    requires { (true) }
    ensures {
      (#"/home/work/workspace/education/acsl-exam/./distance.c" 5 12 46#
      "expl:Ensures clause"
      ((=) (Uint32.to_int result)
      (Int.(-) (MinMax.max (Uint32.to_int a_5) (Uint32.to_int b_2_0))
      (MinMax.min (Uint32.to_int a_5) (Uint32.to_int b_2_0))))) }
  
end

module Function_distance_abs

  use enum.Uint32 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.Abs 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val distance_abs
  (a_6 : Int32.t) 
   (b_3 : Int32.t) : Uint32.t
    requires { true }
    ensures {
      (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 9 12 46#
      "expl:Ensures clause"
      ((=) (Uint32.to_int result)
      (Abs.abs
      (Int.(-) (Abs.abs (Int32.to_int a_6)) (Abs.abs (Int32.to_int b_3))))))
      }
  
end

module Function_distance_abs_safe

  use enum.Uint32 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.Abs 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val distance_abs
  (a_6 : Int32.t) 
   (b_3 : Int32.t) : Uint32.t
    requires {
      ("expl:Internal"
      (#"whole_program.jc" 697 12 157# "expl:Requires clause"
      ((#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 5 13 18#
       "expl:Requires clause" ((=) true true))
      /\
      (#"whole_program.jc" 697 12 157# "expl:Requires clause"
      ((#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 6 13 28#
       "expl:Requires clause"
       ((>) (Int32.to_int a_6) (Int.(-_) (2147483648))))
      /\
      (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 7 13 28#
      "expl:Requires clause"
      ((>) (Int32.to_int b_3) (Int.(-_) (2147483648))))))))) }
    ensures {
      (#"/home/work/workspace/education/acsl-exam/./distance_abs.c" 9 12 46#
      "expl:Ensures clause"
      ((=) (Uint32.to_int result)
      (Abs.abs
      (Int.(-) (Abs.abs (Int32.to_int a_6)) (Abs.abs (Int32.to_int b_3))))))
      }
  
end

module Function_factorial_0

  use enum.Uint64 
  
  use enum.Uint32 
  
  use import int.Int 
  
  use import Axiomatic_Factorial 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val factorial_0
  (i : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (#"/home/work/workspace/education/acsl-exam/./factorial.c" 19 12 35#
     "expl:Ensures clause"
     ((=) (Uint64.to_int result) (factorial (Uint32.to_int i)))) }
  
end

module Function_factorial_0_safe

  use enum.Uint64 
  
  use enum.Uint32 
  
  use import int.Int 
  
  use import Axiomatic_Factorial 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val factorial_0
  (i : Uint32.t) : Uint64.t
   requires {
     ("expl:Internal"
     (#"/home/work/workspace/education/acsl-exam/./factorial.c" 17 13 51#
     "expl:Requires clause"
     ((<=) (factorial (Uint32.to_int i)) (18446744073709551615)))) }
   ensures {
     (#"/home/work/workspace/education/acsl-exam/./factorial.c" 19 12 35#
     "expl:Ensures clause"
     ((=) (Uint64.to_int result) (factorial (Uint32.to_int i)))) }
  
end

module Function_max_max

  use enum.Uint32 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val max_max
  (a_7 : (pointer voidP)) 
   (size_5 : Uint32.t) 
    (max1 : (pointer int_xP)) 
     (max2 : (pointer int_xP)) 
      (int_xP_int_xM_max2_16 : ref (memory int_xP (pointer voidP))) 
       (int_xP_int_xM_max1_15 : ref (memory int_xP (pointer voidP))) 
        (voidP_a_7_14_alloc_table : (alloc_table voidP)) 
         (int_xP_max2_16_alloc_table : (alloc_table int_xP)) 
          (int_xP_max1_15_alloc_table : (alloc_table int_xP)) 
           (voidP_a_7_14_tag_table : (tag_table voidP)) 
            (intP_intM_a_7_14 : (memory voidP Int32.t)) : unit
             requires { true } reads { int_xP_int_xM_max1_15,
             int_xP_int_xM_max2_16 } writes { int_xP_int_xM_max1_15,
             int_xP_int_xM_max2_16 }
             ensures {
               ((((>) (Uint32.to_int size_5) (0)) ->
                 (((#"whole_program.jc" 1048 10 36# "expl:Assigns clause"
                   (not_assigns int_xP_max1_15_alloc_table
                   int_xP_max1_15_alloc_table (old !int_xP_int_xM_max1_15)
                   !int_xP_int_xM_max1_15 (pset_singleton max1)))
                  /\
                  (#"whole_program.jc" 1048 10 36# "expl:Assigns clause"
                  (not_assigns int_xP_max2_16_alloc_table
                  int_xP_max2_16_alloc_table (old !int_xP_int_xM_max2_16)
                  !int_xP_int_xM_max2_16 (pset_singleton max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 27#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max1_15_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max1_15_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 31 43#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max2_16_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max2_16_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 12 15 67#
                  "expl:Ensures clause"
                  (exists i_24 : int.
                   (((<=) (0) i_24) /\
                   (((<) i_24 (Uint32.to_int size_5)) /\
                   ((=) (shift a_7 i_24)
                   (select !int_xP_int_xM_max1_15 max1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 67#
                  "expl:Ensures clause"
                  (exists i_25 : int.
                   (((<=) (0) i_25) /\
                   (((<) i_25 (Uint32.to_int size_5)) /\
                   ((=) (shift a_7 i_25)
                   (select !int_xP_int_xM_max2_16 max2))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 14 15 31#
                  "expl:Ensures clause"
                  (Int32.(>=)
                  (select intP_intM_a_7_14
                  (select !int_xP_int_xM_max1_15 max1))
                  (select intP_intM_a_7_14
                  (select !int_xP_int_xM_max2_16 max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 15 15 66#
                  "expl:Ensures clause"
                  (forall i_26 : int.
                   ((((<=) (0) i_26) /\ ((<) i_26 (Uint32.to_int size_5))) ->
                    (Int32.(<=) (select intP_intM_a_7_14 (shift a_7 i_26))
                    (select intP_intM_a_7_14
                    (select !int_xP_int_xM_max1_15 max1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 16 15 83#
                  "expl:Ensures clause"
                  (exists i_27 : int.
                   (((<=) (0) i_27) /\
                   (((<) i_27 (Uint32.to_int size_5)) /\
                   ((Int32.(>=) (select intP_intM_a_7_14 (shift a_7 i_27))
                    (select intP_intM_a_7_14
                    (select !int_xP_int_xM_max2_16 max2)))
                   /\
                   (Int32.(=) (select intP_intM_a_7_14 (shift a_7 i_27))
                   (select intP_intM_a_7_14
                   (select !int_xP_int_xM_max1_15 max1))))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 17 15 131#
                 "expl:Ensures clause"
                 (not
                 (exists i_28 : int.
                  (exists j_9 : int.
                   (((<=) (0) i_28) /\
                   (((<) i_28 (Uint32.to_int size_5)) /\
                   (((<=) (0) j_9) /\
                   (((<) j_9 (Uint32.to_int size_5)) /\
                   (((<>) i_28 j_9) /\
                   ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 i_28))
                    (select intP_intM_a_7_14
                    (select !int_xP_int_xM_max2_16 max2)))
                   /\
                   ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 j_9))
                    (select intP_intM_a_7_14
                    (select !int_xP_int_xM_max2_16 max2)))
                   /\
                   (Int32.(>) (select intP_intM_a_7_14 (shift a_7 i_28))
                   (select intP_intM_a_7_14 (shift a_7 j_9)))))))))))))))))))))))))))))))
               /\
               (((=) (Uint32.to_int size_5) (0)) ->
                (((#"whole_program.jc" 1043 10 18# "expl:Assigns clause"
                  (not_assigns int_xP_max1_15_alloc_table
                  int_xP_max1_15_alloc_table (old !int_xP_int_xM_max1_15)
                  !int_xP_int_xM_max1_15 pset_empty))
                 /\
                 (#"whole_program.jc" 1043 10 18# "expl:Assigns clause"
                 (not_assigns int_xP_max2_16_alloc_table
                 int_xP_max2_16_alloc_table (old !int_xP_int_xM_max2_16)
                 !int_xP_int_xM_max2_16 pset_empty)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                "expl:Ensures clause"
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                "expl:Ensures clause"
                ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                 "expl:Ensures clause" ((=) max1 max1))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 7 15 33#
                "expl:Ensures clause" ((=) max2 max2)))))))) }
  
end

module Function_max_max_safe

  use enum.Uint32 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val max_max
  (a_7 : (pointer voidP)) 
   (size_5 : Uint32.t) 
    (max1 : (pointer int_xP)) 
     (max2 : (pointer int_xP)) 
      (int_xP_int_xM_max2_16 : ref (memory int_xP (pointer voidP))) 
       (int_xP_int_xM_max1_15 : ref (memory int_xP (pointer voidP))) 
        (voidP_a_7_14_alloc_table : (alloc_table voidP)) 
         (int_xP_max2_16_alloc_table : (alloc_table int_xP)) 
          (int_xP_max1_15_alloc_table : (alloc_table int_xP)) 
           (voidP_a_7_14_tag_table : (tag_table voidP)) 
            (intP_intM_a_7_14 : (memory voidP Int32.t)) : unit
             requires {
               ("expl:Internal"
               (#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 1 13 34#
                "expl:Requires clause"
                (if ((<=) (0) (Int.(-) (Uint32.to_int size_5) (1))) then
                 (((<=) (offset_min voidP_a_7_14_alloc_table a_7) (0)) /\
                 (((>=) (offset_max voidP_a_7_14_alloc_table a_7)
                  (Int.(-) (Uint32.to_int size_5) (1)))
                 /\
                 (forall __framac_tmp12 : int.
                  ((((<=) (0) __framac_tmp12) /\
                   ((<=) __framac_tmp12 (Int.(-) (Uint32.to_int size_5) (1))))
                   -> ((=) true true))))) else ((=) true true)))
               /\
               (#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 13 25#
                "expl:Requires clause"
                (#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
                ((#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
                 ((<=) (offset_min int_xP_max1_15_alloc_table max1) (0)))
                /\
                (#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
                ((#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
                 ((>=) (offset_max int_xP_max1_15_alloc_table max1) (0)))
                /\
                (#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
                ((=) true true)))))))
               /\
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 29 41#
               "expl:Requires clause"
               (#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
               ((#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
                ((<=) (offset_min int_xP_max2_16_alloc_table max2) (0)))
               /\
               (#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
               ((#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
                ((>=) (offset_max int_xP_max2_16_alloc_table max2) (0)))
               /\
               (#"whole_program.jc" 1019 12 1287# "expl:Requires clause"
               ((=) true true)))))))))))) }
             reads { int_xP_int_xM_max1_15, int_xP_int_xM_max2_16 } writes {
             int_xP_int_xM_max1_15, int_xP_int_xM_max2_16 }
             ensures {
               ((((>) (Uint32.to_int size_5) (0)) ->
                 (((#"whole_program.jc" 1048 10 36# "expl:Assigns clause"
                   (not_assigns int_xP_max1_15_alloc_table
                   int_xP_max1_15_alloc_table (old !int_xP_int_xM_max1_15)
                   !int_xP_int_xM_max1_15 (pset_singleton max1)))
                  /\
                  (#"whole_program.jc" 1048 10 36# "expl:Assigns clause"
                  (not_assigns int_xP_max2_16_alloc_table
                  int_xP_max2_16_alloc_table (old !int_xP_int_xM_max2_16)
                  !int_xP_int_xM_max2_16 (pset_singleton max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 27#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max1_15_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max1_15_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 31 43#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max2_16_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max2_16_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 12 15 67#
                  "expl:Ensures clause"
                  (exists i_24 : int.
                   (((<=) (0) i_24) /\
                   (((<) i_24 (Uint32.to_int size_5)) /\
                   ((=) (shift a_7 i_24)
                   (select !int_xP_int_xM_max1_15 max1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 67#
                  "expl:Ensures clause"
                  (exists i_25 : int.
                   (((<=) (0) i_25) /\
                   (((<) i_25 (Uint32.to_int size_5)) /\
                   ((=) (shift a_7 i_25)
                   (select !int_xP_int_xM_max2_16 max2))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 14 15 31#
                  "expl:Ensures clause"
                  (Int32.(>=)
                  (select intP_intM_a_7_14
                  (select !int_xP_int_xM_max1_15 max1))
                  (select intP_intM_a_7_14
                  (select !int_xP_int_xM_max2_16 max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 15 15 66#
                  "expl:Ensures clause"
                  (forall i_26 : int.
                   ((((<=) (0) i_26) /\ ((<) i_26 (Uint32.to_int size_5))) ->
                    (Int32.(<=) (select intP_intM_a_7_14 (shift a_7 i_26))
                    (select intP_intM_a_7_14
                    (select !int_xP_int_xM_max1_15 max1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 16 15 83#
                  "expl:Ensures clause"
                  (exists i_27 : int.
                   (((<=) (0) i_27) /\
                   (((<) i_27 (Uint32.to_int size_5)) /\
                   ((Int32.(>=) (select intP_intM_a_7_14 (shift a_7 i_27))
                    (select intP_intM_a_7_14
                    (select !int_xP_int_xM_max2_16 max2)))
                   /\
                   (Int32.(=) (select intP_intM_a_7_14 (shift a_7 i_27))
                   (select intP_intM_a_7_14
                   (select !int_xP_int_xM_max1_15 max1))))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 17 15 131#
                 "expl:Ensures clause"
                 (not
                 (exists i_28 : int.
                  (exists j_9 : int.
                   (((<=) (0) i_28) /\
                   (((<) i_28 (Uint32.to_int size_5)) /\
                   (((<=) (0) j_9) /\
                   (((<) j_9 (Uint32.to_int size_5)) /\
                   (((<>) i_28 j_9) /\
                   ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 i_28))
                    (select intP_intM_a_7_14
                    (select !int_xP_int_xM_max2_16 max2)))
                   /\
                   ((Int32.(>) (select intP_intM_a_7_14 (shift a_7 j_9))
                    (select intP_intM_a_7_14
                    (select !int_xP_int_xM_max2_16 max2)))
                   /\
                   (Int32.(>) (select intP_intM_a_7_14 (shift a_7 i_28))
                   (select intP_intM_a_7_14 (shift a_7 j_9)))))))))))))))))))))))))))))))
               /\
               (((=) (Uint32.to_int size_5) (0)) ->
                (((#"whole_program.jc" 1043 10 18# "expl:Assigns clause"
                  (not_assigns int_xP_max1_15_alloc_table
                  int_xP_max1_15_alloc_table (old !int_xP_int_xM_max1_15)
                  !int_xP_int_xM_max1_15 pset_empty))
                 /\
                 (#"whole_program.jc" 1043 10 18# "expl:Assigns clause"
                 (not_assigns int_xP_max2_16_alloc_table
                 int_xP_max2_16_alloc_table (old !int_xP_int_xM_max2_16)
                 !int_xP_int_xM_max2_16 pset_empty)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                "expl:Ensures clause"
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                "expl:Ensures clause"
                ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                 "expl:Ensures clause" ((=) max1 max1))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 7 15 33#
                "expl:Ensures clause" ((=) max2 max2)))))))) }
  
end

module Function_max_min

  use enum.Uint32 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val max_min
  (a_8 : (pointer voidP)) 
   (size_6 : Uint32.t) 
    (max : (pointer int_xP)) 
     (min : (pointer int_xP)) 
      (int_xP_int_xM_min_19 : ref (memory int_xP (pointer voidP))) 
       (int_xP_int_xM_max_18 : ref (memory int_xP (pointer voidP))) 
        (voidP_a_8_17_alloc_table : (alloc_table voidP)) 
         (int_xP_min_19_alloc_table : (alloc_table int_xP)) 
          (int_xP_max_18_alloc_table : (alloc_table int_xP)) 
           (voidP_a_8_17_tag_table : (tag_table voidP)) 
            (intP_intM_a_8_17 : (memory voidP Int32.t)) : unit
             requires { true } reads { int_xP_int_xM_max_18,
             int_xP_int_xM_min_19 } writes { int_xP_int_xM_max_18,
             int_xP_int_xM_min_19 }
             ensures {
               ((((>) (Uint32.to_int size_6) (0)) ->
                 (((#"whole_program.jc" 1208 10 34# "expl:Assigns clause"
                   (not_assigns int_xP_max_18_alloc_table
                   int_xP_max_18_alloc_table (old !int_xP_int_xM_max_18)
                   !int_xP_int_xM_max_18 (pset_singleton max)))
                  /\
                  (#"whole_program.jc" 1208 10 34# "expl:Assigns clause"
                  (not_assigns int_xP_min_19_alloc_table
                  int_xP_min_19_alloc_table (old !int_xP_int_xM_min_19)
                  !int_xP_int_xM_min_19 (pset_singleton min))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
                  "expl:Ensures clause"
                  (exists i_29 : int.
                   (((<=) (0) i_29) /\
                   (((<) i_29 (Uint32.to_int size_6)) /\
                   ((=) (shift a_8 i_29) (select !int_xP_int_xM_max_18 max))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 12 15 66#
                  "expl:Ensures clause"
                  (exists i_30 : int.
                   (((<=) (0) i_30) /\
                   (((<) i_30 (Uint32.to_int size_6)) /\
                   ((=) (shift a_8 i_30) (select !int_xP_int_xM_min_19 min))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 13 15 29#
                  "expl:Ensures clause"
                  (Int32.(>=)
                  (select intP_intM_a_8_17
                  (select !int_xP_int_xM_max_18 max))
                  (select intP_intM_a_8_17
                  (select !int_xP_int_xM_min_19 min))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_min.c" 14 15 74#
                 "expl:Ensures clause"
                 (forall i_31 : int.
                  ((((<=) (0) i_31) /\ ((<) i_31 (Uint32.to_int size_6))) ->
                   ((Int32.(>=)
                    (select intP_intM_a_8_17
                    (select !int_xP_int_xM_max_18 max))
                    (select intP_intM_a_8_17 (shift a_8 i_31)))
                   /\
                   (Int32.(>=) (select intP_intM_a_8_17 (shift a_8 i_31))
                   (select intP_intM_a_8_17
                   (select !int_xP_int_xM_min_19 min))))))))))))))))
               /\
               (((=) (Uint32.to_int size_6) (0)) ->
                (((#"whole_program.jc" 1203 10 18# "expl:Assigns clause"
                  (not_assigns int_xP_max_18_alloc_table
                  int_xP_max_18_alloc_table (old !int_xP_int_xM_max_18)
                  !int_xP_int_xM_max_18 pset_empty))
                 /\
                 (#"whole_program.jc" 1203 10 18# "expl:Assigns clause"
                 (not_assigns int_xP_min_19_alloc_table
                 int_xP_min_19_alloc_table (old !int_xP_int_xM_min_19)
                 !int_xP_int_xM_min_19 pset_empty)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 15 51#
                "expl:Ensures clause"
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 15 51#
                "expl:Ensures clause"
                ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 15 31#
                 "expl:Ensures clause" ((=) max max))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 35 51#
                "expl:Ensures clause" ((=) min min)))))))) }
  
end

module Function_max_min_safe

  use enum.Uint32 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val max_min
  (a_8 : (pointer voidP)) 
   (size_6 : Uint32.t) 
    (max : (pointer int_xP)) 
     (min : (pointer int_xP)) 
      (int_xP_int_xM_min_19 : ref (memory int_xP (pointer voidP))) 
       (int_xP_int_xM_max_18 : ref (memory int_xP (pointer voidP))) 
        (voidP_a_8_17_alloc_table : (alloc_table voidP)) 
         (int_xP_min_19_alloc_table : (alloc_table int_xP)) 
          (int_xP_max_18_alloc_table : (alloc_table int_xP)) 
           (voidP_a_8_17_tag_table : (tag_table voidP)) 
            (intP_intM_a_8_17 : (memory voidP Int32.t)) : unit
             requires {
               ("expl:Internal"
               (#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
               ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 1 13 34#
                "expl:Requires clause"
                (if ((<=) (0) (Int.(-) (Uint32.to_int size_6) (1))) then
                 (((<=) (offset_min voidP_a_8_17_alloc_table a_8) (0)) /\
                 (((>=) (offset_max voidP_a_8_17_alloc_table a_8)
                  (Int.(-) (Uint32.to_int size_6) (1)))
                 /\
                 (forall __framac_tmp15 : int.
                  ((((<=) (0) __framac_tmp15) /\
                   ((<=) __framac_tmp15 (Int.(-) (Uint32.to_int size_6) (1))))
                   -> ((=) true true))))) else ((=) true true)))
               /\
               (#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
               ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 2 13 24#
                "expl:Requires clause"
                (#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
                ((#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
                 ((<=) (offset_min int_xP_max_18_alloc_table max) (0)))
                /\
                (#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
                ((#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
                 ((>=) (offset_max int_xP_max_18_alloc_table max) (0)))
                /\
                (#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
                ((=) true true)))))))
               /\
               (#"/home/work/workspace/education/acsl-exam/./max_min.c" 3 13 24#
               "expl:Requires clause"
               (#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
               ((#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
                ((<=) (offset_min int_xP_min_19_alloc_table min) (0)))
               /\
               (#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
               ((#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
                ((>=) (offset_max int_xP_min_19_alloc_table min) (0)))
               /\
               (#"whole_program.jc" 1183 12 1050# "expl:Requires clause"
               ((=) true true)))))))))))) }
             reads { int_xP_int_xM_max_18, int_xP_int_xM_min_19 } writes {
             int_xP_int_xM_max_18, int_xP_int_xM_min_19 }
             ensures {
               ((((>) (Uint32.to_int size_6) (0)) ->
                 (((#"whole_program.jc" 1208 10 34# "expl:Assigns clause"
                   (not_assigns int_xP_max_18_alloc_table
                   int_xP_max_18_alloc_table (old !int_xP_int_xM_max_18)
                   !int_xP_int_xM_max_18 (pset_singleton max)))
                  /\
                  (#"whole_program.jc" 1208 10 34# "expl:Assigns clause"
                  (not_assigns int_xP_min_19_alloc_table
                  int_xP_min_19_alloc_table (old !int_xP_int_xM_min_19)
                  !int_xP_int_xM_min_19 (pset_singleton min))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
                  "expl:Ensures clause"
                  (exists i_29 : int.
                   (((<=) (0) i_29) /\
                   (((<) i_29 (Uint32.to_int size_6)) /\
                   ((=) (shift a_8 i_29) (select !int_xP_int_xM_max_18 max))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 12 15 66#
                  "expl:Ensures clause"
                  (exists i_30 : int.
                   (((<=) (0) i_30) /\
                   (((<) i_30 (Uint32.to_int size_6)) /\
                   ((=) (shift a_8 i_30) (select !int_xP_int_xM_min_19 min))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_min.c" 11 15 66#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 13 15 29#
                  "expl:Ensures clause"
                  (Int32.(>=)
                  (select intP_intM_a_8_17
                  (select !int_xP_int_xM_max_18 max))
                  (select intP_intM_a_8_17
                  (select !int_xP_int_xM_min_19 min))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_min.c" 14 15 74#
                 "expl:Ensures clause"
                 (forall i_31 : int.
                  ((((<=) (0) i_31) /\ ((<) i_31 (Uint32.to_int size_6))) ->
                   ((Int32.(>=)
                    (select intP_intM_a_8_17
                    (select !int_xP_int_xM_max_18 max))
                    (select intP_intM_a_8_17 (shift a_8 i_31)))
                   /\
                   (Int32.(>=) (select intP_intM_a_8_17 (shift a_8 i_31))
                   (select intP_intM_a_8_17
                   (select !int_xP_int_xM_min_19 min))))))))))))))))
               /\
               (((=) (Uint32.to_int size_6) (0)) ->
                (((#"whole_program.jc" 1203 10 18# "expl:Assigns clause"
                  (not_assigns int_xP_max_18_alloc_table
                  int_xP_max_18_alloc_table (old !int_xP_int_xM_max_18)
                  !int_xP_int_xM_max_18 pset_empty))
                 /\
                 (#"whole_program.jc" 1203 10 18# "expl:Assigns clause"
                 (not_assigns int_xP_min_19_alloc_table
                 int_xP_min_19_alloc_table (old !int_xP_int_xM_min_19)
                 !int_xP_int_xM_min_19 pset_empty)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 15 51#
                "expl:Ensures clause"
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 15 51#
                "expl:Ensures clause"
                ((#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 15 31#
                 "expl:Ensures clause" ((=) max max))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_min.c" 7 35 51#
                "expl:Ensures clause" ((=) min min)))))))) }
  
end

module Function_min_min

  use enum.Uint32 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val min_min
  (a_9 : (pointer voidP)) 
   (size_7 : Uint32.t) 
    (min1 : (pointer int_xP)) 
     (min2 : (pointer int_xP)) 
      (int_xP_int_xM_min2_22 : ref (memory int_xP (pointer voidP))) 
       (int_xP_int_xM_min1_21 : ref (memory int_xP (pointer voidP))) 
        (voidP_a_9_20_alloc_table : (alloc_table voidP)) 
         (int_xP_min2_22_alloc_table : (alloc_table int_xP)) 
          (int_xP_min1_21_alloc_table : (alloc_table int_xP)) 
           (voidP_a_9_20_tag_table : (tag_table voidP)) 
            (intP_intM_a_9_20 : (memory voidP Int32.t)) : unit
             requires { true } reads { int_xP_int_xM_min1_21,
             int_xP_int_xM_min2_22 } writes { int_xP_int_xM_min1_21,
             int_xP_int_xM_min2_22 }
             ensures {
               ((((>) (Uint32.to_int size_7) (0)) ->
                 (((#"whole_program.jc" 1320 10 36# "expl:Assigns clause"
                   (not_assigns int_xP_min1_21_alloc_table
                   int_xP_min1_21_alloc_table (old !int_xP_int_xM_min1_21)
                   !int_xP_int_xM_min1_21 (pset_singleton min1)))
                  /\
                  (#"whole_program.jc" 1320 10 36# "expl:Assigns clause"
                  (not_assigns int_xP_min2_22_alloc_table
                  int_xP_min2_22_alloc_table (old !int_xP_int_xM_min2_22)
                  !int_xP_int_xM_min2_22 (pset_singleton min2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 27#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_min1_21_alloc_table min1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_min1_21_alloc_table min1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 31 43#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_min2_22_alloc_table min2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_min2_22_alloc_table min2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 12 15 67#
                  "expl:Ensures clause"
                  (exists i_32 : int.
                   (((<=) (0) i_32) /\
                   (((<) i_32 (Uint32.to_int size_7)) /\
                   ((=) (shift a_9 i_32)
                   (select !int_xP_int_xM_min1_21 min1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 13 15 67#
                  "expl:Ensures clause"
                  (exists i_33 : int.
                   (((<=) (0) i_33) /\
                   (((<) i_33 (Uint32.to_int size_7)) /\
                   ((=) (shift a_9 i_33)
                   (select !int_xP_int_xM_min2_22 min2))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 14 15 31#
                  "expl:Ensures clause"
                  (Int32.(<=)
                  (select intP_intM_a_9_20
                  (select !int_xP_int_xM_min1_21 min1))
                  (select intP_intM_a_9_20
                  (select !int_xP_int_xM_min2_22 min2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 15 15 66#
                  "expl:Ensures clause"
                  (forall i_34 : int.
                   ((((<=) (0) i_34) /\ ((<) i_34 (Uint32.to_int size_7))) ->
                    (Int32.(>=) (select intP_intM_a_9_20 (shift a_9 i_34))
                    (select intP_intM_a_9_20
                    (select !int_xP_int_xM_min1_21 min1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 16 15 83#
                  "expl:Ensures clause"
                  (exists i_35 : int.
                   (((<=) (0) i_35) /\
                   (((<) i_35 (Uint32.to_int size_7)) /\
                   ((Int32.(<=) (select intP_intM_a_9_20 (shift a_9 i_35))
                    (select intP_intM_a_9_20
                    (select !int_xP_int_xM_min2_22 min2)))
                   /\
                   (Int32.(=) (select intP_intM_a_9_20 (shift a_9 i_35))
                   (select intP_intM_a_9_20
                   (select !int_xP_int_xM_min1_21 min1))))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 17 15 131#
                 "expl:Ensures clause"
                 (not
                 (exists i_36 : int.
                  (exists j_18 : int.
                   (((<=) (0) i_36) /\
                   (((<) i_36 (Uint32.to_int size_7)) /\
                   (((<=) (0) j_18) /\
                   (((<) j_18 (Uint32.to_int size_7)) /\
                   (((<>) i_36 j_18) /\
                   ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 i_36))
                    (select intP_intM_a_9_20
                    (select !int_xP_int_xM_min2_22 min2)))
                   /\
                   ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 j_18))
                    (select intP_intM_a_9_20
                    (select !int_xP_int_xM_min2_22 min2)))
                   /\
                   (Int32.(<) (select intP_intM_a_9_20 (shift a_9 i_36))
                   (select intP_intM_a_9_20 (shift a_9 j_18)))))))))))))))))))))))))))))))
               /\
               (((=) (Uint32.to_int size_7) (0)) ->
                (((#"whole_program.jc" 1315 10 18# "expl:Assigns clause"
                  (not_assigns int_xP_min1_21_alloc_table
                  int_xP_min1_21_alloc_table (old !int_xP_int_xM_min1_21)
                  !int_xP_int_xM_min1_21 pset_empty))
                 /\
                 (#"whole_program.jc" 1315 10 18# "expl:Assigns clause"
                 (not_assigns int_xP_min2_22_alloc_table
                 int_xP_min2_22_alloc_table (old !int_xP_int_xM_min2_22)
                 !int_xP_int_xM_min2_22 pset_empty)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 6 15 33#
                "expl:Ensures clause"
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 6 15 33#
                "expl:Ensures clause"
                ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 6 15 33#
                 "expl:Ensures clause" ((=) min1 min1))
                /\
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 7 15 33#
                "expl:Ensures clause" ((=) min2 min2)))))))) }
  
end

module Function_min_min_safe

  use enum.Uint32 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val min_min
  (a_9 : (pointer voidP)) 
   (size_7 : Uint32.t) 
    (min1 : (pointer int_xP)) 
     (min2 : (pointer int_xP)) 
      (int_xP_int_xM_min2_22 : ref (memory int_xP (pointer voidP))) 
       (int_xP_int_xM_min1_21 : ref (memory int_xP (pointer voidP))) 
        (voidP_a_9_20_alloc_table : (alloc_table voidP)) 
         (int_xP_min2_22_alloc_table : (alloc_table int_xP)) 
          (int_xP_min1_21_alloc_table : (alloc_table int_xP)) 
           (voidP_a_9_20_tag_table : (tag_table voidP)) 
            (intP_intM_a_9_20 : (memory voidP Int32.t)) : unit
             requires {
               ("expl:Internal"
               (#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
               ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 1 13 34#
                "expl:Requires clause"
                (if ((<=) (0) (Int.(-) (Uint32.to_int size_7) (1))) then
                 (((<=) (offset_min voidP_a_9_20_alloc_table a_9) (0)) /\
                 (((>=) (offset_max voidP_a_9_20_alloc_table a_9)
                  (Int.(-) (Uint32.to_int size_7) (1)))
                 /\
                 (forall __framac_tmp20 : int.
                  ((((<=) (0) __framac_tmp20) /\
                   ((<=) __framac_tmp20 (Int.(-) (Uint32.to_int size_7) (1))))
                   -> ((=) true true))))) else ((=) true true)))
               /\
               (#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
               ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 2 13 25#
                "expl:Requires clause"
                (#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
                ((#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
                 ((<=) (offset_min int_xP_min1_21_alloc_table min1) (0)))
                /\
                (#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
                ((#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
                 ((>=) (offset_max int_xP_min1_21_alloc_table min1) (0)))
                /\
                (#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
                ((=) true true)))))))
               /\
               (#"/home/work/workspace/education/acsl-exam/./min_min.c" 2 29 41#
               "expl:Requires clause"
               (#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
               ((#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
                ((<=) (offset_min int_xP_min2_22_alloc_table min2) (0)))
               /\
               (#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
               ((#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
                ((>=) (offset_max int_xP_min2_22_alloc_table min2) (0)))
               /\
               (#"whole_program.jc" 1291 12 1287# "expl:Requires clause"
               ((=) true true)))))))))))) }
             reads { int_xP_int_xM_min1_21, int_xP_int_xM_min2_22 } writes {
             int_xP_int_xM_min1_21, int_xP_int_xM_min2_22 }
             ensures {
               ((((>) (Uint32.to_int size_7) (0)) ->
                 (((#"whole_program.jc" 1320 10 36# "expl:Assigns clause"
                   (not_assigns int_xP_min1_21_alloc_table
                   int_xP_min1_21_alloc_table (old !int_xP_int_xM_min1_21)
                   !int_xP_int_xM_min1_21 (pset_singleton min1)))
                  /\
                  (#"whole_program.jc" 1320 10 36# "expl:Assigns clause"
                  (not_assigns int_xP_min2_22_alloc_table
                  int_xP_min2_22_alloc_table (old !int_xP_int_xM_min2_22)
                  !int_xP_int_xM_min2_22 (pset_singleton min2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 27#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_min1_21_alloc_table min1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_min1_21_alloc_table min1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 31 43#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_min2_22_alloc_table min2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_min2_22_alloc_table min2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 12 15 67#
                  "expl:Ensures clause"
                  (exists i_32 : int.
                   (((<=) (0) i_32) /\
                   (((<) i_32 (Uint32.to_int size_7)) /\
                   ((=) (shift a_9 i_32)
                   (select !int_xP_int_xM_min1_21 min1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 13 15 67#
                  "expl:Ensures clause"
                  (exists i_33 : int.
                   (((<=) (0) i_33) /\
                   (((<) i_33 (Uint32.to_int size_7)) /\
                   ((=) (shift a_9 i_33)
                   (select !int_xP_int_xM_min2_22 min2))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 14 15 31#
                  "expl:Ensures clause"
                  (Int32.(<=)
                  (select intP_intM_a_9_20
                  (select !int_xP_int_xM_min1_21 min1))
                  (select intP_intM_a_9_20
                  (select !int_xP_int_xM_min2_22 min2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 15 15 66#
                  "expl:Ensures clause"
                  (forall i_34 : int.
                   ((((<=) (0) i_34) /\ ((<) i_34 (Uint32.to_int size_7))) ->
                    (Int32.(>=) (select intP_intM_a_9_20 (shift a_9 i_34))
                    (select intP_intM_a_9_20
                    (select !int_xP_int_xM_min1_21 min1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 16 15 83#
                  "expl:Ensures clause"
                  (exists i_35 : int.
                   (((<=) (0) i_35) /\
                   (((<) i_35 (Uint32.to_int size_7)) /\
                   ((Int32.(<=) (select intP_intM_a_9_20 (shift a_9 i_35))
                    (select intP_intM_a_9_20
                    (select !int_xP_int_xM_min2_22 min2)))
                   /\
                   (Int32.(=) (select intP_intM_a_9_20 (shift a_9 i_35))
                   (select intP_intM_a_9_20
                   (select !int_xP_int_xM_min1_21 min1))))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./min_min.c" 17 15 131#
                 "expl:Ensures clause"
                 (not
                 (exists i_36 : int.
                  (exists j_18 : int.
                   (((<=) (0) i_36) /\
                   (((<) i_36 (Uint32.to_int size_7)) /\
                   (((<=) (0) j_18) /\
                   (((<) j_18 (Uint32.to_int size_7)) /\
                   (((<>) i_36 j_18) /\
                   ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 i_36))
                    (select intP_intM_a_9_20
                    (select !int_xP_int_xM_min2_22 min2)))
                   /\
                   ((Int32.(<) (select intP_intM_a_9_20 (shift a_9 j_18))
                    (select intP_intM_a_9_20
                    (select !int_xP_int_xM_min2_22 min2)))
                   /\
                   (Int32.(<) (select intP_intM_a_9_20 (shift a_9 i_36))
                   (select intP_intM_a_9_20 (shift a_9 j_18)))))))))))))))))))))))))))))))
               /\
               (((=) (Uint32.to_int size_7) (0)) ->
                (((#"whole_program.jc" 1315 10 18# "expl:Assigns clause"
                  (not_assigns int_xP_min1_21_alloc_table
                  int_xP_min1_21_alloc_table (old !int_xP_int_xM_min1_21)
                  !int_xP_int_xM_min1_21 pset_empty))
                 /\
                 (#"whole_program.jc" 1315 10 18# "expl:Assigns clause"
                 (not_assigns int_xP_min2_22_alloc_table
                 int_xP_min2_22_alloc_table (old !int_xP_int_xM_min2_22)
                 !int_xP_int_xM_min2_22 pset_empty)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 6 15 33#
                "expl:Ensures clause"
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 6 15 33#
                "expl:Ensures clause"
                ((#"/home/work/workspace/education/acsl-exam/./min_min.c" 6 15 33#
                 "expl:Ensures clause" ((=) min1 min1))
                /\
                (#"/home/work/workspace/education/acsl-exam/./min_min.c" 7 15 33#
                "expl:Ensures clause" ((=) min2 min2)))))))) }
  
end

module Function_palindrome

  use enum.Uint32 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val palindrome
  (a_10 : (pointer voidP)) 
   (size_8 : Uint32.t) 
    (voidP_a_10_23_alloc_table : (alloc_table voidP)) 
     (voidP_a_10_23_tag_table : (tag_table voidP)) 
      (intP_intM_a_10_23 : (memory voidP Int32.t)) : Int32.t
       requires { true }
       ensures {
         (((((>) (Uint32.to_int size_8) (0)) /\
           (exists i_37 : int.
            (((<=) (0) i_37) /\
            (((<) i_37 (Uint32.to_int size_8)) /\
            (Int32.(<>) (select intP_intM_a_10_23 (shift a_10 i_37))
            (select intP_intM_a_10_23
            (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_37) (1)))))))))
           ->
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 14 15 27#
           "expl:Ensures clause"
           (Int32.(=) result (#"whole_program.jc" 1485 32 44#
           "expl:Integer cast" (Int32.of_int (0))))))
         /\
         (((((>) (Uint32.to_int size_8) (0)) /\
           (forall i_38 : int.
            ((((<=) (0) i_38) /\ ((<) i_38 (Uint32.to_int size_8))) ->
             (Int32.(=) (select intP_intM_a_10_23 (shift a_10 i_38))
             (select intP_intM_a_10_23
             (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_38) (1))))))))
           ->
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 10 15 27#
           "expl:Ensures clause"
           (Int32.(=) result (#"whole_program.jc" 1478 32 44#
           "expl:Integer cast" (Int32.of_int (1))))))
         /\
         ((((=) (Uint32.to_int size_8) (0)) ->
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 6 15 27#
           "expl:Ensures clause"
           (Int32.(=) result (#"whole_program.jc" 1471 32 44#
           "expl:Integer cast" (Int32.of_int (1))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 3 12 40#
         "expl:Ensures clause"
         ((Int32.(=) result (#"whole_program.jc" 1468 33 45#
          "expl:Integer cast" (Int32.of_int (0))))
         \/
         (Int32.(=) result (#"whole_program.jc" 1468 62 74#
         "expl:Integer cast" (Int32.of_int (1))))))))) }
  
end

module Function_palindrome_safe

  use enum.Uint32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val palindrome
  (a_10 : (pointer voidP)) 
   (size_8 : Uint32.t) 
    (voidP_a_10_23_alloc_table : (alloc_table voidP)) 
     (voidP_a_10_23_tag_table : (tag_table voidP)) 
      (intP_intM_a_10_23 : (memory voidP Int32.t)) : Int32.t
       requires {
         ("expl:Internal"
         (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 1 13 34#
         "expl:Requires clause"
         (if ((<=) (0) (Int.(-) (Uint32.to_int size_8) (1))) then
          (((<=) (offset_min voidP_a_10_23_alloc_table a_10) (0)) /\
          (((>=) (offset_max voidP_a_10_23_alloc_table a_10)
           (Int.(-) (Uint32.to_int size_8) (1)))
          /\
          (forall __framac_tmp23 : int.
           ((((<=) (0) __framac_tmp23) /\
            ((<=) __framac_tmp23 (Int.(-) (Uint32.to_int size_8) (1)))) ->
            ((=) true true))))) else ((=) true true)))) }
       ensures {
         (((((>) (Uint32.to_int size_8) (0)) /\
           (exists i_37 : int.
            (((<=) (0) i_37) /\
            (((<) i_37 (Uint32.to_int size_8)) /\
            (Int32.(<>) (select intP_intM_a_10_23 (shift a_10 i_37))
            (select intP_intM_a_10_23
            (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_37) (1)))))))))
           ->
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 14 15 27#
           "expl:Ensures clause"
           (Int32.(=) result (#"whole_program.jc" 1485 32 44#
           "expl:Integer cast" (Int32.of_int (0))))))
         /\
         (((((>) (Uint32.to_int size_8) (0)) /\
           (forall i_38 : int.
            ((((<=) (0) i_38) /\ ((<) i_38 (Uint32.to_int size_8))) ->
             (Int32.(=) (select intP_intM_a_10_23 (shift a_10 i_38))
             (select intP_intM_a_10_23
             (shift a_10 (Int.(-) (Int.(-) (Uint32.to_int size_8) i_38) (1))))))))
           ->
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 10 15 27#
           "expl:Ensures clause"
           (Int32.(=) result (#"whole_program.jc" 1478 32 44#
           "expl:Integer cast" (Int32.of_int (1))))))
         /\
         ((((=) (Uint32.to_int size_8) (0)) ->
           (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 6 15 27#
           "expl:Ensures clause"
           (Int32.(=) result (#"whole_program.jc" 1471 32 44#
           "expl:Integer cast" (Int32.of_int (1))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./palindrome.c" 3 12 40#
         "expl:Ensures clause"
         ((Int32.(=) result (#"whole_program.jc" 1468 33 45#
          "expl:Integer cast" (Int32.of_int (0))))
         \/
         (Int32.(=) result (#"whole_program.jc" 1468 62 74#
         "expl:Integer cast" (Int32.of_int (1))))))))) }
  
end

module Function_reverse

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val reverse
  (a_11 : (pointer voidP)) 
   (res : (pointer voidP)) 
    (size_9 : Int32.t) 
     (intP_intM_res_25 : ref (memory voidP Int32.t)) 
      (voidP_res_25_alloc_table : (alloc_table voidP)) 
       (voidP_a_11_24_alloc_table : (alloc_table voidP)) 
        (voidP_res_25_tag_table : (tag_table voidP)) 
         (voidP_a_11_24_tag_table : (tag_table voidP)) 
          (intP_intM_a_11_24 : (memory voidP Int32.t)) : unit
           requires { true } reads { intP_intM_res_25 } writes {
           intP_intM_res_25 }
           ensures {
             ((#"whole_program.jc" 1618 10 53# "expl:Assigns clause"
              (not_assigns voidP_res_25_alloc_table voidP_res_25_alloc_table
              (old !intP_intM_res_25) !intP_intM_res_25
              (pset_range (pset_singleton res) (0)
              (Int.(-) (Int32.to_int size_9) (1)))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./reverse.c" 6 12 74#
             "expl:Ensures clause"
             (forall i_39 : int.
              ((((<=) (0) i_39) /\ ((<) i_39 (Int32.to_int size_9))) ->
               (Int32.(=) (select !intP_intM_res_25 (shift res i_39))
               (select intP_intM_a_11_24
               (shift a_11
               (Int.(-) (Int.(-) (Int32.to_int size_9) i_39) (1))))))))) }
  
end

module Function_reverse_safe

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val reverse
  (a_11 : (pointer voidP)) 
   (res : (pointer voidP)) 
    (size_9 : Int32.t) 
     (intP_intM_res_25 : ref (memory voidP Int32.t)) 
      (voidP_res_25_alloc_table : (alloc_table voidP)) 
       (voidP_a_11_24_alloc_table : (alloc_table voidP)) 
        (voidP_res_25_tag_table : (tag_table voidP)) 
         (voidP_a_11_24_tag_table : (tag_table voidP)) 
          (intP_intM_a_11_24 : (memory voidP Int32.t)) : unit
           requires {
             ("expl:Internal"
             (#"whole_program.jc" 1596 12 1392# "expl:Requires clause"
             ((#"/home/work/workspace/education/acsl-exam/./reverse.c" 2 13 22#
              "expl:Requires clause"
              (Int32.(>=) size_9 (#"whole_program.jc" 1596 33 45#
              "expl:Integer cast" (Int32.of_int (0)))))
             /\
             (#"whole_program.jc" 1596 12 1392# "expl:Requires clause"
             ((#"/home/work/workspace/education/acsl-exam/./reverse.c" 3 13 34#
              "expl:Requires clause"
              (if ((<=) (0) (Int.(-) (Int32.to_int size_9) (1))) then
               (((<=) (offset_min voidP_a_11_24_alloc_table a_11) (0)) /\
               (((>=) (offset_max voidP_a_11_24_alloc_table a_11)
                (Int.(-) (Int32.to_int size_9) (1)))
               /\
               (forall __framac_tmp24 : int.
                ((((<=) (0) __framac_tmp24) /\
                 ((<=) __framac_tmp24 (Int.(-) (Int32.to_int size_9) (1))))
                 -> ((=) true true))))) else ((=) true true)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./reverse.c" 4 13 36#
             "expl:Requires clause"
             (if ((<=) (0) (Int.(-) (Int32.to_int size_9) (1))) then
              (((<=) (offset_min voidP_res_25_alloc_table res) (0)) /\
              (((>=) (offset_max voidP_res_25_alloc_table res)
               (Int.(-) (Int32.to_int size_9) (1)))
              /\
              (forall __framac_tmp25 : int.
               ((((<=) (0) __framac_tmp25) /\
                ((<=) __framac_tmp25 (Int.(-) (Int32.to_int size_9) (1)))) ->
                ((=) true true))))) else ((=) true true)))))))) }
           reads { intP_intM_res_25 } writes { intP_intM_res_25 }
           ensures {
             ((#"whole_program.jc" 1618 10 53# "expl:Assigns clause"
              (not_assigns voidP_res_25_alloc_table voidP_res_25_alloc_table
              (old !intP_intM_res_25) !intP_intM_res_25
              (pset_range (pset_singleton res) (0)
              (Int.(-) (Int32.to_int size_9) (1)))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./reverse.c" 6 12 74#
             "expl:Ensures clause"
             (forall i_39 : int.
              ((((<=) (0) i_39) /\ ((<) i_39 (Int32.to_int size_9))) ->
               (Int32.(=) (select !intP_intM_res_25 (shift res i_39))
               (select intP_intM_a_11_24
               (shift a_11
               (Int.(-) (Int.(-) (Int32.to_int size_9) i_39) (1))))))))) }
  
end

module Function_reverse_in_place

  use import ref.Ref 
  
  use import Logic_reverse_0 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val reverse_in_place
  (a_12 : (pointer voidP)) 
   (size_10 : Int32.t) 
    (intP_intM_a_12_29 : ref (memory voidP Int32.t)) 
     (voidP_a_12_29_alloc_table : (alloc_table voidP)) : unit
      requires { true } reads { intP_intM_a_12_29 } writes {
      intP_intM_a_12_29 }
      ensures {
        ((#"whole_program.jc" 1710 10 55# "expl:Assigns clause"
         (not_assigns voidP_a_12_29_alloc_table voidP_a_12_29_alloc_table
         (old !intP_intM_a_12_29) !intP_intM_a_12_29
         (pset_range (pset_singleton a_12) (0)
         (Int.(-) (Int32.to_int size_10) (1)))))
        /\
        (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 27 12 38#
        "expl:Ensures clause"
        (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 27 12 38#
        "expl:Ensures clause"
        ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 27 12 38#
         "expl:Ensures clause"
         (reverse_0 a_12 (Int32.to_int size_10) !intP_intM_a_12_29 (old
         !intP_intM_a_12_29)))
        /\
        (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 28 12 121#
        "expl:Ensures clause"
        (forall i_41 : int.
         ((((<=) (0) i_41) /\ ((<) i_41 (Int32.to_int size_10))) ->
          (exists j_23 : int.
           (((<=) (0) j_23) /\
           (((<) j_23 (Int32.to_int size_10)) /\
           (Int32.(=) (select !intP_intM_a_12_29 (shift a_12 i_41))
           (select !intP_intM_a_12_29 (shift a_12 j_23))))))))))))) }
  
end

module Function_reverse_in_place_safe

  use import ref.Ref 
  
  use import Logic_reverse_0 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val reverse_in_place
  (a_12 : (pointer voidP)) 
   (size_10 : Int32.t) 
    (intP_intM_a_12_29 : ref (memory voidP Int32.t)) 
     (voidP_a_12_29_alloc_table : (alloc_table voidP)) : unit
      requires {
        ("expl:Internal"
        (#"whole_program.jc" 1698 12 709# "expl:Requires clause"
        ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 24 13 22#
         "expl:Requires clause"
         (Int32.(>=) size_10 (#"whole_program.jc" 1698 34 46#
         "expl:Integer cast" (Int32.of_int (0)))))
        /\
        (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 25 13 34#
        "expl:Requires clause"
        (if ((<=) (0) (Int.(-) (Int32.to_int size_10) (1))) then
         (((<=) (offset_min voidP_a_12_29_alloc_table a_12) (0)) /\
         (((>=) (offset_max voidP_a_12_29_alloc_table a_12)
          (Int.(-) (Int32.to_int size_10) (1)))
         /\
         (forall __framac_tmp28 : int.
          ((((<=) (0) __framac_tmp28) /\
           ((<=) __framac_tmp28 (Int.(-) (Int32.to_int size_10) (1)))) ->
           ((=) true true))))) else ((=) true true)))))) }
      reads { intP_intM_a_12_29 } writes { intP_intM_a_12_29 }
      ensures {
        ((#"whole_program.jc" 1710 10 55# "expl:Assigns clause"
         (not_assigns voidP_a_12_29_alloc_table voidP_a_12_29_alloc_table
         (old !intP_intM_a_12_29) !intP_intM_a_12_29
         (pset_range (pset_singleton a_12) (0)
         (Int.(-) (Int32.to_int size_10) (1)))))
        /\
        (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 27 12 38#
        "expl:Ensures clause"
        (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 27 12 38#
        "expl:Ensures clause"
        ((#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 27 12 38#
         "expl:Ensures clause"
         (reverse_0 a_12 (Int32.to_int size_10) !intP_intM_a_12_29 (old
         !intP_intM_a_12_29)))
        /\
        (#"/home/work/workspace/education/acsl-exam/./reverse_in_place.c" 28 12 121#
        "expl:Ensures clause"
        (forall i_41 : int.
         ((((<=) (0) i_41) /\ ((<) i_41 (Int32.to_int size_10))) ->
          (exists j_23 : int.
           (((<=) (0) j_23) /\
           (((<) j_23 (Int32.to_int size_10)) /\
           (Int32.(=) (select !intP_intM_a_12_29 (shift a_12 i_41))
           (select !intP_intM_a_12_29 (shift a_12 j_23))))))))))))) }
  
end

module Function_set_even

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val set_even
  (p_0 : (pointer voidP)) 
   (size_11 : Int32.t) 
    (val_1 : Int32.t) 
     (intP_intM_p_30 : ref (memory voidP Int32.t)) 
      (voidP_p_30_alloc_table : (alloc_table voidP)) 
       (voidP_p_30_tag_table : (tag_table voidP)) : unit
        requires { true } reads { intP_intM_p_30 } writes { intP_intM_p_30 }
        ensures {
          ((#"whole_program.jc" 1784 10 52# "expl:Assigns clause"
           (not_assigns voidP_p_30_alloc_table voidP_p_30_alloc_table (old
           !intP_intM_p_30) !intP_intM_p_30
           (pset_range (pset_singleton p_0) (0)
           (Int.(-) (Int32.to_int size_11) (1)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_even.c" 4 12 74#
          "expl:Ensures clause"
          (#"/home/work/workspace/education/acsl-exam/./set_even.c" 4 12 74#
          "expl:Ensures clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_even.c" 4 12 74#
           "expl:Ensures clause"
           (forall j_26 : int.
            ((((<=) (0) j_26) /\
             (((<) j_26 (Int32.to_int size_11)) /\
             ((=) (ComputerDivision.mod j_26 (2)) (0)))) ->
             (Int32.(=) (select !intP_intM_p_30 (shift p_0 j_26)) val_1))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_even.c" 5 12 81#
          "expl:Ensures clause"
          (forall j_27 : int.
           ((((<=) (0) j_27) /\
            (((<) j_27 (Int32.to_int size_11)) /\
            ((<>) (ComputerDivision.mod j_27 (2)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_30 (shift p_0 j_27))
            (select (old !intP_intM_p_30) (shift p_0 j_27)))))))))) }
  
end

module Function_set_even_safe

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val set_even
  (p_0 : (pointer voidP)) 
   (size_11 : Int32.t) 
    (val_1 : Int32.t) 
     (intP_intM_p_30 : ref (memory voidP Int32.t)) 
      (voidP_p_30_alloc_table : (alloc_table voidP)) 
       (voidP_p_30_tag_table : (tag_table voidP)) : unit
        requires {
          ("expl:Internal"
          (#"whole_program.jc" 1772 12 703# "expl:Requires clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_even.c" 1 13 22#
           "expl:Requires clause"
           (Int32.(>=) size_11 (#"whole_program.jc" 1772 34 46#
           "expl:Integer cast" (Int32.of_int (0)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_even.c" 2 13 34#
          "expl:Requires clause"
          (if ((<=) (0) (Int.(-) (Int32.to_int size_11) (1))) then
           (((<=) (offset_min voidP_p_30_alloc_table p_0) (0)) /\
           (((>=) (offset_max voidP_p_30_alloc_table p_0)
            (Int.(-) (Int32.to_int size_11) (1)))
           /\
           (forall __framac_tmp29 : int.
            ((((<=) (0) __framac_tmp29) /\
             ((<=) __framac_tmp29 (Int.(-) (Int32.to_int size_11) (1)))) ->
             ((=) true true))))) else ((=) true true)))))) }
        reads { intP_intM_p_30 } writes { intP_intM_p_30 }
        ensures {
          ((#"whole_program.jc" 1784 10 52# "expl:Assigns clause"
           (not_assigns voidP_p_30_alloc_table voidP_p_30_alloc_table (old
           !intP_intM_p_30) !intP_intM_p_30
           (pset_range (pset_singleton p_0) (0)
           (Int.(-) (Int32.to_int size_11) (1)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_even.c" 4 12 74#
          "expl:Ensures clause"
          (#"/home/work/workspace/education/acsl-exam/./set_even.c" 4 12 74#
          "expl:Ensures clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_even.c" 4 12 74#
           "expl:Ensures clause"
           (forall j_26 : int.
            ((((<=) (0) j_26) /\
             (((<) j_26 (Int32.to_int size_11)) /\
             ((=) (ComputerDivision.mod j_26 (2)) (0)))) ->
             (Int32.(=) (select !intP_intM_p_30 (shift p_0 j_26)) val_1))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_even.c" 5 12 81#
          "expl:Ensures clause"
          (forall j_27 : int.
           ((((<=) (0) j_27) /\
            (((<) j_27 (Int32.to_int size_11)) /\
            ((<>) (ComputerDivision.mod j_27 (2)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_30 (shift p_0 j_27))
            (select (old !intP_intM_p_30) (shift p_0 j_27)))))))))) }
  
end

module Function_set_odd

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val set_odd
  (p_0_0 : (pointer voidP)) 
   (size_12 : Int32.t) 
    (val_2 : Int32.t) 
     (intP_intM_p_0_31 : ref (memory voidP Int32.t)) 
      (voidP_p_0_31_alloc_table : (alloc_table voidP)) 
       (voidP_p_0_31_tag_table : (tag_table voidP)) : unit
        requires { true } reads { intP_intM_p_0_31 } writes {
        intP_intM_p_0_31 }
        ensures {
          ((#"whole_program.jc" 1855 10 54# "expl:Assigns clause"
           (not_assigns voidP_p_0_31_alloc_table voidP_p_0_31_alloc_table
           (old !intP_intM_p_0_31) !intP_intM_p_0_31
           (pset_range (pset_singleton p_0_0) (0)
           (Int.(-) (Int32.to_int size_12) (1)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 4 12 74#
          "expl:Ensures clause"
          (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 4 12 74#
          "expl:Ensures clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 4 12 74#
           "expl:Ensures clause"
           (forall j_30 : int.
            ((((<=) (0) j_30) /\
             (((<) j_30 (Int32.to_int size_12)) /\
             ((<>) (ComputerDivision.mod j_30 (2)) (0)))) ->
             (Int32.(=) (select !intP_intM_p_0_31 (shift p_0_0 j_30)) val_2))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 5 12 81#
          "expl:Ensures clause"
          (forall j_31 : int.
           ((((<=) (0) j_31) /\
            (((<) j_31 (Int32.to_int size_12)) /\
            ((=) (ComputerDivision.mod j_31 (2)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_0_31 (shift p_0_0 j_31))
            (select (old !intP_intM_p_0_31) (shift p_0_0 j_31)))))))))) }
  
end

module Function_set_odd_safe

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val set_odd
  (p_0_0 : (pointer voidP)) 
   (size_12 : Int32.t) 
    (val_2 : Int32.t) 
     (intP_intM_p_0_31 : ref (memory voidP Int32.t)) 
      (voidP_p_0_31_alloc_table : (alloc_table voidP)) 
       (voidP_p_0_31_tag_table : (tag_table voidP)) : unit
        requires {
          ("expl:Internal"
          (#"whole_program.jc" 1843 12 707# "expl:Requires clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 1 13 22#
           "expl:Requires clause"
           (Int32.(>=) size_12 (#"whole_program.jc" 1843 34 46#
           "expl:Integer cast" (Int32.of_int (0)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 2 13 34#
          "expl:Requires clause"
          (if ((<=) (0) (Int.(-) (Int32.to_int size_12) (1))) then
           (((<=) (offset_min voidP_p_0_31_alloc_table p_0_0) (0)) /\
           (((>=) (offset_max voidP_p_0_31_alloc_table p_0_0)
            (Int.(-) (Int32.to_int size_12) (1)))
           /\
           (forall __framac_tmp30 : int.
            ((((<=) (0) __framac_tmp30) /\
             ((<=) __framac_tmp30 (Int.(-) (Int32.to_int size_12) (1)))) ->
             ((=) true true))))) else ((=) true true)))))) }
        reads { intP_intM_p_0_31 } writes { intP_intM_p_0_31 }
        ensures {
          ((#"whole_program.jc" 1855 10 54# "expl:Assigns clause"
           (not_assigns voidP_p_0_31_alloc_table voidP_p_0_31_alloc_table
           (old !intP_intM_p_0_31) !intP_intM_p_0_31
           (pset_range (pset_singleton p_0_0) (0)
           (Int.(-) (Int32.to_int size_12) (1)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 4 12 74#
          "expl:Ensures clause"
          (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 4 12 74#
          "expl:Ensures clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_odd.c" 4 12 74#
           "expl:Ensures clause"
           (forall j_30 : int.
            ((((<=) (0) j_30) /\
             (((<) j_30 (Int32.to_int size_12)) /\
             ((<>) (ComputerDivision.mod j_30 (2)) (0)))) ->
             (Int32.(=) (select !intP_intM_p_0_31 (shift p_0_0 j_30)) val_2))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_odd.c" 5 12 81#
          "expl:Ensures clause"
          (forall j_31 : int.
           ((((<=) (0) j_31) /\
            (((<) j_31 (Int32.to_int size_12)) /\
            ((=) (ComputerDivision.mod j_31 (2)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_0_31 (shift p_0_0 j_31))
            (select (old !intP_intM_p_0_31) (shift p_0_0 j_31)))))))))) }
  
end

module Function_set_odd_even_skip

  use enum.Uint32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val set_odd_even_skip
  (a_13 : (pointer voidP)) 
   (n_11 : Uint32.t) 
    (intP_intM_a_13_32 : ref (memory voidP Int32.t)) 
     (voidP_a_13_32_alloc_table : (alloc_table voidP)) 
      (voidP_a_13_32_tag_table : (tag_table voidP)) : unit
       requires { true } reads { intP_intM_a_13_32 } writes {
       intP_intM_a_13_32 }
       ensures {
         ((#"whole_program.jc" 1925 10 52# "expl:Assigns clause"
          (not_assigns voidP_a_13_32_alloc_table voidP_a_13_32_alloc_table
          (old !intP_intM_a_13_32) !intP_intM_a_13_32
          (pset_range (pset_singleton a_13) (0)
          (Int.(-) (Uint32.to_int n_11) (1)))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
         "expl:Ensures clause"
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
          "expl:Ensures clause"
          (forall i_42 : int.
           ((((<=) (0) i_42) /\
            (((<) i_42 (Uint32.to_int n_11)) /\
            (((=) (ComputerDivision.mod i_42 (2)) (0)) /\
            ((<>) (ComputerDivision.mod i_42 (3)) (0))))) ->
            (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 i_42))
            (#"whole_program.jc" 1932 37 49# "expl:Integer cast"
            (Int32.of_int (1)))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 5 12 87#
          "expl:Ensures clause"
          (forall i_43 : int.
           ((((<=) (0) i_43) /\
            (((<) i_43 (Uint32.to_int n_11)) /\
            (((=) (ComputerDivision.mod i_43 (2)) (1)) /\
            ((<>) (ComputerDivision.mod i_43 (3)) (0))))) ->
            (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 i_43))
            (#"whole_program.jc" 1939 39 51# "expl:Integer cast"
            (Int32.of_int (0)))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 6 12 80#
         "expl:Ensures clause"
         (forall i_44 : int.
          ((((<=) (0) i_44) /\
           (((<) i_44 (Uint32.to_int n_11)) /\
           ((=) (ComputerDivision.mod i_44 (3)) (0)))) ->
           (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 i_44))
           (select (old !intP_intM_a_13_32) (shift a_13 i_44)))))))))))) }
  
end

module Function_set_odd_even_skip_safe

  use enum.Uint32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val set_odd_even_skip
  (a_13 : (pointer voidP)) 
   (n_11 : Uint32.t) 
    (intP_intM_a_13_32 : ref (memory voidP Int32.t)) 
     (voidP_a_13_32_alloc_table : (alloc_table voidP)) 
      (voidP_a_13_32_tag_table : (tag_table voidP)) : unit
       requires {
         ("expl:Internal"
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 2 13 31#
         "expl:Requires clause"
         (if ((<=) (0) (Int.(-) (Uint32.to_int n_11) (1))) then
          (((<=) (offset_min voidP_a_13_32_alloc_table a_13) (0)) /\
          (((>=) (offset_max voidP_a_13_32_alloc_table a_13)
           (Int.(-) (Uint32.to_int n_11) (1)))
          /\
          (forall __framac_tmp31 : int.
           ((((<=) (0) __framac_tmp31) /\
            ((<=) __framac_tmp31 (Int.(-) (Uint32.to_int n_11) (1)))) ->
            ((=) true true))))) else ((=) true true)))) }
       reads { intP_intM_a_13_32 } writes { intP_intM_a_13_32 }
       ensures {
         ((#"whole_program.jc" 1925 10 52# "expl:Assigns clause"
          (not_assigns voidP_a_13_32_alloc_table voidP_a_13_32_alloc_table
          (old !intP_intM_a_13_32) !intP_intM_a_13_32
          (pset_range (pset_singleton a_13) (0)
          (Int.(-) (Uint32.to_int n_11) (1)))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
         "expl:Ensures clause"
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
          "expl:Ensures clause"
          (forall i_42 : int.
           ((((<=) (0) i_42) /\
            (((<) i_42 (Uint32.to_int n_11)) /\
            (((=) (ComputerDivision.mod i_42 (2)) (0)) /\
            ((<>) (ComputerDivision.mod i_42 (3)) (0))))) ->
            (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 i_42))
            (#"whole_program.jc" 1932 37 49# "expl:Integer cast"
            (Int32.of_int (1)))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 4 12 87#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 5 12 87#
          "expl:Ensures clause"
          (forall i_43 : int.
           ((((<=) (0) i_43) /\
            (((<) i_43 (Uint32.to_int n_11)) /\
            (((=) (ComputerDivision.mod i_43 (2)) (1)) /\
            ((<>) (ComputerDivision.mod i_43 (3)) (0))))) ->
            (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 i_43))
            (#"whole_program.jc" 1939 39 51# "expl:Integer cast"
            (Int32.of_int (0)))))))
         /\
         (#"/home/work/workspace/education/acsl-exam/./set_odd_even_skip.c" 6 12 80#
         "expl:Ensures clause"
         (forall i_44 : int.
          ((((<=) (0) i_44) /\
           (((<) i_44 (Uint32.to_int n_11)) /\
           ((=) (ComputerDivision.mod i_44 (3)) (0)))) ->
           (Int32.(=) (select !intP_intM_a_13_32 (shift a_13 i_44))
           (select (old !intP_intM_a_13_32) (shift a_13 i_44)))))))))))) }
  
end

module Function_set_only_third

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val set_only_third
  (p_1 : (pointer voidP)) 
   (size_13 : Int32.t) 
    (val_3 : Int32.t) 
     (intP_intM_p_1_33 : ref (memory voidP Int32.t)) 
      (voidP_p_1_33_alloc_table : (alloc_table voidP)) 
       (voidP_p_1_33_tag_table : (tag_table voidP)) : unit
        requires { true } reads { intP_intM_p_1_33 } writes {
        intP_intM_p_1_33 }
        ensures {
          ((#"whole_program.jc" 2016 10 54# "expl:Assigns clause"
           (not_assigns voidP_p_1_33_alloc_table voidP_p_1_33_alloc_table
           (old !intP_intM_p_1_33) !intP_intM_p_1_33
           (pset_range (pset_singleton p_1) (0)
           (Int.(-) (Int32.to_int size_13) (1)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 4 12 74#
          "expl:Ensures clause"
          (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 4 12 74#
          "expl:Ensures clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 4 12 74#
           "expl:Ensures clause"
           (forall j_37 : int.
            ((((<=) (0) j_37) /\
             (((<) j_37 (Int32.to_int size_13)) /\
             ((=) (ComputerDivision.mod j_37 (3)) (0)))) ->
             (Int32.(=) (select !intP_intM_p_1_33 (shift p_1 j_37)) val_3))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 5 12 81#
          "expl:Ensures clause"
          (forall j_38 : int.
           ((((<=) (0) j_38) /\
            (((<) j_38 (Int32.to_int size_13)) /\
            ((<>) (ComputerDivision.mod j_38 (3)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_1_33 (shift p_1 j_38))
            (select (old !intP_intM_p_1_33) (shift p_1 j_38)))))))))) }
  
end

module Function_set_only_third_safe

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val set_only_third
  (p_1 : (pointer voidP)) 
   (size_13 : Int32.t) 
    (val_3 : Int32.t) 
     (intP_intM_p_1_33 : ref (memory voidP Int32.t)) 
      (voidP_p_1_33_alloc_table : (alloc_table voidP)) 
       (voidP_p_1_33_tag_table : (tag_table voidP)) : unit
        requires {
          ("expl:Internal"
          (#"whole_program.jc" 2004 12 707# "expl:Requires clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 1 13 22#
           "expl:Requires clause"
           (Int32.(>=) size_13 (#"whole_program.jc" 2004 34 46#
           "expl:Integer cast" (Int32.of_int (0)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 2 13 34#
          "expl:Requires clause"
          (if ((<=) (0) (Int.(-) (Int32.to_int size_13) (1))) then
           (((<=) (offset_min voidP_p_1_33_alloc_table p_1) (0)) /\
           (((>=) (offset_max voidP_p_1_33_alloc_table p_1)
            (Int.(-) (Int32.to_int size_13) (1)))
           /\
           (forall __framac_tmp32 : int.
            ((((<=) (0) __framac_tmp32) /\
             ((<=) __framac_tmp32 (Int.(-) (Int32.to_int size_13) (1)))) ->
             ((=) true true))))) else ((=) true true)))))) }
        reads { intP_intM_p_1_33 } writes { intP_intM_p_1_33 }
        ensures {
          ((#"whole_program.jc" 2016 10 54# "expl:Assigns clause"
           (not_assigns voidP_p_1_33_alloc_table voidP_p_1_33_alloc_table
           (old !intP_intM_p_1_33) !intP_intM_p_1_33
           (pset_range (pset_singleton p_1) (0)
           (Int.(-) (Int32.to_int size_13) (1)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 4 12 74#
          "expl:Ensures clause"
          (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 4 12 74#
          "expl:Ensures clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 4 12 74#
           "expl:Ensures clause"
           (forall j_37 : int.
            ((((<=) (0) j_37) /\
             (((<) j_37 (Int32.to_int size_13)) /\
             ((=) (ComputerDivision.mod j_37 (3)) (0)))) ->
             (Int32.(=) (select !intP_intM_p_1_33 (shift p_1 j_37)) val_3))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_only_third.c" 5 12 81#
          "expl:Ensures clause"
          (forall j_38 : int.
           ((((<=) (0) j_38) /\
            (((<) j_38 (Int32.to_int size_13)) /\
            ((<>) (ComputerDivision.mod j_38 (3)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_1_33 (shift p_1 j_38))
            (select (old !intP_intM_p_1_33) (shift p_1 j_38)))))))))) }
  
end

module Function_set_skip_third

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val set_skip_third
  (p_2 : (pointer voidP)) 
   (size_14 : Int32.t) 
    (val_4 : Int32.t) 
     (intP_intM_p_2_34 : ref (memory voidP Int32.t)) 
      (voidP_p_2_34_alloc_table : (alloc_table voidP)) 
       (voidP_p_2_34_tag_table : (tag_table voidP)) : unit
        requires { true } reads { intP_intM_p_2_34 } writes {
        intP_intM_p_2_34 }
        ensures {
          ((#"whole_program.jc" 2088 10 54# "expl:Assigns clause"
           (not_assigns voidP_p_2_34_alloc_table voidP_p_2_34_alloc_table
           (old !intP_intM_p_2_34) !intP_intM_p_2_34
           (pset_range (pset_singleton p_2) (0)
           (Int.(-) (Int32.to_int size_14) (1)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 7 12 82#
          "expl:Ensures clause"
          (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 7 12 82#
          "expl:Ensures clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 7 12 82#
           "expl:Ensures clause"
           (forall j_41 : int.
            ((((<=) (0) j_41) /\
             (((<) j_41 (Int32.to_int size_14)) /\
             ((<>) (ComputerDivision.mod j_41 (3)) (0)))) ->
             ((=) (Int32.to_int (select !intP_intM_p_2_34 (shift p_2 j_41)))
             (Int.(+) (Int32.to_int val_4) (ComputerDivision.mod j_41 (3)))))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 8 12 81#
          "expl:Ensures clause"
          (forall j_42 : int.
           ((((<=) (0) j_42) /\
            (((<) j_42 (Int32.to_int size_14)) /\
            ((=) (ComputerDivision.mod j_42 (3)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_2_34 (shift p_2 j_42))
            (select (old !intP_intM_p_2_34) (shift p_2 j_42)))))))))) }
  
end

module Function_set_skip_third_safe

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_range 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val set_skip_third
  (p_2 : (pointer voidP)) 
   (size_14 : Int32.t) 
    (val_4 : Int32.t) 
     (intP_intM_p_2_34 : ref (memory voidP Int32.t)) 
      (voidP_p_2_34_alloc_table : (alloc_table voidP)) 
       (voidP_p_2_34_tag_table : (tag_table voidP)) : unit
        requires {
          ("expl:Internal"
          (#"whole_program.jc" 2075 12 782# "expl:Requires clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 3 13 22#
           "expl:Requires clause"
           (Int32.(>=) size_14 (#"whole_program.jc" 2075 34 46#
           "expl:Integer cast" (Int32.of_int (0)))))
          /\
          (#"whole_program.jc" 2075 12 782# "expl:Requires clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 4 13 34#
           "expl:Requires clause"
           (if ((<=) (0) (Int.(-) (Int32.to_int size_14) (1))) then
            (((<=) (offset_min voidP_p_2_34_alloc_table p_2) (0)) /\
            (((>=) (offset_max voidP_p_2_34_alloc_table p_2)
             (Int.(-) (Int32.to_int size_14) (1)))
            /\
            (forall __framac_tmp33 : int.
             ((((<=) (0) __framac_tmp33) /\
              ((<=) __framac_tmp33 (Int.(-) (Int32.to_int size_14) (1)))) ->
              ((=) true true))))) else ((=) true true)))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 5 13 28#
          "expl:Requires clause"
          ((<) (Int.(+) (Int32.to_int val_4) (2)) (32767)))))))) }
        reads { intP_intM_p_2_34 } writes { intP_intM_p_2_34 }
        ensures {
          ((#"whole_program.jc" 2088 10 54# "expl:Assigns clause"
           (not_assigns voidP_p_2_34_alloc_table voidP_p_2_34_alloc_table
           (old !intP_intM_p_2_34) !intP_intM_p_2_34
           (pset_range (pset_singleton p_2) (0)
           (Int.(-) (Int32.to_int size_14) (1)))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 7 12 82#
          "expl:Ensures clause"
          (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 7 12 82#
          "expl:Ensures clause"
          ((#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 7 12 82#
           "expl:Ensures clause"
           (forall j_41 : int.
            ((((<=) (0) j_41) /\
             (((<) j_41 (Int32.to_int size_14)) /\
             ((<>) (ComputerDivision.mod j_41 (3)) (0)))) ->
             ((=) (Int32.to_int (select !intP_intM_p_2_34 (shift p_2 j_41)))
             (Int.(+) (Int32.to_int val_4) (ComputerDivision.mod j_41 (3)))))))
          /\
          (#"/home/work/workspace/education/acsl-exam/./set_skip_third.c" 8 12 81#
          "expl:Ensures clause"
          (forall j_42 : int.
           ((((<=) (0) j_42) /\
            (((<) j_42 (Int32.to_int size_14)) /\
            ((=) (ComputerDivision.mod j_42 (3)) (0)))) ->
            (Int32.(=) (select !intP_intM_p_2_34 (shift p_2 j_42))
            (select (old !intP_intM_p_2_34) (shift p_2 j_42)))))))))) }
  
end

module Function_spec_sign

  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val spec_sign
  (x : Int32.t) : Int32.t
   requires { true }
   ensures {
     (((Int32.(<) x (#"whole_program.jc" 2166 15 27# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 12 15 28#
       "expl:Ensures clause" ((=) (Int32.to_int result) (Int.(-_) (1)))))
     /\
     (((Int32.(=) x (#"whole_program.jc" 2163 16 28# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 9 15 27#
       "expl:Ensures clause"
       (Int32.(=) result (#"whole_program.jc" 2164 32 44# "expl:Integer cast"
       (Int32.of_int (0))))))
     /\
     (((Int32.(>) x (#"whole_program.jc" 2160 15 27# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 6 15 27#
       "expl:Ensures clause"
       (Int32.(=) result (#"whole_program.jc" 2161 32 44# "expl:Integer cast"
       (Int32.of_int (1))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./sign.c" 3 12 57#
     "expl:Ensures clause"
     ((Int32.(=) result (#"whole_program.jc" 2157 34 46# "expl:Integer cast"
      (Int32.of_int (0))))
     \/
     ((Int32.(=) result (#"whole_program.jc" 2157 63 75# "expl:Integer cast"
      (Int32.of_int (1))))
     \/ ((=) (Int32.to_int result) (Int.(-_) (1))))))))) }
  
end

module Function_spec_sign_safe

  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val spec_sign
  (x : Int32.t) : Int32.t
   requires { (true) }
   ensures {
     (((Int32.(<) x (#"whole_program.jc" 2166 15 27# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 12 15 28#
       "expl:Ensures clause" ((=) (Int32.to_int result) (Int.(-_) (1)))))
     /\
     (((Int32.(=) x (#"whole_program.jc" 2163 16 28# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 9 15 27#
       "expl:Ensures clause"
       (Int32.(=) result (#"whole_program.jc" 2164 32 44# "expl:Integer cast"
       (Int32.of_int (0))))))
     /\
     (((Int32.(>) x (#"whole_program.jc" 2160 15 27# "expl:Integer cast"
       (Int32.of_int (0)))) ->
       (#"/home/work/workspace/education/acsl-exam/./sign.c" 6 15 27#
       "expl:Ensures clause"
       (Int32.(=) result (#"whole_program.jc" 2161 32 44# "expl:Integer cast"
       (Int32.of_int (1))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./sign.c" 3 12 57#
     "expl:Ensures clause"
     ((Int32.(=) result (#"whole_program.jc" 2157 34 46# "expl:Integer cast"
      (Int32.of_int (0))))
     \/
     ((Int32.(=) result (#"whole_program.jc" 2157 63 75# "expl:Integer cast"
      (Int32.of_int (1))))
     \/ ((=) (Int32.to_int result) (Int.(-_) (1))))))))) }
  
end

module Function_sum_0

  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Sum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val sum_0
  (a_16 : Int32.t) 
   (b_4 : Int32.t) : Int32.t
    requires { true }
    ensures {
      (#"/home/work/workspace/education/acsl-exam/./sum.c" 24 12 32#
      "expl:Ensures clause"
      ((=) (Int32.to_int result)
      (sum (Int32.to_int a_16) (Int32.to_int b_4)))) }
  
end

module Function_sum_0_safe

  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Sum 
  
  use why3.Bool.Bool 
  
  use import Lemma_increasing 
  
  use import Lemma_factorial_ind_20 
  
  val sum_0
  (a_16 : Int32.t) 
   (b_4 : Int32.t) : Int32.t
    requires {
      ("expl:Internal"
      (#"whole_program.jc" 2224 12 242# "expl:Requires clause"
      ((#"/home/work/workspace/education/acsl-exam/./sum.c" 20 13 18#
       "expl:Requires clause" (Int32.(<) a_16 b_4))
      /\
      (#"whole_program.jc" 2224 12 242# "expl:Requires clause"
      ((#"/home/work/workspace/education/acsl-exam/./sum.c" 21 13 19#
       "expl:Requires clause"
       (Int32.(>=) a_16 (#"whole_program.jc" 2225 44 56# "expl:Integer cast"
       (Int32.of_int (0)))))
      /\
      (#"whole_program.jc" 2224 12 242# "expl:Requires clause"
      ((#"/home/work/workspace/education/acsl-exam/./sum.c" 21 23 29#
       "expl:Requires clause"
       (Int32.(>=) b_4 (#"whole_program.jc" 2226 44 56# "expl:Integer cast"
       (Int32.of_int (0)))))
      /\
      (#"/home/work/workspace/education/acsl-exam/./sum.c" 22 13 30#
      "expl:Requires clause"
      ((<) (sum (Int32.to_int a_16) (Int32.to_int b_4)) (32767)))))))))) }
    ensures {
      (#"/home/work/workspace/education/acsl-exam/./sum.c" 24 12 32#
      "expl:Ensures clause"
      ((=) (Int32.to_int result)
      (sum (Int32.to_int a_16) (Int32.to_int b_4)))) }
  
end
