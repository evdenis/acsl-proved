
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Jessie_voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_safe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_unsafe

  use why3.Bool.Bool 
  
end

module Root_intP_safe

  use why3.Bool.Bool 
  
end

module Root_intP_unsafe

  use why3.Bool.Bool 
  
end

theory Root_intP

  use why3.Bool.Bool 
  
  type intP 
  
end

theory Struct_intP

  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function intP_tag  : (tag_id intP)
  
  axiom IntP_parenttag_bottom :
  (parenttag intP_tag bottom_tag)
  
  axiom IntP_is_final :
  (forall intP_tag_table : (tag_table intP).
   (forall p : (pointer intP).
    ((instanceof intP_tag_table p intP_tag) ->
     ((=) (typeof intP_tag_table p) intP_tag))))
  
  predicate frame_tag_struct_intP (p : (pointer intP)) (old_intP_tag_table :
  (tag_table intP)) (intP_tag_table : (tag_table intP))
  =
     ((tag_extends old_intP_tag_table intP_tag_table) /\
     (alloc_tag_block old_intP_tag_table intP_tag_table p))
  
  predicate frame_free_struct_intP (p : (pointer intP)) (old_intP_alloc_table
  : (alloc_table intP)) (intP_alloc_table : (alloc_table intP))
  =
     ((free_extends old_intP_alloc_table intP_alloc_table) /\
     (free_block old_intP_alloc_table intP_alloc_table p))
  
  predicate frame_alloc_struct_intP (p : (pointer intP)) (n : int)
  (old_intP_alloc_table : (alloc_table intP)) (intP_alloc_table :
  (alloc_table intP))
  =
     ((alloc_extends old_intP_alloc_table intP_alloc_table) /\
     (alloc_block old_intP_alloc_table intP_alloc_table p n))
  
  predicate fresh_tag_struct_intP (p : (pointer intP)) (intP_tag_table :
  (tag_table intP)) = (tag_fresh intP_tag_table p)
  
  predicate fresh_alloc_struct_intP (p : (pointer intP)) (intP_alloc_table :
  (alloc_table intP)) = (alloc_fresh intP_alloc_table p)
  
  predicate container_of_singleton_struct_intP (p : (pointer intP))
  (intP_tag_table : (tag_table intP)) = true
  
  predicate container_of_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP)) = true
  
  predicate typeof_singleton_struct_intP (p : (pointer intP)) (intP_tag_table
  : (tag_table intP)) = ((=) (typeof intP_tag_table p) intP_tag)
  
  predicate typeof_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP))
  =
     (((=) (typeof intP_tag_table p) intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof intP_tag_table (shift p i)) intP_tag))))
  
  predicate instanceof_singleton_struct_intP (p : (pointer intP))
  (intP_tag_table : (tag_table intP))
  = (instanceof intP_tag_table p intP_tag)
  
  predicate instanceof_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP))
  =
     ((instanceof intP_tag_table p intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof intP_tag_table (shift p i) intP_tag))))
  
  predicate right_valid_struct_intP (p : (pointer intP)) (b : int)
  (intP_alloc_table : (alloc_table intP))
  = ((>=) (offset_max intP_alloc_table p) b)
  
  predicate left_valid_struct_intP (p : (pointer intP)) (a : int)
  (intP_alloc_table : (alloc_table intP))
  = ((<=) (offset_min intP_alloc_table p) a)
  
  predicate valid_struct_intP (p : (pointer intP)) (a : int) (b : int)
  (intP_alloc_table : (alloc_table intP))
  =
     (((<=) (offset_min intP_alloc_table p) a) /\
     ((>=) (offset_max intP_alloc_table p) b))
  
  predicate strict_valid_struct_intP (p : (pointer intP)) (a : int) (b : int)
  (intP_alloc_table : (alloc_table intP))
  =
     (((=) (offset_min intP_alloc_table p) a) /\
     ((=) (offset_max intP_alloc_table p) b))
  
  axiom IntP_int : ((=) (int_of_tag intP_tag) (4))
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Goto_while_0_break_exc unit
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Function_max_min_in_array_safety

  use import Struct_intP 
  
  use Safe_int32 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_upd_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  let max_min_in_array
  #"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 15 5 59#
  "expl:Function max_min_in_array, safety" =
  fun
   (a_1 : (pointer intP)) (size_4 : Int32.t) (max : (pointer intP)) (min :
   (pointer intP)) (intP_intM_max_3 : ref (memory intP Int32.t))
   (intP_a_1_2_alloc_table : (alloc_table intP)) (intP_max_3_alloc_table :
   (alloc_table intP)) (intP_a_1_2_tag_table : (tag_table intP))
   (intP_intM_a_1_2 : (memory intP Int32.t)) 
   requires {
   (((allocated intP_a_1_2_alloc_table a_1) ->
     (((=) (typeof intP_a_1_2_tag_table a_1) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_1_2_alloc_table a_1) i) /\
       ((<) i (offset_max intP_a_1_2_alloc_table a_1))) ->
       ((=) (typeof intP_a_1_2_tag_table (shift a_1 i)) intP_tag)))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 2 13 22#
    (Int32.(>=) size_4 (#"different_array_iterators.jc" 30 32 44#
    "expl:Integer cast" (Int32.of_int (2)))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 3 13 36#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_4) (1))) then
     (((<=) (offset_min intP_a_1_2_alloc_table a_1) (0)) /\
     (((>=) (offset_max intP_a_1_2_alloc_table a_1)
      (Int.(-) (Int32.to_int size_4) (1)))
     /\
     (forall __framac_tmp1 : int.
      ((((<=) (0) __framac_tmp1) /\
       ((<=) __framac_tmp1 (Int.(-) (Int32.to_int size_4) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 4 13 24#
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((<=) (offset_min intP_max_3_alloc_table max) (0)))
    /\
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((>=) (offset_max intP_max_3_alloc_table max) (0)))
    /\ (#"different_array_iterators.jc" 30 12 1163# ((=) true true)))))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 5 13 24#
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((<=) (offset_min intP_max_3_alloc_table min) (0)))
    /\
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((>=) (offset_max intP_max_3_alloc_table min) (0)))
    /\ (#"different_array_iterators.jc" 30 12 1163# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 6 13 23#
   ((<>) max min))))))))))) } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let mx = ref (Safe_int32.any_  () ) in
    (let mn = ref (Safe_int32.any_  () ) in
    (let i = ref (Safe_int32.any_  () ) in
    begin
    (mx :=
     (let _jessie_58 =
     (#"different_array_iterators.jc" 74 20 32# "expl:Integer cast"
     (Safe_int32.of_int (0))) in
     begin
     (assert {
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 17 3 6#
     "expl:Pointer index bounds" true) }); _jessie_58 end));
     begin
     (mn :=
      (let _jessie_59 =
      (#"different_array_iterators.jc" 75 20 32# "expl:Integer cast"
      (Safe_int32.of_int (1))) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 18 3 6#
      "expl:Pointer index bounds" true) }); _jessie_59 end));
      try
       begin
       (i :=
        (let _jessie_60 =
        (#"different_array_iterators.jc" 77 22 34# "expl:Integer cast"
        (Safe_int32.of_int (2))) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 27 7 10#
        "expl:Pointer index bounds" true) }); _jessie_60 end));
        'Loop_4:
        loop
        invariant { (#"different_array_iterators.jc" 79 9 2455# true) }
          variant {
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 25 20 28#
            (Int.(-) (Int32.to_int size_4) (Int32.to_int !i))) }
         begin
         any unit
         requires { true } reads { size_4 }
         ensures {
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 36#
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 36#
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 29#
             (Int32.(<=) (#"different_array_iterators.jc" 87 39 51#
             "expl:Integer cast" (Int32.of_int (1))) !mn))
            /\
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 27 36#
            (Int32.(<) !mn size_4)))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 36#
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 36#
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 29#
             (Int32.(<=) (#"different_array_iterators.jc" 84 41 53#
             "expl:Integer cast" (Int32.of_int (0))) !mx))
            /\
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 27 36#
            (Int32.(<) !mx size_4)))))
           /\
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 36#
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 36#
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 28#
            (Int32.(<=) (#"different_array_iterators.jc" 81 41 53#
            "expl:Integer cast" (Int32.of_int (2))) !i))
           /\
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 27 36#
           (Int32.(<=) !i size_4))))))) } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 27 18 26#
           (Safe_int32.(<)  !i size_4 )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 28 10 15#
            (Safe_int32.(<>) 
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 28 10 15#
             "expl:Division by zero"
             (Safe_int32.(%)  !i
              (#"different_array_iterators.jc" 107 57 69# "expl:Integer cast"
              (Safe_int32.of_int (2))) ))
             (#"different_array_iterators.jc" 108 33 45# "expl:Integer cast"
             (Safe_int32.of_int (0))) ))
            then
             (if
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 29 13 25#
             (Safe_int32.(>) 
              (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 29 13 18#
              "expl:Pointer dereference"
              (acc_offset_typesafe  intP_a_1_2_alloc_table intP_intM_a_1_2
               a_1 (Safe_int32.to_int  !mn ) ))
              (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 29 21 25#
              "expl:Pointer dereference"
              (acc_offset_typesafe  intP_a_1_2_alloc_table intP_intM_a_1_2
               a_1 (Safe_int32.to_int  !i ) )) ))
             then
              (mn :=
               (let _jessie_62 = !i in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 29 27 33#
               "expl:Pointer index bounds" true) }); _jessie_62 end))
             else ())
            else
             (if
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 31 13 25#
             (Safe_int32.(<) 
              (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 31 13 18#
              "expl:Pointer dereference"
              (acc_offset_typesafe  intP_a_1_2_alloc_table intP_intM_a_1_2
               a_1 (Safe_int32.to_int  !mx ) ))
              (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 31 21 25#
              "expl:Pointer dereference"
              (acc_offset_typesafe  intP_a_1_2_alloc_table intP_intM_a_1_2
               a_1 (Safe_int32.to_int  !i ) )) ))
             then
              (mx :=
               (let _jessie_61 = !i in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 31 27 33#
               "expl:Pointer index bounds" true) }); _jessie_61 end))
             else ()));
            (i :=
             (let _jessie_63 =
             (Safe_int32.(+)  !i
              (#"different_array_iterators.jc" 121 53 65# "expl:Integer cast"
              (Safe_int32.of_int (1))) ) in
             begin
             (assert {
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 27 28 31#
             "expl:Pointer index bounds" true) }); _jessie_63 end)) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end with Goto_while_0_break_exc _jessie_1 ->
       'While_0_break: 'While_0_break: () end;
      begin
      (let _jessie_65 =
      (let _jessie_64 = !mx in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 35 3 12#
      "expl:Pointer index bounds" true) }); _jessie_64 end) in
      (let _jessie_66 = max in
      (let _jessie_67 = (0) in
      (let _jessie_68 = _jessie_66 in
      (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 35 3 12#
      "expl:Pointer dereference"
      (upd  intP_max_3_alloc_table intP_intM_max_3 _jessie_66 _jessie_65 ))))));
       begin
       (let _jessie_70 =
       (let _jessie_69 = !mn in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 36 3 12#
       "expl:Pointer index bounds" true) }); _jessie_69 end) in
       (let _jessie_71 = min in
       (let _jessie_72 = (0) in
       (let _jessie_73 = _jessie_71 in
       (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 36 3 12#
       "expl:Pointer dereference"
       (upd  intP_max_3_alloc_table intP_intM_max_3 _jessie_71 _jessie_70 ))))));
        (raise Return) end end end end))); (raise Return) end with Return ->
    () end
  
end

module Function_max_min_in_array_behaviors

  use Unsafe_int32 
  
  use import Struct_intP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset_union 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  let max_min_in_array_ensures_default
  #"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 15 5 59#
  "expl:Function max_min_in_array, default behavior" =
  fun
   (a_1 : (pointer intP)) (size_4 : Int32.t) (max : (pointer intP)) (min :
   (pointer intP)) (intP_intM_max_3 : ref (memory intP Int32.t))
   (intP_a_1_2_alloc_table : (alloc_table intP)) (intP_max_3_alloc_table :
   (alloc_table intP)) (intP_a_1_2_tag_table : (tag_table intP))
   (intP_intM_a_1_2 : (memory intP Int32.t)) 
   requires {
   (((allocated intP_a_1_2_alloc_table a_1) ->
     (((=) (typeof intP_a_1_2_tag_table a_1) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_1_2_alloc_table a_1) i) /\
       ((<) i (offset_max intP_a_1_2_alloc_table a_1))) ->
       ((=) (typeof intP_a_1_2_tag_table (shift a_1 i)) intP_tag)))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 2 13 22#
    (Int32.(>=) size_4 (#"different_array_iterators.jc" 30 32 44#
    "expl:Integer cast" (Int32.of_int (2)))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 3 13 36#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_4) (1))) then
     (((<=) (offset_min intP_a_1_2_alloc_table a_1) (0)) /\
     (((>=) (offset_max intP_a_1_2_alloc_table a_1)
      (Int.(-) (Int32.to_int size_4) (1)))
     /\
     (forall __framac_tmp1 : int.
      ((((<=) (0) __framac_tmp1) /\
       ((<=) __framac_tmp1 (Int.(-) (Int32.to_int size_4) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 4 13 24#
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((<=) (offset_min intP_max_3_alloc_table max) (0)))
    /\
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((>=) (offset_max intP_max_3_alloc_table max) (0)))
    /\ (#"different_array_iterators.jc" 30 12 1163# ((=) true true)))))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 5 13 24#
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((<=) (offset_min intP_max_3_alloc_table min) (0)))
    /\
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((>=) (offset_max intP_max_3_alloc_table min) (0)))
    /\ (#"different_array_iterators.jc" 30 12 1163# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 6 13 23#
   ((<>) max min))))))))))) }
   ensures {
     ("expl:Postcondition"
     ((#"different_array_iterators.jc" 49 10 30# "expl:Assigns clause"
      (not_assigns intP_max_3_alloc_table intP_max_3_alloc_table (old
      !intP_intM_max_3) !intP_intM_max_3
      (pset_union (pset_singleton max) (pset_singleton min))))
     /\
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 21#
      "expl:Ensures clause"
      (Int32.(<=) (#"different_array_iterators.jc" 51 31 43#
      "expl:Integer cast" (Int32.of_int (0))) (select !intP_intM_max_3 max)))
     /\
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 17 28#
      "expl:Ensures clause" (Int32.(<) (select !intP_intM_max_3 max) size_4))
     /\
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 9 12 21#
      "expl:Ensures clause"
      (Int32.(<=) (#"different_array_iterators.jc" 53 32 44#
      "expl:Integer cast" (Int32.of_int (0))) (select !intP_intM_max_3 min)))
     /\
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 9 17 28#
     "expl:Ensures clause" (Int32.(<) (select !intP_intM_max_3 min) size_4)))))))))))
     } diverges  ->
   'Init:
   try
    begin
    (let mx = ref (Unsafe_int32.any_  () ) in
    (let mn = ref (Unsafe_int32.any_  () ) in
    (let i = ref (Unsafe_int32.any_  () ) in
    begin
    (mx :=
     (#"different_array_iterators.jc" 74 20 32# "expl:Integer cast"
     (Unsafe_int32.of_int (0))));
     begin
     (mn :=
      (#"different_array_iterators.jc" 75 20 32# "expl:Integer cast"
      (Unsafe_int32.of_int (1))));
      try
       begin
       (i :=
        (#"different_array_iterators.jc" 77 22 34# "expl:Integer cast"
        (Unsafe_int32.of_int (2))));
        'Loop_1:
        loop
        invariant
          { (((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 36#
              (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 36#
              ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 28#
               (Int32.(<=) (#"different_array_iterators.jc" 81 41 53#
               "expl:Integer cast" (Int32.of_int (2))) !i))
              /\
              (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 27 36#
              (Int32.(<=) !i size_4)))))
             &&
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 36#
              (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 36#
              ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 29#
               (Int32.(<=) (#"different_array_iterators.jc" 84 41 53#
               "expl:Integer cast" (Int32.of_int (0))) !mx))
              /\
              (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 27 36#
              (Int32.(<) !mx size_4)))))
             &&
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 36#
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 36#
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 29#
              (Int32.(<=) (#"different_array_iterators.jc" 87 39 51#
              "expl:Integer cast" (Int32.of_int (1))) !mn))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 27 36#
             (Int32.(<) !mn size_4)))))))
            /\
            (#"different_array_iterators.jc" 49 10 30# "expl:Assigns clause"
            (not_assigns intP_max_3_alloc_table intP_max_3_alloc_table (at
            !intP_intM_max_3 'Init) !intP_intM_max_3
            (pset_union (pset_singleton max) (pset_singleton min))))) } 
          
         begin
         any unit requires { true } ensures { true } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 27 18 26#
           (Unsafe_int32.(<)  !i size_4 )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 28 10 15#
            (Unsafe_int32.(<>) 
             (Unsafe_int32.(%)  !i
              (#"different_array_iterators.jc" 107 57 69# "expl:Integer cast"
              (Unsafe_int32.of_int (2))) )
             (#"different_array_iterators.jc" 108 33 45# "expl:Integer cast"
             (Unsafe_int32.of_int (0))) ))
            then
             (if
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 29 13 25#
             (Unsafe_int32.(>) 
              (acc  intP_intM_a_1_2
               (shift_  a_1 (Unsafe_int32.to_int  !mn ) ) )
              (acc  intP_intM_a_1_2 (shift_  a_1 (Unsafe_int32.to_int  !i ) )
               ) )) then (mn := !i) else ())
            else
             (if
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 31 13 25#
             (Unsafe_int32.(<) 
              (acc  intP_intM_a_1_2
               (shift_  a_1 (Unsafe_int32.to_int  !mx ) ) )
              (acc  intP_intM_a_1_2 (shift_  a_1 (Unsafe_int32.to_int  !i ) )
               ) )) then (mx := !i) else ()));
            (i :=
             (Unsafe_int32.(+)  !i
              (#"different_array_iterators.jc" 121 53 65# "expl:Integer cast"
              (Unsafe_int32.of_int (1))) )) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end with Goto_while_0_break_exc _jessie_1 ->
       'While_0_break: 'While_0_break: () end;
      begin
      (let _jessie_17 = !mx in
      (let _jessie_18 = max in
      (let _jessie_19 = (0) in
      (let _jessie_20 = _jessie_18 in
      (upd  intP_intM_max_3 _jessie_20 _jessie_17 )))));
       begin
       (let _jessie_22 = !mn in
       (let _jessie_23 = min in
       (let _jessie_24 = (0) in
       (let _jessie_25 = _jessie_23 in
       (upd  intP_intM_max_3 _jessie_25 _jessie_22 ))))); (raise Return) end
      end end end))); (raise Return) end with Return -> () end
  
  let max_min_in_array_ensures_max
  #"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 15 5 59#
  "expl:Function max_min_in_array, behavior max" =
  fun
   (a_1 : (pointer intP)) (size_4 : Int32.t) (max : (pointer intP)) (min :
   (pointer intP)) (intP_intM_max_3 : ref (memory intP Int32.t))
   (intP_a_1_2_alloc_table : (alloc_table intP)) (intP_max_3_alloc_table :
   (alloc_table intP)) (intP_a_1_2_tag_table : (tag_table intP))
   (intP_intM_a_1_2 : (memory intP Int32.t)) 
   requires {
   (((allocated intP_a_1_2_alloc_table a_1) ->
     (((=) (typeof intP_a_1_2_tag_table a_1) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_1_2_alloc_table a_1) i) /\
       ((<) i (offset_max intP_a_1_2_alloc_table a_1))) ->
       ((=) (typeof intP_a_1_2_tag_table (shift a_1 i)) intP_tag)))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 2 13 22#
    (Int32.(>=) size_4 (#"different_array_iterators.jc" 30 32 44#
    "expl:Integer cast" (Int32.of_int (2)))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 3 13 36#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_4) (1))) then
     (((<=) (offset_min intP_a_1_2_alloc_table a_1) (0)) /\
     (((>=) (offset_max intP_a_1_2_alloc_table a_1)
      (Int.(-) (Int32.to_int size_4) (1)))
     /\
     (forall __framac_tmp1 : int.
      ((((<=) (0) __framac_tmp1) /\
       ((<=) __framac_tmp1 (Int.(-) (Int32.to_int size_4) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 4 13 24#
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((<=) (offset_min intP_max_3_alloc_table max) (0)))
    /\
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((>=) (offset_max intP_max_3_alloc_table max) (0)))
    /\ (#"different_array_iterators.jc" 30 12 1163# ((=) true true)))))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 5 13 24#
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((<=) (offset_min intP_max_3_alloc_table min) (0)))
    /\
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((>=) (offset_max intP_max_3_alloc_table min) (0)))
    /\ (#"different_array_iterators.jc" 30 12 1163# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 6 13 23#
   ((<>) max min))))))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 11 15 85#
     "expl:Ensures clause"
     (forall i_2 : int.
      ((((<=) (0) i_2) /\
       (((<) i_2 (Int32.to_int size_4)) /\
       ((=) (ComputerDivision.mod i_2 (2)) (0)))) ->
       (Int32.(<=) (select intP_intM_a_1_2 (shift a_1 i_2))
       (select intP_intM_a_1_2
       (shift a_1 (Int32.to_int (select !intP_intM_max_3 max))))))))) }
   diverges  ->
   'Init:
   try
    begin
    (let mx = ref (Unsafe_int32.any_  () ) in
    (let mn = ref (Unsafe_int32.any_  () ) in
    (let i = ref (Unsafe_int32.any_  () ) in
    begin
    (mx :=
     (#"different_array_iterators.jc" 74 20 32# "expl:Integer cast"
     (Unsafe_int32.of_int (0))));
     begin
     (mn :=
      (#"different_array_iterators.jc" 75 20 32# "expl:Integer cast"
      (Unsafe_int32.of_int (1))));
      try
       begin
       (i :=
        (#"different_array_iterators.jc" 77 22 34# "expl:Integer cast"
        (Unsafe_int32.of_int (2))));
        'Loop_2:
        loop
        invariant
          { (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 23 31 96#
            (forall j_0 : int.
             ((((<=) (0) j_0) /\
              (((<) j_0 (Int32.to_int !i)) /\
              ((=) (ComputerDivision.mod j_0 (2)) (0)))) ->
              (Int32.(<=) (select intP_intM_a_1_2 (shift a_1 j_0))
              (select intP_intM_a_1_2 (shift a_1 (Int32.to_int !mx))))))) } 
          
         begin
         any unit
         requires { true } reads { size_4 }
         ensures {
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 36#
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 36#
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 29#
             (Int32.(<=) (#"different_array_iterators.jc" 87 39 51#
             "expl:Integer cast" (Int32.of_int (1))) !mn))
            /\
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 27 36#
            (Int32.(<) !mn size_4)))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 36#
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 36#
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 29#
             (Int32.(<=) (#"different_array_iterators.jc" 84 41 53#
             "expl:Integer cast" (Int32.of_int (0))) !mx))
            /\
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 27 36#
            (Int32.(<) !mx size_4)))))
           /\
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 36#
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 36#
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 28#
            (Int32.(<=) (#"different_array_iterators.jc" 81 41 53#
            "expl:Integer cast" (Int32.of_int (2))) !i))
           /\
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 27 36#
           (Int32.(<=) !i size_4))))))) } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 27 18 26#
           (Unsafe_int32.(<)  !i size_4 )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 28 10 15#
            (Unsafe_int32.(<>) 
             (Unsafe_int32.(%)  !i
              (#"different_array_iterators.jc" 107 57 69# "expl:Integer cast"
              (Unsafe_int32.of_int (2))) )
             (#"different_array_iterators.jc" 108 33 45# "expl:Integer cast"
             (Unsafe_int32.of_int (0))) ))
            then
             (if
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 29 13 25#
             (Unsafe_int32.(>) 
              (acc  intP_intM_a_1_2
               (shift_  a_1 (Unsafe_int32.to_int  !mn ) ) )
              (acc  intP_intM_a_1_2 (shift_  a_1 (Unsafe_int32.to_int  !i ) )
               ) )) then (mn := !i) else ())
            else
             (if
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 31 13 25#
             (Unsafe_int32.(<) 
              (acc  intP_intM_a_1_2
               (shift_  a_1 (Unsafe_int32.to_int  !mx ) ) )
              (acc  intP_intM_a_1_2 (shift_  a_1 (Unsafe_int32.to_int  !i ) )
               ) )) then (mx := !i) else ()));
            (i :=
             (Unsafe_int32.(+)  !i
              (#"different_array_iterators.jc" 121 53 65# "expl:Integer cast"
              (Unsafe_int32.of_int (1))) )) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end with Goto_while_0_break_exc _jessie_1 ->
       'While_0_break: 'While_0_break: () end;
      begin
      (let _jessie_33 = !mx in
      (let _jessie_34 = max in
      (let _jessie_35 = (0) in
      (let _jessie_36 = _jessie_34 in
      (upd  intP_intM_max_3 _jessie_36 _jessie_33 )))));
       begin
       (let _jessie_38 = !mn in
       (let _jessie_39 = min in
       (let _jessie_40 = (0) in
       (let _jessie_41 = _jessie_39 in
       (upd  intP_intM_max_3 _jessie_41 _jessie_38 ))))); (raise Return) end
      end end end))); (raise Return) end with Return -> () end
  
  let max_min_in_array_ensures_min
  #"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 15 5 59#
  "expl:Function max_min_in_array, behavior min" =
  fun
   (a_1 : (pointer intP)) (size_4 : Int32.t) (max : (pointer intP)) (min :
   (pointer intP)) (intP_intM_max_3 : ref (memory intP Int32.t))
   (intP_a_1_2_alloc_table : (alloc_table intP)) (intP_max_3_alloc_table :
   (alloc_table intP)) (intP_a_1_2_tag_table : (tag_table intP))
   (intP_intM_a_1_2 : (memory intP Int32.t)) 
   requires {
   (((allocated intP_a_1_2_alloc_table a_1) ->
     (((=) (typeof intP_a_1_2_tag_table a_1) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_1_2_alloc_table a_1) i) /\
       ((<) i (offset_max intP_a_1_2_alloc_table a_1))) ->
       ((=) (typeof intP_a_1_2_tag_table (shift a_1 i)) intP_tag)))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 2 13 22#
    (Int32.(>=) size_4 (#"different_array_iterators.jc" 30 32 44#
    "expl:Integer cast" (Int32.of_int (2)))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 3 13 36#
    (if ((<=) (0) (Int.(-) (Int32.to_int size_4) (1))) then
     (((<=) (offset_min intP_a_1_2_alloc_table a_1) (0)) /\
     (((>=) (offset_max intP_a_1_2_alloc_table a_1)
      (Int.(-) (Int32.to_int size_4) (1)))
     /\
     (forall __framac_tmp1 : int.
      ((((<=) (0) __framac_tmp1) /\
       ((<=) __framac_tmp1 (Int.(-) (Int32.to_int size_4) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 4 13 24#
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((<=) (offset_min intP_max_3_alloc_table max) (0)))
    /\
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((>=) (offset_max intP_max_3_alloc_table max) (0)))
    /\ (#"different_array_iterators.jc" 30 12 1163# ((=) true true)))))))
   /\
   (#"different_array_iterators.jc" 30 12 1163#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 5 13 24#
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((<=) (offset_min intP_max_3_alloc_table min) (0)))
    /\
    (#"different_array_iterators.jc" 30 12 1163#
    ((#"different_array_iterators.jc" 30 12 1163#
     ((>=) (offset_max intP_max_3_alloc_table min) (0)))
    /\ (#"different_array_iterators.jc" 30 12 1163# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 6 13 23#
   ((<>) max min))))))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 13 15 85#
     "expl:Ensures clause"
     (forall i_1 : int.
      ((((<=) (0) i_1) /\
       (((<) i_1 (Int32.to_int size_4)) /\
       ((=) (ComputerDivision.mod i_1 (2)) (1)))) ->
       (Int32.(<=)
       (select intP_intM_a_1_2
       (shift a_1 (Int32.to_int (select !intP_intM_max_3 min))))
       (select intP_intM_a_1_2 (shift a_1 i_1))))))) } diverges  ->
   'Init:
   try
    begin
    (let mx = ref (Unsafe_int32.any_  () ) in
    (let mn = ref (Unsafe_int32.any_  () ) in
    (let i = ref (Unsafe_int32.any_  () ) in
    begin
    (mx :=
     (#"different_array_iterators.jc" 74 20 32# "expl:Integer cast"
     (Unsafe_int32.of_int (0))));
     begin
     (mn :=
      (#"different_array_iterators.jc" 75 20 32# "expl:Integer cast"
      (Unsafe_int32.of_int (1))));
      try
       begin
       (i :=
        (#"different_array_iterators.jc" 77 22 34# "expl:Integer cast"
        (Unsafe_int32.of_int (2))));
        'Loop_3:
        loop
        invariant
          { (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 24 31 96#
            (forall j_1 : int.
             ((((<=) (0) j_1) /\
              (((<) j_1 (Int32.to_int !i)) /\
              ((=) (ComputerDivision.mod j_1 (2)) (1)))) ->
              (Int32.(<=)
              (select intP_intM_a_1_2 (shift a_1 (Int32.to_int !mn)))
              (select intP_intM_a_1_2 (shift a_1 j_1)))))) } 
         begin
         any unit
         requires { true } reads { size_4 }
         ensures {
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 36#
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 36#
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 22 29#
             (Int32.(<=) (#"different_array_iterators.jc" 87 39 51#
             "expl:Integer cast" (Int32.of_int (1))) !mn))
            /\
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 22 27 36#
            (Int32.(<) !mn size_4)))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 36#
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 36#
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 22 29#
             (Int32.(<=) (#"different_array_iterators.jc" 84 41 53#
             "expl:Integer cast" (Int32.of_int (0))) !mx))
            /\
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 21 27 36#
            (Int32.(<) !mx size_4)))))
           /\
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 36#
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 36#
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 22 28#
            (Int32.(<=) (#"different_array_iterators.jc" 81 41 53#
            "expl:Integer cast" (Int32.of_int (2))) !i))
           /\
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 20 27 36#
           (Int32.(<=) !i size_4))))))) } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 27 18 26#
           (Unsafe_int32.(<)  !i size_4 )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 28 10 15#
            (Unsafe_int32.(<>) 
             (Unsafe_int32.(%)  !i
              (#"different_array_iterators.jc" 107 57 69# "expl:Integer cast"
              (Unsafe_int32.of_int (2))) )
             (#"different_array_iterators.jc" 108 33 45# "expl:Integer cast"
             (Unsafe_int32.of_int (0))) ))
            then
             (if
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 29 13 25#
             (Unsafe_int32.(>) 
              (acc  intP_intM_a_1_2
               (shift_  a_1 (Unsafe_int32.to_int  !mn ) ) )
              (acc  intP_intM_a_1_2 (shift_  a_1 (Unsafe_int32.to_int  !i ) )
               ) )) then (mn := !i) else ())
            else
             (if
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 31 13 25#
             (Unsafe_int32.(<) 
              (acc  intP_intM_a_1_2
               (shift_  a_1 (Unsafe_int32.to_int  !mx ) ) )
              (acc  intP_intM_a_1_2 (shift_  a_1 (Unsafe_int32.to_int  !i ) )
               ) )) then (mx := !i) else ()));
            (i :=
             (Unsafe_int32.(+)  !i
              (#"different_array_iterators.jc" 121 53 65# "expl:Integer cast"
              (Unsafe_int32.of_int (1))) )) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end with Goto_while_0_break_exc _jessie_1 ->
       'While_0_break: 'While_0_break: () end;
      begin
      (let _jessie_49 = !mx in
      (let _jessie_50 = max in
      (let _jessie_51 = (0) in
      (let _jessie_52 = _jessie_50 in
      (upd  intP_intM_max_3 _jessie_52 _jessie_49 )))));
       begin
       (let _jessie_54 = !mn in
       (let _jessie_55 = min in
       (let _jessie_56 = (0) in
       (let _jessie_57 = _jessie_55 in
       (upd  intP_intM_max_3 _jessie_57 _jessie_54 ))))); (raise Return) end
      end end end))); (raise Return) end with Return -> () end
  
end

module Function_max_in_array_safety

  use import Struct_intP 
  
  use Safe_int32 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  let max_in_array
  #"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 44 4 34#
  "expl:Function max_in_array, safety" =
  fun
   (a : (pointer intP)) (size_2 : Int32.t) (intP_a_5_alloc_table :
   (alloc_table intP)) (intP_a_5_tag_table : (tag_table intP)) (intP_intM_a_5
   : (memory intP Int32.t)) 
   requires {
   (((allocated intP_a_5_alloc_table a) ->
     (((=) (typeof intP_a_5_tag_table a) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_5_alloc_table a) i) /\
       ((<) i (offset_max intP_a_5_alloc_table a))) ->
       ((=) (typeof intP_a_5_tag_table (shift a i)) intP_tag)))))
   /\
   (#"different_array_iterators.jc" 134 12 684#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 39 13 21#
    (Int32.(>) size_2 (#"different_array_iterators.jc" 134 31 43#
    "expl:Integer cast" (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 40 13 38#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
    (((<=) (offset_min intP_a_5_alloc_table a) (0)) /\
    (((>=) (offset_max intP_a_5_alloc_table a)
     (Int.(-) (Int32.to_int size_2) (1)))
    /\
    (forall __framac_tmp4 : int.
     ((((<=) (0) __framac_tmp4) /\
      ((<=) __framac_tmp4 (Int.(-) (Int32.to_int size_2) (1)))) ->
      ((=) true true))))) else ((=) true true)))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_int32.any_  () ) in
   try
    begin
    (let j = ref (Safe_int32.any_  () ) in
    (let max_0 = ref (Safe_int32.any_  () ) in
    (let i_0 = ref (Safe_int32.any_  () ) in
    begin
    (j :=
     (let _jessie_81 =
     (#"different_array_iterators.jc" 160 20 32# "expl:Integer cast"
     (Safe_int32.of_int (0))) in
     begin
     (assert {
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 46 3 6#
     "expl:Pointer index bounds" true) }); _jessie_81 end));
     begin
     (max_0 :=
      (let _jessie_82 =
      (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 47 13 17#
      "expl:Pointer dereference"
      (acc  intP_a_5_alloc_table intP_intM_a_5 a )) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 47 3 6#
      "expl:Pointer index bounds" true) }); _jessie_82 end));
      try
       begin
       (i_0 :=
        (let _jessie_83 =
        (#"different_array_iterators.jc" 163 25 37# "expl:Integer cast"
        (Safe_int32.of_int (1))) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 55 7 10#
        "expl:Pointer index bounds" true) }); _jessie_83 end));
        'Loop_6:
        loop
        invariant { (#"different_array_iterators.jc" 165 9 1205# true) }
          variant {
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 53 20 28#
            (Int.(-) (Int32.to_int size_2) (Int32.to_int !i_0))) }
         begin
         any unit
         requires { true } reads { a, size_2 }
         ensures {
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 52 22 67#
            (forall k_1 : int.
             ((((<=) (0) k_1) /\ ((<) k_1 (Int32.to_int !i_0))) ->
              (Int32.(<=) (select intP_intM_a_5 (shift a k_1)) !max_0))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 51 22 33#
            (Int32.(=) !max_0
            (select intP_intM_a_5 (shift a (Int32.to_int !j)))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 50 22 32#
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 50 22 32#
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 50 22 28#
             (Int32.(<=) (#"different_array_iterators.jc" 170 41 53#
             "expl:Integer cast" (Int32.of_int (0))) !j))
            /\
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 50 27 32#
            (Int32.(<) !j !i_0)))))
           /\
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 49 22 36#
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 49 22 36#
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 49 22 28#
            (Int32.(<=) (#"different_array_iterators.jc" 167 41 53#
            "expl:Integer cast" (Int32.of_int (1))) !i_0))
           /\
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 49 27 36#
           (Int32.(<=) !i_0 size_2)))))))) } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 55 18 26#
           (Safe_int32.(<)  !i_0 size_2 )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 56 10 20#
            (Safe_int32.(<)  !max_0
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 56 16 20#
             "expl:Pointer dereference"
             (acc_offset_typesafe  intP_a_5_alloc_table intP_intM_a_5 a
              (Safe_int32.to_int  !i_0 ) )) ))
            then
             begin
             (j :=
              (let _jessie_84 = !i_0 in
              begin
              (assert {
              (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 57 9 14#
              "expl:Pointer index bounds" true) }); _jessie_84 end));
              (max_0 :=
               (let _jessie_85 =
               (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 58 15 19#
               "expl:Pointer dereference"
               (acc_offset_typesafe  intP_a_5_alloc_table intP_intM_a_5 a
                (Safe_int32.to_int  !i_0 ) )) in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 58 9 19#
               "expl:Pointer index bounds" true) }); _jessie_85 end)) end
            else ());
            (i_0 :=
             (let _jessie_86 =
             (Safe_int32.(+)  !i_0
              (#"different_array_iterators.jc" 189 57 69# "expl:Integer cast"
              (Safe_int32.of_int (1))) ) in
             begin
             (assert {
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 55 28 31#
             "expl:Pointer index bounds" true) }); _jessie_86 end)) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_6 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end with Goto_while_0_break_exc _jessie_4 ->
       'While_0_break: 'While_0_break: () end;
      begin
      (return :=
       (let _jessie_87 = !j in
       begin
       (assert {
       (#"different_array_iterators.jc" 195 7 15# "expl:Pointer index bounds"
       true) }); _jessie_87 end)); (raise Return) end end end))); absurd  end
    with Return -> !return end)
  
end

module Function_max_in_array_behaviors

  use Unsafe_int32 
  
  use import Struct_intP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  let max_in_array_ensures_default
  #"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 44 4 34#
  "expl:Function max_in_array, default behavior" =
  fun
   (a : (pointer intP)) (size_2 : Int32.t) (intP_a_5_alloc_table :
   (alloc_table intP)) (intP_a_5_tag_table : (tag_table intP)) (intP_intM_a_5
   : (memory intP Int32.t)) 
   requires {
   (((allocated intP_a_5_alloc_table a) ->
     (((=) (typeof intP_a_5_tag_table a) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_5_alloc_table a) i) /\
       ((<) i (offset_max intP_a_5_alloc_table a))) ->
       ((=) (typeof intP_a_5_tag_table (shift a i)) intP_tag)))))
   /\
   (#"different_array_iterators.jc" 134 12 684#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 39 13 21#
    (Int32.(>) size_2 (#"different_array_iterators.jc" 134 31 43#
    "expl:Integer cast" (Int32.of_int (0)))))
   /\
   (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 40 13 38#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
    (((<=) (offset_min intP_a_5_alloc_table a) (0)) /\
    (((>=) (offset_max intP_a_5_alloc_table a)
     (Int.(-) (Int32.to_int size_2) (1)))
    /\
    (forall __framac_tmp4 : int.
     ((((<=) (0) __framac_tmp4) /\
      ((<=) __framac_tmp4 (Int.(-) (Int32.to_int size_2) (1)))) ->
      ((=) true true))))) else ((=) true true)))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 31#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 31#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 24#
      "expl:Ensures clause"
      (Int32.(<=) (#"different_array_iterators.jc" 146 31 43#
      "expl:Integer cast" (Int32.of_int (0))) result))
     /\
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 31#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 17 31#
      "expl:Ensures clause" (Int32.(<) result size_2))
     /\
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 42 12 67#
     "expl:Ensures clause"
     (forall i_3 : int.
      ((((<=) (0) i_3) /\ ((<) i_3 (Int32.to_int size_2))) ->
       (Int32.(<=) (select intP_intM_a_5 (shift a i_3))
       (select intP_intM_a_5 (shift a (Int32.to_int result))))))))))))) }
   diverges  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (let j = ref (Unsafe_int32.any_  () ) in
    (let max_0 = ref (Unsafe_int32.any_  () ) in
    (let i_0 = ref (Unsafe_int32.any_  () ) in
    begin
    (j :=
     (#"different_array_iterators.jc" 160 20 32# "expl:Integer cast"
     (Unsafe_int32.of_int (0))));
     begin
     (max_0 :=
      (acc  intP_intM_a_5
       (shift_  a
        (Unsafe_int32.to_int 
         (#"different_array_iterators.jc" 161 47 59# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) ));
      try
       begin
       (i_0 :=
        (#"different_array_iterators.jc" 163 25 37# "expl:Integer cast"
        (Unsafe_int32.of_int (1))));
        'Loop_5:
        loop
        invariant
          { ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 49 22 36#
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 49 22 36#
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 49 22 28#
              (Int32.(<=) (#"different_array_iterators.jc" 167 41 53#
              "expl:Integer cast" (Int32.of_int (1))) !i_0))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 49 27 36#
             (Int32.(<=) !i_0 size_2)))))
            &&
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 50 22 32#
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 50 22 32#
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 50 22 28#
              (Int32.(<=) (#"different_array_iterators.jc" 170 41 53#
              "expl:Integer cast" (Int32.of_int (0))) !j))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 50 27 32#
             (Int32.(<) !j !i_0)))))
            &&
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 51 22 33#
             (Int32.(=) !max_0
             (select intP_intM_a_5 (shift a (Int32.to_int !j)))))
            &&
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 52 22 67#
            (forall k_1 : int.
             ((((<=) (0) k_1) /\ ((<) k_1 (Int32.to_int !i_0))) ->
              (Int32.(<=) (select intP_intM_a_5 (shift a k_1)) !max_0))))))) }
          
         begin
         any unit requires { true } ensures { true } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 55 18 26#
           (Unsafe_int32.(<)  !i_0 size_2 )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 56 10 20#
            (Unsafe_int32.(<)  !max_0
             (acc  intP_intM_a_5 (shift_  a (Unsafe_int32.to_int  !i_0 ) ) )
             ))
            then
             begin
             (j := !i_0);
              (max_0 :=
               (acc  intP_intM_a_5 (shift_  a (Unsafe_int32.to_int  !i_0 ) )
                )) end else ());
            (i_0 :=
             (Unsafe_int32.(+)  !i_0
              (#"different_array_iterators.jc" 189 57 69# "expl:Integer cast"
              (Unsafe_int32.of_int (1))) )) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_6 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end with Goto_while_0_break_exc _jessie_4 ->
       'While_0_break: 'While_0_break: () end;
      begin (return := !j); (raise Return) end end end))); absurd  end with
    Return -> !return end)
  
end

module Function_max_in_array_even_safety

  use import Struct_intP 
  
  use Safe_int32 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  let max_in_array_even
  #"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 82 4 39#
  "expl:Function max_in_array_even, safety" =
  fun
   (a_0 : (pointer intP)) (size_3 : Int32.t) (intP_a_0_6_alloc_table :
   (alloc_table intP)) (intP_a_0_6_tag_table : (tag_table intP))
   (intP_intM_a_0_6 : (memory intP Int32.t)) 
   requires {
   (((allocated intP_a_0_6_alloc_table a_0) ->
     (((=) (typeof intP_a_0_6_tag_table a_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_0_6_alloc_table a_0) i) /\
       ((<) i (offset_max intP_a_0_6_alloc_table a_0))) ->
       ((=) (typeof intP_a_0_6_tag_table (shift a_0 i)) intP_tag)))))
   /\
   (#"different_array_iterators.jc" 200 12 790#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 75 13 21#
    (Int32.(>) size_3 (#"different_array_iterators.jc" 200 32 44#
    "expl:Integer cast" (Int32.of_int (0)))))
   /\
   (#"different_array_iterators.jc" 200 12 790#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 76 13 35#
    ((<=) (Int32.to_int size_3) (Int.(-) (2147483647) (1))))
   /\
   (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 77 13 38#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_3) (1))) then
    (((<=) (offset_min intP_a_0_6_alloc_table a_0) (0)) /\
    (((>=) (offset_max intP_a_0_6_alloc_table a_0)
     (Int.(-) (Int32.to_int size_3) (1)))
    /\
    (forall __framac_tmp5 : int.
     ((((<=) (0) __framac_tmp5) /\
      ((<=) __framac_tmp5 (Int.(-) (Int32.to_int size_3) (1)))) ->
      ((=) true true))))) else ((=) true true)))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_int32.any_  () ) in
   try
    begin
    (let j_0_0 = ref (Safe_int32.any_  () ) in
    (let max_1 = ref (Safe_int32.any_  () ) in
    (let i_1_0 = ref (Safe_int32.any_  () ) in
    begin
    (j_0_0 :=
     (let _jessie_95 =
     (#"different_array_iterators.jc" 229 22 34# "expl:Integer cast"
     (Safe_int32.of_int (0))) in
     begin
     (assert {
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 84 3 6#
     "expl:Pointer index bounds" true) }); _jessie_95 end));
     begin
     (max_1 :=
      (let _jessie_96 =
      (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 85 13 17#
      "expl:Pointer dereference"
      (acc  intP_a_0_6_alloc_table intP_intM_a_0_6 a_0 )) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 85 3 6#
      "expl:Pointer index bounds" true) }); _jessie_96 end));
      try
       begin
       (i_1_0 :=
        (let _jessie_97 =
        (#"different_array_iterators.jc" 232 25 37# "expl:Integer cast"
        (Safe_int32.of_int (2))) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 94 7 10#
        "expl:Pointer index bounds" true) }); _jessie_97 end));
        'Loop_8:
        loop
        invariant { (#"different_array_iterators.jc" 234 9 1577# true) }
          variant {
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 92 20 28#
            (Int.(-) (Int32.to_int size_3) (Int32.to_int !i_1_0))) }
         begin
         any unit
         requires { true } reads { a_0, size_3 }
         ensures {
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 91 22 85#
            (forall k_2 : int.
             ((((<=) (0) k_2) /\
              (((<) k_2 (Int32.to_int !i_1_0)) /\
              ((=) (ComputerDivision.mod k_2 (2)) (0)))) ->
              (Int32.(<=) (select intP_intM_a_0_6 (shift a_0 k_2)) !max_1))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 90 22 33#
            (Int32.(=) !max_1
            (select intP_intM_a_0_6 (shift a_0 (Int32.to_int !j_0_0)))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 89 22 46#
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 89 22 46#
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 89 22 32#
             ((=) (ComputerDivision.mod (Int32.to_int !i_1_0) (2)) (0)))
            /\
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 89 36 46#
            ((=) (ComputerDivision.mod (Int32.to_int !j_0_0) (2)) (0))))))
           /\
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 88 22 32#
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 88 22 32#
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 88 22 28#
             (Int32.(<=) (#"different_array_iterators.jc" 240 41 53#
             "expl:Integer cast" (Int32.of_int (0))) !j_0_0))
            /\
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 88 27 32#
            (Int32.(<) !j_0_0 !i_1_0)))))
           /\
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 87 22 40#
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 87 22 40#
           ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 87 22 28#
            (Int32.(<=) (#"different_array_iterators.jc" 236 42 54#
            "expl:Integer cast" (Int32.of_int (2))) !i_1_0))
           /\
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 87 27 40#
           ((<=) (Int32.to_int !i_1_0) (Int.(+) (Int32.to_int size_3) (1)))))))))))
           } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 94 18 26#
           (Safe_int32.(<)  !i_1_0 size_3 )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 95 10 20#
            (Safe_int32.(<)  !max_1
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 95 16 20#
             "expl:Pointer dereference"
             (acc_offset_typesafe  intP_a_0_6_alloc_table intP_intM_a_0_6 a_0
              (Safe_int32.to_int  !i_1_0 ) )) ))
            then
             begin
             (j_0_0 :=
              (let _jessie_98 = !i_1_0 in
              begin
              (assert {
              (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 96 9 14#
              "expl:Pointer index bounds" true) }); _jessie_98 end));
              (max_1 :=
               (let _jessie_99 =
               (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 97 15 19#
               "expl:Pointer dereference"
               (acc_offset_typesafe  intP_a_0_6_alloc_table intP_intM_a_0_6
                a_0 (Safe_int32.to_int  !i_1_0 ) )) in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 97 9 19#
               "expl:Pointer index bounds" true) }); _jessie_99 end)) end
            else ());
            (i_1_0 :=
             (let _jessie_100 =
             (Safe_int32.(+)  !i_1_0
              (#"different_array_iterators.jc" 264 60 72# "expl:Integer cast"
              (Safe_int32.of_int (2))) ) in
             begin
             (assert {
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 94 28 34#
             "expl:Pointer index bounds" true) }); _jessie_100 end)) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_9 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end with Goto_while_0_break_exc _jessie_7 ->
       'While_0_break: 'While_0_break: () end;
      begin
      (return :=
       (let _jessie_101 = !j_0_0 in
       begin
       (assert {
       (#"different_array_iterators.jc" 270 7 17# "expl:Pointer index bounds"
       true) }); _jessie_101 end)); (raise Return) end end end))); absurd 
    end with Return -> !return end)
  
end

module Function_max_in_array_even_behaviors

  use Unsafe_int32 
  
  use import Struct_intP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  let max_in_array_even_ensures_default
  #"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 82 4 39#
  "expl:Function max_in_array_even, default behavior" =
  fun
   (a_0 : (pointer intP)) (size_3 : Int32.t) (intP_a_0_6_alloc_table :
   (alloc_table intP)) (intP_a_0_6_tag_table : (tag_table intP))
   (intP_intM_a_0_6 : (memory intP Int32.t)) 
   requires {
   (((allocated intP_a_0_6_alloc_table a_0) ->
     (((=) (typeof intP_a_0_6_tag_table a_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_0_6_alloc_table a_0) i) /\
       ((<) i (offset_max intP_a_0_6_alloc_table a_0))) ->
       ((=) (typeof intP_a_0_6_tag_table (shift a_0 i)) intP_tag)))))
   /\
   (#"different_array_iterators.jc" 200 12 790#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 75 13 21#
    (Int32.(>) size_3 (#"different_array_iterators.jc" 200 32 44#
    "expl:Integer cast" (Int32.of_int (0)))))
   /\
   (#"different_array_iterators.jc" 200 12 790#
   ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 76 13 35#
    ((<=) (Int32.to_int size_3) (Int.(-) (2147483647) (1))))
   /\
   (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 77 13 38#
   (if ((<=) (0) (Int.(-) (Int32.to_int size_3) (1))) then
    (((<=) (offset_min intP_a_0_6_alloc_table a_0) (0)) /\
    (((>=) (offset_max intP_a_0_6_alloc_table a_0)
     (Int.(-) (Int32.to_int size_3) (1)))
    /\
    (forall __framac_tmp5 : int.
     ((((<=) (0) __framac_tmp5) /\
      ((<=) __framac_tmp5 (Int.(-) (Int32.to_int size_3) (1)))) ->
      ((=) true true))))) else ((=) true true)))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 24#
      "expl:Ensures clause"
      (Int32.(<=) (#"different_array_iterators.jc" 213 33 45#
      "expl:Integer cast" (Int32.of_int (0))) result))
     /\
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 17 31#
      "expl:Ensures clause" (Int32.(<) result size_3))
     /\
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 79 12 28#
      "expl:Ensures clause"
      ((=) (ComputerDivision.mod (Int32.to_int result) (2)) (0)))
     /\
     (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 80 12 85#
     "expl:Ensures clause"
     (forall i_4 : int.
      ((((<=) (0) i_4) /\
       (((<) i_4 (Int32.to_int size_3)) /\
       ((=) (ComputerDivision.mod i_4 (2)) (0)))) ->
       (Int32.(<=) (select intP_intM_a_0_6 (shift a_0 i_4))
       (select intP_intM_a_0_6 (shift a_0 (Int32.to_int result)))))))))))))))
     } diverges  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (let j_0_0 = ref (Unsafe_int32.any_  () ) in
    (let max_1 = ref (Unsafe_int32.any_  () ) in
    (let i_1_0 = ref (Unsafe_int32.any_  () ) in
    begin
    (j_0_0 :=
     (#"different_array_iterators.jc" 229 22 34# "expl:Integer cast"
     (Unsafe_int32.of_int (0))));
     begin
     (max_1 :=
      (acc  intP_intM_a_0_6
       (shift_  a_0
        (Unsafe_int32.to_int 
         (#"different_array_iterators.jc" 230 49 61# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) ));
      try
       begin
       (i_1_0 :=
        (#"different_array_iterators.jc" 232 25 37# "expl:Integer cast"
        (Unsafe_int32.of_int (2))));
        'Loop_7:
        loop
        invariant
          { ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 87 22 40#
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 87 22 40#
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 87 22 28#
              (Int32.(<=) (#"different_array_iterators.jc" 236 42 54#
              "expl:Integer cast" (Int32.of_int (2))) !i_1_0))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 87 27 40#
             ((<=) (Int32.to_int !i_1_0) (Int.(+) (Int32.to_int size_3) (1)))))))
            &&
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 88 22 32#
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 88 22 32#
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 88 22 28#
              (Int32.(<=) (#"different_array_iterators.jc" 240 41 53#
              "expl:Integer cast" (Int32.of_int (0))) !j_0_0))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 88 27 32#
             (Int32.(<) !j_0_0 !i_1_0)))))
            &&
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 89 22 46#
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 89 22 46#
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 89 22 32#
              ((=) (ComputerDivision.mod (Int32.to_int !i_1_0) (2)) (0)))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 89 36 46#
             ((=) (ComputerDivision.mod (Int32.to_int !j_0_0) (2)) (0))))))
            &&
            ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 90 22 33#
             (Int32.(=) !max_1
             (select intP_intM_a_0_6 (shift a_0 (Int32.to_int !j_0_0)))))
            &&
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 91 22 85#
            (forall k_2 : int.
             ((((<=) (0) k_2) /\
              (((<) k_2 (Int32.to_int !i_1_0)) /\
              ((=) (ComputerDivision.mod k_2 (2)) (0)))) ->
              (Int32.(<=) (select intP_intM_a_0_6 (shift a_0 k_2)) !max_1)))))))) }
          
         begin
         any unit requires { true } ensures { true } ;
          try
           begin
           begin
           (if
           (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 94 18 26#
           (Unsafe_int32.(<)  !i_1_0 size_3 )) then ()
           else (raise (Goto_while_0_break_exc ())));
            (if
            (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 95 10 20#
            (Unsafe_int32.(<)  !max_1
             (acc  intP_intM_a_0_6
              (shift_  a_0 (Unsafe_int32.to_int  !i_1_0 ) ) ) ))
            then
             begin
             (j_0_0 := !i_1_0);
              (max_1 :=
               (acc  intP_intM_a_0_6
                (shift_  a_0 (Unsafe_int32.to_int  !i_1_0 ) ) )) end 
            else ());
            (i_1_0 :=
             (Unsafe_int32.(+)  !i_1_0
              (#"different_array_iterators.jc" 264 60 72# "expl:Integer cast"
              (Unsafe_int32.of_int (2))) )) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_9 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end with Goto_while_0_break_exc _jessie_7 ->
       'While_0_break: 'While_0_break: () end;
      begin (return := !j_0_0); (raise Return) end end end))); absurd  end
    with Return -> !return end)
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_voidP

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP)) = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_charP

  use import Struct_voidP 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

module Struct_intP_unsafe

  use import Struct_intP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_intP
  (p : (pointer intP)) 
   (intP_alloc_table : ref (alloc_table intP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !intP_alloc_table p))
      }
    writes { intP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !intP_alloc_table (old !intP_alloc_table))) \/
      ((frame_free_struct_intP p (old !intP_alloc_table) !intP_alloc_table)
      /\ (fresh_alloc_struct_intP p !intP_alloc_table))) }
  
  val allocate_struct_intP_requires
  (n : int) 
   (intP_alloc_table : ref (alloc_table intP)) 
    (intP_tag_table : ref (tag_table intP)) : (pointer intP)
     requires { ((>=) n (0)) } writes { intP_alloc_table, intP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !intP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !intP_alloc_table)
        !intP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (old !intP_alloc_table)) /\
       ((fresh_tag_struct_intP result (old !intP_tag_table)) /\
       ((typeof_struct_intP result (0) n !intP_tag_table) /\
       (container_of_struct_intP result (0) n !intP_tag_table))))))) }
  
end

module Struct_intP_safe

  use import Struct_intP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_intP
  (p : (pointer intP)) 
   (intP_alloc_table : ref (alloc_table intP)) : unit
    requires { true } writes { intP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !intP_alloc_table (old !intP_alloc_table))) \/
      ((frame_free_struct_intP p (old !intP_alloc_table) !intP_alloc_table)
      /\ (fresh_alloc_struct_intP p !intP_alloc_table))) }
  
  val allocate_struct_intP
  (n : int) 
   (intP_alloc_table : ref (alloc_table intP)) 
    (intP_tag_table : ref (tag_table intP)) : (pointer intP)
     requires { true } writes { intP_alloc_table, intP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !intP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !intP_alloc_table)
        !intP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (old !intP_alloc_table)) /\
       ((fresh_tag_struct_intP result (old !intP_tag_table)) /\
       ((typeof_struct_intP result (0) n !intP_tag_table) /\
       (container_of_struct_intP result (0) n !intP_tag_table))))))) }
  
  val allocate_singleton_struct_intP
  (intP_alloc_table : ref (alloc_table intP)) 
   (intP_tag_table : ref (tag_table intP)) : (pointer intP)
    requires { true } writes { intP_alloc_table, intP_tag_table }
    ensures {
      ((strict_valid_struct_intP result (0) (0) !intP_alloc_table) /\
      ((frame_alloc_struct_intP result (1) (old !intP_alloc_table)
       !intP_alloc_table)
      /\
      ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
      /\
      ((fresh_alloc_struct_intP result (old !intP_alloc_table)) /\
      ((fresh_tag_struct_intP result (old !intP_tag_table)) /\
      ((typeof_singleton_struct_intP result !intP_tag_table) /\
      (container_of_singleton_struct_intP result !intP_tag_table))))))) }
  
end

theory Root_unsigned_charP

  use why3.Bool.Bool 
  
  type unsigned_charP 
  
end

theory Struct_unsigned_charP

  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function unsigned_charP_tag  : (tag_id
  unsigned_charP)
  
  axiom Unsigned_charP_parenttag_bottom :
  (parenttag unsigned_charP_tag bottom_tag)
  
  axiom Unsigned_charP_is_final :
  (forall unsigned_charP_tag_table : (tag_table unsigned_charP).
   (forall p : (pointer unsigned_charP).
    ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) ->
     ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag))))
  
  predicate frame_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_tag_table : (tag_table unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((tag_extends old_unsigned_charP_tag_table unsigned_charP_tag_table) /\
     (alloc_tag_block old_unsigned_charP_tag_table unsigned_charP_tag_table
     p))
  
  predicate frame_free_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((free_extends old_unsigned_charP_alloc_table unsigned_charP_alloc_table)
     /\
     (free_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p))
  
  predicate frame_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (n : int) (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((alloc_extends old_unsigned_charP_alloc_table
      unsigned_charP_alloc_table)
     /\
     (alloc_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p
     n))
  
  predicate fresh_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (tag_fresh unsigned_charP_tag_table p)
  
  predicate fresh_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = (alloc_fresh unsigned_charP_alloc_table p)
  
  predicate container_of_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate container_of_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate typeof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag)
  
  predicate typeof_struct_unsigned_charP (p : (pointer unsigned_charP)) (l :
  int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     (((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof unsigned_charP_tag_table (shift p i)) unsigned_charP_tag))))
  
  predicate instanceof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (instanceof unsigned_charP_tag_table p unsigned_charP_tag)
  
  predicate instanceof_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof unsigned_charP_tag_table (shift p i) unsigned_charP_tag))))
  
  predicate right_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((>=) (offset_max unsigned_charP_alloc_table p) b)
  
  predicate left_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((<=) (offset_min unsigned_charP_alloc_table p) a)
  
  predicate valid_struct_unsigned_charP (p : (pointer unsigned_charP)) (a :
  int) (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     (((<=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((>=) (offset_max unsigned_charP_alloc_table p) b))
  
  predicate strict_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (b : int) (unsigned_charP_alloc_table : (alloc_table
  unsigned_charP))
  =
     (((=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((=) (offset_max unsigned_charP_alloc_table p) b))
  
  axiom Unsigned_charP_int : ((=) (int_of_tag unsigned_charP_tag) (5))
  
end

module Struct_unsigned_charP_unsafe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !unsigned_charP_alloc_table p)) }
    writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP_requires
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { ((>=) n (0)) } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
end

module Struct_unsigned_charP_safe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires { true } writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { true } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
  val allocate_singleton_struct_unsigned_charP
  (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
   (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
    unsigned_charP)
    requires { true } writes { unsigned_charP_alloc_table,
    unsigned_charP_tag_table }
    ensures {
      ((strict_valid_struct_unsigned_charP result (0) (0)
       !unsigned_charP_alloc_table)
      /\
      ((frame_alloc_struct_unsigned_charP result (1) (old
       !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
      /\
      ((frame_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table) !unsigned_charP_tag_table)
      /\
      ((fresh_alloc_struct_unsigned_charP result (old
       !unsigned_charP_alloc_table))
      /\
      ((fresh_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table))
      /\
      ((typeof_singleton_struct_unsigned_charP result
       !unsigned_charP_tag_table)
      /\
      (container_of_singleton_struct_unsigned_charP result
      !unsigned_charP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Function_max_min_in_array

  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_union 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  val max_min_in_array
  (a_1 : (pointer intP)) 
   (size_4 : Int32.t) 
    (max : (pointer intP)) 
     (min : (pointer intP)) 
      (intP_intM_max_3 : ref (memory intP Int32.t)) 
       (intP_max_3_alloc_table : (alloc_table intP)) 
        (intP_a_1_2_alloc_table : (alloc_table intP)) 
         (intP_a_1_2_tag_table : (tag_table intP)) 
          (intP_intM_a_1_2 : (memory intP Int32.t)) : unit
           requires { true } reads { intP_intM_max_3 } writes {
           intP_intM_max_3 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 13 15 85#
              "expl:Ensures clause"
              (forall i_1 : int.
               ((((<=) (0) i_1) /\
                (((<) i_1 (Int32.to_int size_4)) /\
                ((=) (ComputerDivision.mod i_1 (2)) (1)))) ->
                (Int32.(<=)
                (select intP_intM_a_1_2
                (shift a_1 (Int32.to_int (select !intP_intM_max_3 min))))
                (select intP_intM_a_1_2 (shift a_1 i_1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 11 15 85#
              "expl:Ensures clause"
              (forall i_2 : int.
               ((((<=) (0) i_2) /\
                (((<) i_2 (Int32.to_int size_4)) /\
                ((=) (ComputerDivision.mod i_2 (2)) (0)))) ->
                (Int32.(<=) (select intP_intM_a_1_2 (shift a_1 i_2))
                (select intP_intM_a_1_2
                (shift a_1 (Int32.to_int (select !intP_intM_max_3 max))))))))
             /\
             ((#"different_array_iterators.jc" 49 10 30#
              "expl:Assigns clause"
              (not_assigns intP_max_3_alloc_table intP_max_3_alloc_table (old
              !intP_intM_max_3) !intP_intM_max_3
              (pset_union (pset_singleton max) (pset_singleton min))))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
             "expl:Ensures clause"
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
             "expl:Ensures clause"
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 21#
              "expl:Ensures clause"
              (Int32.(<=) (#"different_array_iterators.jc" 51 31 43#
              "expl:Integer cast" (Int32.of_int (0)))
              (select !intP_intM_max_3 max)))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
             "expl:Ensures clause"
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 17 28#
              "expl:Ensures clause"
              (Int32.(<) (select !intP_intM_max_3 max) size_4))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
             "expl:Ensures clause"
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 9 12 21#
              "expl:Ensures clause"
              (Int32.(<=) (#"different_array_iterators.jc" 53 32 44#
              "expl:Integer cast" (Int32.of_int (0)))
              (select !intP_intM_max_3 min)))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 9 17 28#
             "expl:Ensures clause"
             (Int32.(<) (select !intP_intM_max_3 min) size_4)))))))))))) }
  
end

module Function_max_min_in_array_safe

  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset_union 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  val max_min_in_array
  (a_1 : (pointer intP)) 
   (size_4 : Int32.t) 
    (max : (pointer intP)) 
     (min : (pointer intP)) 
      (intP_intM_max_3 : ref (memory intP Int32.t)) 
       (intP_max_3_alloc_table : (alloc_table intP)) 
        (intP_a_1_2_alloc_table : (alloc_table intP)) 
         (intP_a_1_2_tag_table : (tag_table intP)) 
          (intP_intM_a_1_2 : (memory intP Int32.t)) : unit
           requires {
             ("expl:Internal"
             (#"different_array_iterators.jc" 30 12 1163#
             "expl:Requires clause"
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 2 13 22#
              "expl:Requires clause"
              (Int32.(>=) size_4 (#"different_array_iterators.jc" 30 32 44#
              "expl:Integer cast" (Int32.of_int (2)))))
             /\
             (#"different_array_iterators.jc" 30 12 1163#
             "expl:Requires clause"
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 3 13 36#
              "expl:Requires clause"
              (if ((<=) (0) (Int.(-) (Int32.to_int size_4) (1))) then
               (((<=) (offset_min intP_a_1_2_alloc_table a_1) (0)) /\
               (((>=) (offset_max intP_a_1_2_alloc_table a_1)
                (Int.(-) (Int32.to_int size_4) (1)))
               /\
               (forall __framac_tmp1 : int.
                ((((<=) (0) __framac_tmp1) /\
                 ((<=) __framac_tmp1 (Int.(-) (Int32.to_int size_4) (1)))) ->
                 ((=) true true))))) else ((=) true true)))
             /\
             (#"different_array_iterators.jc" 30 12 1163#
             "expl:Requires clause"
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 4 13 24#
              "expl:Requires clause"
              (#"different_array_iterators.jc" 30 12 1163#
              "expl:Requires clause"
              ((#"different_array_iterators.jc" 30 12 1163#
               "expl:Requires clause"
               ((<=) (offset_min intP_max_3_alloc_table max) (0)))
              /\
              (#"different_array_iterators.jc" 30 12 1163#
              "expl:Requires clause"
              ((#"different_array_iterators.jc" 30 12 1163#
               "expl:Requires clause"
               ((>=) (offset_max intP_max_3_alloc_table max) (0)))
              /\
              (#"different_array_iterators.jc" 30 12 1163#
              "expl:Requires clause" ((=) true true)))))))
             /\
             (#"different_array_iterators.jc" 30 12 1163#
             "expl:Requires clause"
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 5 13 24#
              "expl:Requires clause"
              (#"different_array_iterators.jc" 30 12 1163#
              "expl:Requires clause"
              ((#"different_array_iterators.jc" 30 12 1163#
               "expl:Requires clause"
               ((<=) (offset_min intP_max_3_alloc_table min) (0)))
              /\
              (#"different_array_iterators.jc" 30 12 1163#
              "expl:Requires clause"
              ((#"different_array_iterators.jc" 30 12 1163#
               "expl:Requires clause"
               ((>=) (offset_max intP_max_3_alloc_table min) (0)))
              /\
              (#"different_array_iterators.jc" 30 12 1163#
              "expl:Requires clause" ((=) true true)))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 6 13 23#
             "expl:Requires clause" ((<>) max min))))))))))) }
           reads { intP_intM_max_3 } writes { intP_intM_max_3 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 13 15 85#
              "expl:Ensures clause"
              (forall i_1 : int.
               ((((<=) (0) i_1) /\
                (((<) i_1 (Int32.to_int size_4)) /\
                ((=) (ComputerDivision.mod i_1 (2)) (1)))) ->
                (Int32.(<=)
                (select intP_intM_a_1_2
                (shift a_1 (Int32.to_int (select !intP_intM_max_3 min))))
                (select intP_intM_a_1_2 (shift a_1 i_1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 11 15 85#
              "expl:Ensures clause"
              (forall i_2 : int.
               ((((<=) (0) i_2) /\
                (((<) i_2 (Int32.to_int size_4)) /\
                ((=) (ComputerDivision.mod i_2 (2)) (0)))) ->
                (Int32.(<=) (select intP_intM_a_1_2 (shift a_1 i_2))
                (select intP_intM_a_1_2
                (shift a_1 (Int32.to_int (select !intP_intM_max_3 max))))))))
             /\
             ((#"different_array_iterators.jc" 49 10 30#
              "expl:Assigns clause"
              (not_assigns intP_max_3_alloc_table intP_max_3_alloc_table (old
              !intP_intM_max_3) !intP_intM_max_3
              (pset_union (pset_singleton max) (pset_singleton min))))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
             "expl:Ensures clause"
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
             "expl:Ensures clause"
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 21#
              "expl:Ensures clause"
              (Int32.(<=) (#"different_array_iterators.jc" 51 31 43#
              "expl:Integer cast" (Int32.of_int (0)))
              (select !intP_intM_max_3 max)))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
             "expl:Ensures clause"
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 17 28#
              "expl:Ensures clause"
              (Int32.(<) (select !intP_intM_max_3 max) size_4))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 8 12 28#
             "expl:Ensures clause"
             ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 9 12 21#
              "expl:Ensures clause"
              (Int32.(<=) (#"different_array_iterators.jc" 53 32 44#
              "expl:Integer cast" (Int32.of_int (0)))
              (select !intP_intM_max_3 min)))
             /\
             (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 9 17 28#
             "expl:Ensures clause"
             (Int32.(<) (select !intP_intM_max_3 min) size_4)))))))))))) }
  
end

module Function_max_in_array

  use import Root_intP 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val max_in_array
  (a : (pointer intP)) 
   (size_2 : Int32.t) 
    (intP_a_5_alloc_table : (alloc_table intP)) 
     (intP_a_5_tag_table : (tag_table intP)) 
      (intP_intM_a_5 : (memory intP Int32.t)) : Int32.t
       requires { true }
       ensures {
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 31#
         "expl:Ensures clause"
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 31#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 24#
          "expl:Ensures clause"
          (Int32.(<=) (#"different_array_iterators.jc" 146 31 43#
          "expl:Integer cast" (Int32.of_int (0))) result))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 31#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 17 31#
          "expl:Ensures clause" (Int32.(<) result size_2))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 42 12 67#
         "expl:Ensures clause"
         (forall i_3 : int.
          ((((<=) (0) i_3) /\ ((<) i_3 (Int32.to_int size_2))) ->
           (Int32.(<=) (select intP_intM_a_5 (shift a i_3))
           (select intP_intM_a_5 (shift a (Int32.to_int result)))))))))))) }
  
end

module Function_max_in_array_safe

  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val max_in_array
  (a : (pointer intP)) 
   (size_2 : Int32.t) 
    (intP_a_5_alloc_table : (alloc_table intP)) 
     (intP_a_5_tag_table : (tag_table intP)) 
      (intP_intM_a_5 : (memory intP Int32.t)) : Int32.t
       requires {
         ("expl:Internal"
         (#"different_array_iterators.jc" 134 12 684# "expl:Requires clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 39 13 21#
          "expl:Requires clause"
          (Int32.(>) size_2 (#"different_array_iterators.jc" 134 31 43#
          "expl:Integer cast" (Int32.of_int (0)))))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 40 13 38#
         "expl:Requires clause"
         (if ((<=) (0) (Int.(-) (Int32.to_int size_2) (1))) then
          (((<=) (offset_min intP_a_5_alloc_table a) (0)) /\
          (((>=) (offset_max intP_a_5_alloc_table a)
           (Int.(-) (Int32.to_int size_2) (1)))
          /\
          (forall __framac_tmp4 : int.
           ((((<=) (0) __framac_tmp4) /\
            ((<=) __framac_tmp4 (Int.(-) (Int32.to_int size_2) (1)))) ->
            ((=) true true))))) else ((=) true true)))))) }
       ensures {
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 31#
         "expl:Ensures clause"
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 31#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 24#
          "expl:Ensures clause"
          (Int32.(<=) (#"different_array_iterators.jc" 146 31 43#
          "expl:Integer cast" (Int32.of_int (0))) result))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 12 31#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 41 17 31#
          "expl:Ensures clause" (Int32.(<) result size_2))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 42 12 67#
         "expl:Ensures clause"
         (forall i_3 : int.
          ((((<=) (0) i_3) /\ ((<) i_3 (Int32.to_int size_2))) ->
           (Int32.(<=) (select intP_intM_a_5 (shift a i_3))
           (select intP_intM_a_5 (shift a (Int32.to_int result)))))))))))) }
  
end

module Function_max_in_array_even

  use import Root_intP 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  val max_in_array_even
  (a_0 : (pointer intP)) 
   (size_3 : Int32.t) 
    (intP_a_0_6_alloc_table : (alloc_table intP)) 
     (intP_a_0_6_tag_table : (tag_table intP)) 
      (intP_intM_a_0_6 : (memory intP Int32.t)) : Int32.t
       requires { true }
       ensures {
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
         "expl:Ensures clause"
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 24#
          "expl:Ensures clause"
          (Int32.(<=) (#"different_array_iterators.jc" 213 33 45#
          "expl:Integer cast" (Int32.of_int (0))) result))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 17 31#
          "expl:Ensures clause" (Int32.(<) result size_3))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 79 12 28#
          "expl:Ensures clause"
          ((=) (ComputerDivision.mod (Int32.to_int result) (2)) (0)))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 80 12 85#
         "expl:Ensures clause"
         (forall i_4 : int.
          ((((<=) (0) i_4) /\
           (((<) i_4 (Int32.to_int size_3)) /\
           ((=) (ComputerDivision.mod i_4 (2)) (0)))) ->
           (Int32.(<=) (select intP_intM_a_0_6 (shift a_0 i_4))
           (select intP_intM_a_0_6 (shift a_0 (Int32.to_int result))))))))))))))
         }
  
end

module Function_max_in_array_even_safe

  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  val max_in_array_even
  (a_0 : (pointer intP)) 
   (size_3 : Int32.t) 
    (intP_a_0_6_alloc_table : (alloc_table intP)) 
     (intP_a_0_6_tag_table : (tag_table intP)) 
      (intP_intM_a_0_6 : (memory intP Int32.t)) : Int32.t
       requires {
         ("expl:Internal"
         (#"different_array_iterators.jc" 200 12 790# "expl:Requires clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 75 13 21#
          "expl:Requires clause"
          (Int32.(>) size_3 (#"different_array_iterators.jc" 200 32 44#
          "expl:Integer cast" (Int32.of_int (0)))))
         /\
         (#"different_array_iterators.jc" 200 12 790# "expl:Requires clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 76 13 35#
          "expl:Requires clause"
          ((<=) (Int32.to_int size_3) (Int.(-) (2147483647) (1))))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 77 13 38#
         "expl:Requires clause"
         (if ((<=) (0) (Int.(-) (Int32.to_int size_3) (1))) then
          (((<=) (offset_min intP_a_0_6_alloc_table a_0) (0)) /\
          (((>=) (offset_max intP_a_0_6_alloc_table a_0)
           (Int.(-) (Int32.to_int size_3) (1)))
          /\
          (forall __framac_tmp5 : int.
           ((((<=) (0) __framac_tmp5) /\
            ((<=) __framac_tmp5 (Int.(-) (Int32.to_int size_3) (1)))) ->
            ((=) true true))))) else ((=) true true)))))))) }
       ensures {
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
         "expl:Ensures clause"
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 24#
          "expl:Ensures clause"
          (Int32.(<=) (#"different_array_iterators.jc" 213 33 45#
          "expl:Integer cast" (Int32.of_int (0))) result))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 17 31#
          "expl:Ensures clause" (Int32.(<) result size_3))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 78 12 31#
         "expl:Ensures clause"
         ((#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 79 12 28#
          "expl:Ensures clause"
          ((=) (ComputerDivision.mod (Int32.to_int result) (2)) (0)))
         /\
         (#"/home/work/workspace/education/acsl-exam/different_array_iterators.c" 80 12 85#
         "expl:Ensures clause"
         (forall i_4 : int.
          ((((<=) (0) i_4) /\
           (((<) i_4 (Int32.to_int size_3)) /\
           ((=) (ComputerDivision.mod i_4 (2)) (0)))) ->
           (Int32.(<=) (select intP_intM_a_0_6 (shift a_0 i_4))
           (select intP_intM_a_0_6 (shift a_0 (Int32.to_int result))))))))))))))
         }
  
end
