
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Jessie_voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_safe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_unsafe

  use why3.Bool.Bool 
  
end

module Root_int_xP_safe

  use why3.Bool.Bool 
  
end

module Root_int_xP_unsafe

  use why3.Bool.Bool 
  
end

module Root_intP_safe

  use why3.Bool.Bool 
  
end

module Root_intP_unsafe

  use why3.Bool.Bool 
  
end

theory Root_intP

  use why3.Bool.Bool 
  
  type intP 
  
end

theory Root_int_xP

  use why3.Bool.Bool 
  
  type int_xP 
  
end

theory Struct_intP

  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function intP_tag  : (tag_id intP)
  
  axiom IntP_parenttag_bottom :
  (parenttag intP_tag bottom_tag)
  
  axiom IntP_is_final :
  (forall intP_tag_table : (tag_table intP).
   (forall p : (pointer intP).
    ((instanceof intP_tag_table p intP_tag) ->
     ((=) (typeof intP_tag_table p) intP_tag))))
  
  predicate frame_tag_struct_intP (p : (pointer intP)) (old_intP_tag_table :
  (tag_table intP)) (intP_tag_table : (tag_table intP))
  =
     ((tag_extends old_intP_tag_table intP_tag_table) /\
     (alloc_tag_block old_intP_tag_table intP_tag_table p))
  
  predicate frame_free_struct_intP (p : (pointer intP)) (old_intP_alloc_table
  : (alloc_table intP)) (intP_alloc_table : (alloc_table intP))
  =
     ((free_extends old_intP_alloc_table intP_alloc_table) /\
     (free_block old_intP_alloc_table intP_alloc_table p))
  
  predicate frame_alloc_struct_intP (p : (pointer intP)) (n : int)
  (old_intP_alloc_table : (alloc_table intP)) (intP_alloc_table :
  (alloc_table intP))
  =
     ((alloc_extends old_intP_alloc_table intP_alloc_table) /\
     (alloc_block old_intP_alloc_table intP_alloc_table p n))
  
  predicate fresh_tag_struct_intP (p : (pointer intP)) (intP_tag_table :
  (tag_table intP)) = (tag_fresh intP_tag_table p)
  
  predicate fresh_alloc_struct_intP (p : (pointer intP)) (intP_alloc_table :
  (alloc_table intP)) = (alloc_fresh intP_alloc_table p)
  
  predicate container_of_singleton_struct_intP (p : (pointer intP))
  (intP_tag_table : (tag_table intP)) = true
  
  predicate container_of_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP)) = true
  
  predicate typeof_singleton_struct_intP (p : (pointer intP)) (intP_tag_table
  : (tag_table intP)) = ((=) (typeof intP_tag_table p) intP_tag)
  
  predicate typeof_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP))
  =
     (((=) (typeof intP_tag_table p) intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof intP_tag_table (shift p i)) intP_tag))))
  
  predicate instanceof_singleton_struct_intP (p : (pointer intP))
  (intP_tag_table : (tag_table intP))
  = (instanceof intP_tag_table p intP_tag)
  
  predicate instanceof_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP))
  =
     ((instanceof intP_tag_table p intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof intP_tag_table (shift p i) intP_tag))))
  
  predicate right_valid_struct_intP (p : (pointer intP)) (b : int)
  (intP_alloc_table : (alloc_table intP))
  = ((>=) (offset_max intP_alloc_table p) b)
  
  predicate left_valid_struct_intP (p : (pointer intP)) (a : int)
  (intP_alloc_table : (alloc_table intP))
  = ((<=) (offset_min intP_alloc_table p) a)
  
  predicate valid_struct_intP (p : (pointer intP)) (a : int) (b : int)
  (intP_alloc_table : (alloc_table intP))
  =
     (((<=) (offset_min intP_alloc_table p) a) /\
     ((>=) (offset_max intP_alloc_table p) b))
  
  predicate strict_valid_struct_intP (p : (pointer intP)) (a : int) (b : int)
  (intP_alloc_table : (alloc_table intP))
  =
     (((=) (offset_min intP_alloc_table p) a) /\
     ((=) (offset_max intP_alloc_table p) b))
  
  axiom IntP_int : ((=) (int_of_tag intP_tag) (4))
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Goto_while_0_break_exc unit
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Function_max_max_safety

  use enum.Uint32 
  
  use import Struct_intP 
  
  use Safe_uint32 
  
  use Safe_int32 
  
  use import Root_int_xP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_upd_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  let max_max
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 22 5 59#
  "expl:Function max_max, safety" =
  fun
   (a : (pointer intP)) (size_2 : Uint32.t) (max1 : (pointer int_xP)) (max2 :
   (pointer int_xP)) (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer
   intP))) (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP)))
   (intP_a_2_alloc_table : (alloc_table intP)) (int_xP_max1_3_alloc_table :
   (alloc_table int_xP)) (int_xP_max2_4_alloc_table : (alloc_table int_xP))
   (intP_a_2_tag_table : (tag_table intP)) (intP_intM_a_2 : (memory intP
   Int32.t)) 
   requires {
   (((allocated intP_a_2_alloc_table a) ->
     (((=) (typeof intP_a_2_tag_table a) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_2_alloc_table a) i) /\
       ((<) i (offset_max intP_a_2_alloc_table a))) ->
       ((=) (typeof intP_a_2_tag_table (shift a i)) intP_tag)))))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_2) (1))) then
     (((<=) (offset_min intP_a_2_alloc_table a) (0)) /\
     (((>=) (offset_max intP_a_2_alloc_table a)
      (Int.(-) (Uint32.to_int size_2) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Uint32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 13 25#
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
    /\
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
    /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 29 41#
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
   /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (); ();
     (let i = ref (Safe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 25 7 15#
     (Safe_uint32.(>)  size_2
      (#"max_max.jc" 127 29 42# "expl:Integer cast" (Safe_uint32.of_int (0)))
      ))
     then
      try
       begin
       (let _jessie_108 =
       (let _jessie_107 =
       (shift_typesafe  a
        (Safe_int32.to_int 
         (#"max_max.jc" 128 54 66# "expl:Integer cast"
         (Safe_int32.of_int (0))) ) ) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./max_max.c" 28 6 19#
       "expl:Pointer index bounds" true) }); _jessie_107 end) in
       (let _jessie_109 = max1 in
       (let _jessie_110 = (0) in
       (let _jessie_111 = _jessie_109 in
       (#"/home/work/workspace/education/acsl-exam/./max_max.c" 28 6 19#
       "expl:Pointer dereference"
       (upd  int_xP_max1_3_alloc_table int_xP_int_xM_max1_3 _jessie_109
        _jessie_108 ))))));
        begin
        (let _jessie_103 =
        (let _jessie_102 =
        (#"/home/work/workspace/education/acsl-exam/./max_max.c" 29 14 19#
        "expl:Pointer dereference"
        (acc  int_xP_max1_3_alloc_table !int_xP_int_xM_max1_3 max1 )) in
        begin
        (assert {
        (#"/home/work/workspace/education/acsl-exam/./max_max.c" 29 6 19#
        "expl:Pointer index bounds" true) }); _jessie_102 end) in
        (let _jessie_104 = max2 in
        (let _jessie_105 = (0) in
        (let _jessie_106 = _jessie_104 in
        (#"/home/work/workspace/education/acsl-exam/./max_max.c" 29 6 19#
        "expl:Pointer dereference"
        (upd  int_xP_max2_4_alloc_table int_xP_int_xM_max2_4 _jessie_104
         _jessie_103 ))))));
         begin
         (i :=
          (let _jessie_85 =
          (#"max_max.jc" 130 22 35# "expl:Integer cast"
          (Safe_uint32.of_int (1))) in
          begin
          (assert {
          (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 10 15#
          "expl:Pointer index bounds" true) }); _jessie_85 end));
          'Loop_4:
          loop
          invariant { (#"max_max.jc" 132 9 2904# true) }
            variant {
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 23 31#
              (Int.(-) (Uint32.to_int size_2) (Uint32.to_int !i))) }
           begin
           any unit
           requires { true } reads { a, int_xP_int_xM_max1_3,
           int_xP_int_xM_max2_4, max1, max2, size_2 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 37 25 135#
              (not
              (exists j_4 : int.
               (exists k_1 : int.
                (((<=) (0) j_4) /\
                (((<) j_4 (Uint32.to_int !i)) /\
                (((<=) (0) k_1) /\
                (((<) k_1 (Uint32.to_int !i)) /\
                (((<>) j_4 k_1) /\
                ((Int32.(>) (select intP_intM_a_2 (shift a j_4))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                ((Int32.(>) (select intP_intM_a_2 (shift a k_1))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                (Int32.(>) (select intP_intM_a_2 (shift a k_1))
                (select intP_intM_a_2 (shift a j_4))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 36 25 90#
              (exists j_3 : int.
               (((<=) (0) j_3) /\
               (((<) j_3 (Uint32.to_int !i)) /\
               ((Int32.(>=) (select intP_intM_a_2 (shift a j_3))
                (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
               /\
               (Int32.(=) (select intP_intM_a_2 (shift a j_3))
               (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 35 25 73#
              (forall j_2 : int.
               ((((<=) (0) j_2) /\ ((<) j_2 (Uint32.to_int !i))) ->
                (Int32.(<=) (select intP_intM_a_2 (shift a j_2))
                (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 25 41#
              (Int32.(>=)
              (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
              (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 33 25 74#
              (exists j_1 : int.
               (((<=) (0) j_1) /\
               (((<) j_1 (Uint32.to_int !i)) /\
               ((=) (shift a j_1) (select !int_xP_int_xM_max2_4 max2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 32 25 74#
              (exists j_0 : int.
               (((<=) (0) j_0) /\
               (((<) j_0 (Uint32.to_int !i)) /\
               ((=) (shift a j_0) (select !int_xP_int_xM_max1_3 max1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 30#
              ((<) (0) (Uint32.to_int !i)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 29 38#
             (Uint32.(<=) !i size_2))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 17 25#
             (Safe_uint32.(<)  !i size_2 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 13 26#
              (Safe_int32.(>) 
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 13 17#
               "expl:Pointer dereference"
               (acc_offset_typesafe  intP_a_2_alloc_table intP_intM_a_2 a
                (Safe_uint32.to_int  !i ) ))
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 20 26#
               "expl:Pointer dereference"
               (acc  intP_a_2_alloc_table intP_intM_a_2
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 21 26#
                "expl:Pointer dereference"
                (acc  int_xP_max1_3_alloc_table !int_xP_int_xM_max1_3 max1 ))
                )) ))
              then
               begin
               (let _jessie_92 =
               (let _jessie_91 =
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 43 20 25#
               "expl:Pointer dereference"
               (acc  int_xP_max1_3_alloc_table !int_xP_int_xM_max1_3 max1 ))
               in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 43 12 25#
               "expl:Pointer index bounds" true) }); _jessie_91 end) in
               (let _jessie_93 = max2 in
               (let _jessie_94 = (0) in
               (let _jessie_95 = _jessie_93 in
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 43 12 25#
               "expl:Pointer dereference"
               (upd  int_xP_max2_4_alloc_table int_xP_int_xM_max2_4
                _jessie_93 _jessie_92 ))))));
                (let _jessie_97 =
                (let _jessie_96 =
                (shift_typesafe  a (Safe_uint32.to_int  !i ) ) in
                begin
                (assert {
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 44 12 25#
                "expl:Pointer index bounds" true) }); _jessie_96 end) in
                (let _jessie_98 = max1 in
                (let _jessie_99 = (0) in
                (let _jessie_100 = _jessie_98 in
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 44 12 25#
                "expl:Pointer dereference"
                (upd  int_xP_max1_3_alloc_table int_xP_int_xM_max1_3
                 _jessie_98 _jessie_97 )))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 20 33#
               (Safe_int32.(>) 
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 20 24#
                "expl:Pointer dereference"
                (acc_offset_typesafe  intP_a_2_alloc_table intP_intM_a_2 a
                 (Safe_uint32.to_int  !i ) ))
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 27 33#
                "expl:Pointer dereference"
                (acc  intP_a_2_alloc_table intP_intM_a_2
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 28 33#
                 "expl:Pointer dereference"
                 (acc  int_xP_max2_4_alloc_table !int_xP_int_xM_max2_4 max2 ))
                 )) ))
               then
                (let _jessie_87 =
                (let _jessie_86 =
                (shift_typesafe  a (Safe_uint32.to_int  !i ) ) in
                begin
                (assert {
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 12 25#
                "expl:Pointer index bounds" true) }); _jessie_86 end) in
                (let _jessie_88 = max2 in
                (let _jessie_89 = (0) in
                (let _jessie_90 = _jessie_88 in
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 12 25#
                "expl:Pointer dereference"
                (upd  int_xP_max2_4_alloc_table int_xP_int_xM_max2_4
                 _jessie_88 _jessie_87 )))))) else ()));
              (i :=
               (let _jessie_101 =
               (Safe_uint32.(+)  !i
                (#"max_max.jc" 184 53 66# "expl:Integer cast"
                (Safe_uint32.of_int (1))) ) in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 27 30#
               "expl:Pointer index bounds" true) }); _jessie_101 end)) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
         end end end with Goto_while_0_break_exc _jessie_1 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
end

module Function_max_max_behaviors

  use Unsafe_uint32 
  
  use Unsafe_int32 
  
  use enum.Uint32 
  
  use import Struct_intP 
  
  use import Root_int_xP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  let max_max_ensures_default
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 22 5 59#
  "expl:Function max_max, default behavior" =
  fun
   (a : (pointer intP)) (size_2 : Uint32.t) (max1 : (pointer int_xP)) (max2 :
   (pointer int_xP)) (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer
   intP))) (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP)))
   (intP_a_2_alloc_table : (alloc_table intP)) (int_xP_max1_3_alloc_table :
   (alloc_table int_xP)) (int_xP_max2_4_alloc_table : (alloc_table int_xP))
   (intP_a_2_tag_table : (tag_table intP)) (intP_intM_a_2 : (memory intP
   Int32.t)) 
   requires {
   (((allocated intP_a_2_alloc_table a) ->
     (((=) (typeof intP_a_2_tag_table a) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_2_alloc_table a) i) /\
       ((<) i (offset_max intP_a_2_alloc_table a))) ->
       ((=) (typeof intP_a_2_tag_table (shift a i)) intP_tag)))))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_2) (1))) then
     (((<=) (offset_min intP_a_2_alloc_table a) (0)) /\
     (((>=) (offset_max intP_a_2_alloc_table a)
      (Int.(-) (Uint32.to_int size_2) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Uint32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 13 25#
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
    /\
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
    /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 29 41#
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
   /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))))))) }
   ensures { ("expl:Postcondition" ("expl:Ensures clause" true)) } diverges 
   ->
   'Init:
   try
    begin
    (check {
    (#"max_max.jc" 119 10 131# "expl:Behavior disjointness check"
    (not
    (((=) (Uint32.to_int size_2) (0)) /\ ((>) (Uint32.to_int size_2) (0)))))
    });
     (check {
     (#"max_max.jc" 122 10 124# "expl:Behavior completeness check"
     (((>) (Uint32.to_int size_2) (0)) \/ ((=) (Uint32.to_int size_2) (0))))
     });
     (let i = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 25 7 15#
     (Unsafe_uint32.(>)  size_2
      (#"max_max.jc" 127 29 42# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_27 =
       (shift_  a
        (Unsafe_int32.to_int 
         (#"max_max.jc" 128 54 66# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_28 = max1 in
       (let _jessie_29 = (0) in
       (let _jessie_30 = _jessie_28 in
       (upd  int_xP_int_xM_max1_3 _jessie_30 _jessie_27 )))));
        begin
        (let _jessie_22 = (acc  !int_xP_int_xM_max1_3 max1 ) in
        (let _jessie_23 = max2 in
        (let _jessie_24 = (0) in
        (let _jessie_25 = _jessie_23 in
        (upd  int_xP_int_xM_max2_4 _jessie_25 _jessie_22 )))));
         begin
         (i :=
          (#"max_max.jc" 130 22 35# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_1:
          loop
          invariant
            { (((#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
                ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 30#
                 ((<) (0) (Uint32.to_int !i)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 29 38#
                (Uint32.(<=) !i size_2)))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 32 25 74#
                (exists j_0 : int.
                 (((<=) (0) j_0) /\
                 (((<) j_0 (Uint32.to_int !i)) /\
                 ((=) (shift a j_0) (select !int_xP_int_xM_max1_3 max1))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 33 25 74#
                (exists j_1 : int.
                 (((<=) (0) j_1) /\
                 (((<) j_1 (Uint32.to_int !i)) /\
                 ((=) (shift a j_1) (select !int_xP_int_xM_max2_4 max2))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 25 41#
                (Int32.(>=)
                (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
                (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 35 25 73#
                (forall j_2 : int.
                 ((((<=) (0) j_2) /\ ((<) j_2 (Uint32.to_int !i))) ->
                  (Int32.(<=) (select intP_intM_a_2 (shift a j_2))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 36 25 90#
                (exists j_3 : int.
                 (((<=) (0) j_3) /\
                 (((<) j_3 (Uint32.to_int !i)) /\
                 ((Int32.(>=) (select intP_intM_a_2 (shift a j_3))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                 /\
                 (Int32.(=) (select intP_intM_a_2 (shift a j_3))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
               &&
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 37 25 135#
               (not
               (exists j_4 : int.
                (exists k_1 : int.
                 (((<=) (0) j_4) /\
                 (((<) j_4 (Uint32.to_int !i)) /\
                 (((<=) (0) k_1) /\
                 (((<) k_1 (Uint32.to_int !i)) /\
                 (((<>) j_4 k_1) /\
                 ((Int32.(>) (select intP_intM_a_2 (shift a j_4))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                 /\
                 ((Int32.(>) (select intP_intM_a_2 (shift a k_1))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                 /\
                 (Int32.(>) (select intP_intM_a_2 (shift a k_1))
                 (select intP_intM_a_2 (shift a j_4))))))))))))))))))))
              /\
              (#"max_max.jc" 132 9 2904#
              ((#"max_max.jc" 132 9 2904# "expl:Assigns clause"
               (not_assigns int_xP_max1_3_alloc_table
               int_xP_max1_3_alloc_table (at !int_xP_int_xM_max1_3 'Loop_1)
               !int_xP_int_xM_max1_3 (pset_singleton max1)))
              /\
              (#"max_max.jc" 132 9 2904# "expl:Assigns clause"
              (not_assigns int_xP_max2_4_alloc_table
              int_xP_max2_4_alloc_table (at !int_xP_int_xM_max2_4 'Loop_1)
              !int_xP_int_xM_max2_4 (pset_singleton max2)))))) } 
           begin
           any unit requires { true } ensures { true } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 17 25#
             (Unsafe_uint32.(<)  !i size_2 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 13 26#
              (Unsafe_int32.(>) 
               (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) ) )
               (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max1_3 max1 ) ) ))
              then
               begin
               (let _jessie_11 = (acc  !int_xP_int_xM_max1_3 max1 ) in
               (let _jessie_12 = max2 in
               (let _jessie_13 = (0) in
               (let _jessie_14 = _jessie_12 in
               (upd  int_xP_int_xM_max2_4 _jessie_14 _jessie_11 )))));
                (let _jessie_16 = (shift_  a (Unsafe_uint32.to_int  !i ) ) in
                (let _jessie_17 = max1 in
                (let _jessie_18 = (0) in
                (let _jessie_19 = _jessie_17 in
                (upd  int_xP_int_xM_max1_3 _jessie_19 _jessie_16 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 20 33#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) )
                 ) (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max2_4 max2 ) ) ))
               then
                (let _jessie_6 = (shift_  a (Unsafe_uint32.to_int  !i ) ) in
                (let _jessie_7 = max2 in
                (let _jessie_8 = (0) in
                (let _jessie_9 = _jessie_7 in
                (upd  int_xP_int_xM_max2_4 _jessie_9 _jessie_6 ))))) 
               else ()));
              (i :=
               (Unsafe_uint32.(+)  !i
                (#"max_max.jc" 184 53 66# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
         end end end with Goto_while_0_break_exc _jessie_1 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
  let max_max_ensures_positive_size
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 22 5 59#
  "expl:Function max_max, behavior positive_size" =
  fun
   (a : (pointer intP)) (size_2 : Uint32.t) (max1 : (pointer int_xP)) (max2 :
   (pointer int_xP)) (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer
   intP))) (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP)))
   (intP_a_2_alloc_table : (alloc_table intP)) (int_xP_max1_3_alloc_table :
   (alloc_table int_xP)) (int_xP_max2_4_alloc_table : (alloc_table int_xP))
   (intP_a_2_tag_table : (tag_table intP)) (intP_intM_a_2 : (memory intP
   Int32.t)) 
   requires {
   (((>) (Uint32.to_int size_2) (0)) /\
   (((allocated intP_a_2_alloc_table a) ->
     (((=) (typeof intP_a_2_tag_table a) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_2_alloc_table a) i) /\
       ((<) i (offset_max intP_a_2_alloc_table a))) ->
       ((=) (typeof intP_a_2_tag_table (shift a i)) intP_tag)))))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_2) (1))) then
     (((<=) (offset_min intP_a_2_alloc_table a) (0)) /\
     (((>=) (offset_max intP_a_2_alloc_table a)
      (Int.(-) (Uint32.to_int size_2) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Uint32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 13 25#
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
    /\
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
    /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 29 41#
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
   /\ (#"max_max.jc" 36 12 1250# ((=) true true))))))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"max_max.jc" 65 10 36# "expl:Assigns clause"
       (not_assigns int_xP_max1_3_alloc_table int_xP_max1_3_alloc_table (old
       !int_xP_int_xM_max1_3) !int_xP_int_xM_max1_3 (pset_singleton max1)))
      /\
      (#"max_max.jc" 65 10 36# "expl:Assigns clause"
      (not_assigns int_xP_max2_4_alloc_table int_xP_max2_4_alloc_table (old
      !int_xP_int_xM_max2_4) !int_xP_int_xM_max2_4 (pset_singleton max2))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 27#
      "expl:Ensures clause"
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
       "expl:Ensures clause"
       ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
       "expl:Ensures clause"
       ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause" ((=) true true)))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 31 43#
      "expl:Ensures clause"
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
       "expl:Ensures clause"
       ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
       "expl:Ensures clause"
       ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
      "expl:Ensures clause" ((=) true true)))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 12 15 67#
      "expl:Ensures clause"
      (exists i_1 : int.
       (((<=) (0) i_1) /\
       (((<) i_1 (Uint32.to_int size_2)) /\
       ((=) (shift a i_1) (select !int_xP_int_xM_max1_3 max1))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 67#
      "expl:Ensures clause"
      (exists i_2 : int.
       (((<=) (0) i_2) /\
       (((<) i_2 (Uint32.to_int size_2)) /\
       ((=) (shift a i_2) (select !int_xP_int_xM_max2_4 max2))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 14 15 31#
      "expl:Ensures clause"
      (Int32.(>=) (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
      (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 15 15 66#
      "expl:Ensures clause"
      (forall i_3 : int.
       ((((<=) (0) i_3) /\ ((<) i_3 (Uint32.to_int size_2))) ->
        (Int32.(<=) (select intP_intM_a_2 (shift a i_3))
        (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 16 15 83#
      "expl:Ensures clause"
      (exists i_4 : int.
       (((<=) (0) i_4) /\
       (((<) i_4 (Uint32.to_int size_2)) /\
       ((Int32.(>=) (select intP_intM_a_2 (shift a i_4))
        (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
       /\
       (Int32.(=) (select intP_intM_a_2 (shift a i_4))
       (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 17 15 131#
     "expl:Ensures clause"
     (not
     (exists i_5 : int.
      (exists j_5 : int.
       (((<=) (0) i_5) /\
       (((<) i_5 (Uint32.to_int size_2)) /\
       (((<=) (0) j_5) /\
       (((<) j_5 (Uint32.to_int size_2)) /\
       (((<>) i_5 j_5) /\
       ((Int32.(>) (select intP_intM_a_2 (shift a i_5))
        (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
       /\
       ((Int32.(>) (select intP_intM_a_2 (shift a j_5))
        (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
       /\
       (Int32.(>) (select intP_intM_a_2 (shift a i_5))
       (select intP_intM_a_2 (shift a j_5))))))))))))))))))))))))))))))) }
   diverges  ->
   'Init:
   try
    begin
    (); ();
     (let i = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 25 7 15#
     (Unsafe_uint32.(>)  size_2
      (#"max_max.jc" 127 29 42# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_81 =
       (shift_  a
        (Unsafe_int32.to_int 
         (#"max_max.jc" 128 54 66# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_82 = max1 in
       (let _jessie_83 = (0) in
       (let _jessie_84 = _jessie_82 in
       (upd  int_xP_int_xM_max1_3 _jessie_84 _jessie_81 )))));
        begin
        (let _jessie_76 = (acc  !int_xP_int_xM_max1_3 max1 ) in
        (let _jessie_77 = max2 in
        (let _jessie_78 = (0) in
        (let _jessie_79 = _jessie_77 in
        (upd  int_xP_int_xM_max2_4 _jessie_79 _jessie_76 )))));
         begin
         (i :=
          (#"max_max.jc" 130 22 35# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_3:
          loop
          invariant
            { (#"max_max.jc" 132 9 2904#
              ((#"max_max.jc" 65 10 36# "expl:Assigns clause"
               (not_assigns int_xP_max1_3_alloc_table
               int_xP_max1_3_alloc_table (at !int_xP_int_xM_max1_3 'Init)
               !int_xP_int_xM_max1_3 (pset_singleton max1)))
              /\
              (#"max_max.jc" 65 10 36# "expl:Assigns clause"
              (not_assigns int_xP_max2_4_alloc_table
              int_xP_max2_4_alloc_table (at !int_xP_int_xM_max2_4 'Init)
              !int_xP_int_xM_max2_4 (pset_singleton max2))))) } 
           begin
           any unit
           requires { true } reads { a, int_xP_int_xM_max1_3,
           int_xP_int_xM_max2_4, max1, max2, size_2 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 37 25 135#
              (not
              (exists j_4 : int.
               (exists k_1 : int.
                (((<=) (0) j_4) /\
                (((<) j_4 (Uint32.to_int !i)) /\
                (((<=) (0) k_1) /\
                (((<) k_1 (Uint32.to_int !i)) /\
                (((<>) j_4 k_1) /\
                ((Int32.(>) (select intP_intM_a_2 (shift a j_4))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                ((Int32.(>) (select intP_intM_a_2 (shift a k_1))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                (Int32.(>) (select intP_intM_a_2 (shift a k_1))
                (select intP_intM_a_2 (shift a j_4))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 36 25 90#
              (exists j_3 : int.
               (((<=) (0) j_3) /\
               (((<) j_3 (Uint32.to_int !i)) /\
               ((Int32.(>=) (select intP_intM_a_2 (shift a j_3))
                (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
               /\
               (Int32.(=) (select intP_intM_a_2 (shift a j_3))
               (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 35 25 73#
              (forall j_2 : int.
               ((((<=) (0) j_2) /\ ((<) j_2 (Uint32.to_int !i))) ->
                (Int32.(<=) (select intP_intM_a_2 (shift a j_2))
                (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 25 41#
              (Int32.(>=)
              (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
              (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 33 25 74#
              (exists j_1 : int.
               (((<=) (0) j_1) /\
               (((<) j_1 (Uint32.to_int !i)) /\
               ((=) (shift a j_1) (select !int_xP_int_xM_max2_4 max2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 32 25 74#
              (exists j_0 : int.
               (((<=) (0) j_0) /\
               (((<) j_0 (Uint32.to_int !i)) /\
               ((=) (shift a j_0) (select !int_xP_int_xM_max1_3 max1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 30#
              ((<) (0) (Uint32.to_int !i)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 29 38#
             (Uint32.(<=) !i size_2))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 17 25#
             (Unsafe_uint32.(<)  !i size_2 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 13 26#
              (Unsafe_int32.(>) 
               (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) ) )
               (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max1_3 max1 ) ) ))
              then
               begin
               (let _jessie_65 = (acc  !int_xP_int_xM_max1_3 max1 ) in
               (let _jessie_66 = max2 in
               (let _jessie_67 = (0) in
               (let _jessie_68 = _jessie_66 in
               (upd  int_xP_int_xM_max2_4 _jessie_68 _jessie_65 )))));
                (let _jessie_70 = (shift_  a (Unsafe_uint32.to_int  !i ) ) in
                (let _jessie_71 = max1 in
                (let _jessie_72 = (0) in
                (let _jessie_73 = _jessie_71 in
                (upd  int_xP_int_xM_max1_3 _jessie_73 _jessie_70 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 20 33#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) )
                 ) (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max2_4 max2 ) ) ))
               then
                (let _jessie_60 = (shift_  a (Unsafe_uint32.to_int  !i ) ) in
                (let _jessie_61 = max2 in
                (let _jessie_62 = (0) in
                (let _jessie_63 = _jessie_61 in
                (upd  int_xP_int_xM_max2_4 _jessie_63 _jessie_60 )))))
               else ()));
              (i :=
               (Unsafe_uint32.(+)  !i
                (#"max_max.jc" 184 53 66# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
         end end end with Goto_while_0_break_exc _jessie_1 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
  let max_max_ensures_zero_size
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 22 5 59#
  "expl:Function max_max, behavior zero_size" =
  fun
   (a : (pointer intP)) (size_2 : Uint32.t) (max1 : (pointer int_xP)) (max2 :
   (pointer int_xP)) (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer
   intP))) (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP)))
   (intP_a_2_alloc_table : (alloc_table intP)) (int_xP_max1_3_alloc_table :
   (alloc_table int_xP)) (int_xP_max2_4_alloc_table : (alloc_table int_xP))
   (intP_a_2_tag_table : (tag_table intP)) (intP_intM_a_2 : (memory intP
   Int32.t)) 
   requires {
   (((=) (Uint32.to_int size_2) (0)) /\
   (((allocated intP_a_2_alloc_table a) ->
     (((=) (typeof intP_a_2_tag_table a) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_2_alloc_table a) i) /\
       ((<) i (offset_max intP_a_2_alloc_table a))) ->
       ((=) (typeof intP_a_2_tag_table (shift a i)) intP_tag)))))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 1 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_2) (1))) then
     (((<=) (offset_min intP_a_2_alloc_table a) (0)) /\
     (((>=) (offset_max intP_a_2_alloc_table a)
      (Int.(-) (Uint32.to_int size_2) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Uint32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 13 25#
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
    /\
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
    /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 29 41#
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
   /\ (#"max_max.jc" 36 12 1250# ((=) true true))))))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"max_max.jc" 60 10 18# "expl:Assigns clause"
       (not_assigns int_xP_max1_3_alloc_table int_xP_max1_3_alloc_table (old
       !int_xP_int_xM_max1_3) !int_xP_int_xM_max1_3 pset_empty))
      /\
      (#"max_max.jc" 60 10 18# "expl:Assigns clause"
      (not_assigns int_xP_max2_4_alloc_table int_xP_max2_4_alloc_table (old
      !int_xP_int_xM_max2_4) !int_xP_int_xM_max2_4 pset_empty)))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
      "expl:Ensures clause" ((=) max1 max1))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 7 15 33#
     "expl:Ensures clause" ((=) max2 max2))))))) } diverges  ->
   'Init:
   try
    begin
    (); ();
     (let i = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 25 7 15#
     (Unsafe_uint32.(>)  size_2
      (#"max_max.jc" 127 29 42# "expl:Integer cast"
      (Unsafe_uint32.of_int (0))) ))
     then
      try
       begin
       (let _jessie_54 =
       (shift_  a
        (Unsafe_int32.to_int 
         (#"max_max.jc" 128 54 66# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_55 = max1 in
       (let _jessie_56 = (0) in
       (let _jessie_57 = _jessie_55 in
       (upd  int_xP_int_xM_max1_3 _jessie_57 _jessie_54 )))));
        begin
        (let _jessie_49 = (acc  !int_xP_int_xM_max1_3 max1 ) in
        (let _jessie_50 = max2 in
        (let _jessie_51 = (0) in
        (let _jessie_52 = _jessie_50 in
        (upd  int_xP_int_xM_max2_4 _jessie_52 _jessie_49 )))));
         begin
         (i :=
          (#"max_max.jc" 130 22 35# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          'Loop_2:
          loop
          invariant
            { (#"max_max.jc" 132 9 2904#
              ((#"max_max.jc" 60 10 18# "expl:Assigns clause"
               (not_assigns int_xP_max1_3_alloc_table
               int_xP_max1_3_alloc_table (at !int_xP_int_xM_max1_3 'Init)
               !int_xP_int_xM_max1_3 pset_empty))
              /\
              (#"max_max.jc" 60 10 18# "expl:Assigns clause"
              (not_assigns int_xP_max2_4_alloc_table
              int_xP_max2_4_alloc_table (at !int_xP_int_xM_max2_4 'Init)
              !int_xP_int_xM_max2_4 pset_empty)))) } 
           begin
           any unit
           requires { true } reads { a, int_xP_int_xM_max1_3,
           int_xP_int_xM_max2_4, max1, max2, size_2 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 37 25 135#
              (not
              (exists j_4 : int.
               (exists k_1 : int.
                (((<=) (0) j_4) /\
                (((<) j_4 (Uint32.to_int !i)) /\
                (((<=) (0) k_1) /\
                (((<) k_1 (Uint32.to_int !i)) /\
                (((<>) j_4 k_1) /\
                ((Int32.(>) (select intP_intM_a_2 (shift a j_4))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                ((Int32.(>) (select intP_intM_a_2 (shift a k_1))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                (Int32.(>) (select intP_intM_a_2 (shift a k_1))
                (select intP_intM_a_2 (shift a j_4))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 36 25 90#
              (exists j_3 : int.
               (((<=) (0) j_3) /\
               (((<) j_3 (Uint32.to_int !i)) /\
               ((Int32.(>=) (select intP_intM_a_2 (shift a j_3))
                (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
               /\
               (Int32.(=) (select intP_intM_a_2 (shift a j_3))
               (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 35 25 73#
              (forall j_2 : int.
               ((((<=) (0) j_2) /\ ((<) j_2 (Uint32.to_int !i))) ->
                (Int32.(<=) (select intP_intM_a_2 (shift a j_2))
                (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 25 41#
              (Int32.(>=)
              (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
              (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 33 25 74#
              (exists j_1 : int.
               (((<=) (0) j_1) /\
               (((<) j_1 (Uint32.to_int !i)) /\
               ((=) (shift a j_1) (select !int_xP_int_xM_max2_4 max2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 32 25 74#
              (exists j_0 : int.
               (((<=) (0) j_0) /\
               (((<) j_0 (Uint32.to_int !i)) /\
               ((=) (shift a j_0) (select !int_xP_int_xM_max1_3 max1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 38#
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 25 30#
              ((<) (0) (Uint32.to_int !i)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 29 38#
             (Uint32.(<=) !i size_2))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 17 25#
             (Unsafe_uint32.(<)  !i size_2 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 13 26#
              (Unsafe_int32.(>) 
               (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) ) )
               (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max1_3 max1 ) ) ))
              then
               begin
               (let _jessie_38 = (acc  !int_xP_int_xM_max1_3 max1 ) in
               (let _jessie_39 = max2 in
               (let _jessie_40 = (0) in
               (let _jessie_41 = _jessie_39 in
               (upd  int_xP_int_xM_max2_4 _jessie_41 _jessie_38 )))));
                (let _jessie_43 = (shift_  a (Unsafe_uint32.to_int  !i ) ) in
                (let _jessie_44 = max1 in
                (let _jessie_45 = (0) in
                (let _jessie_46 = _jessie_44 in
                (upd  int_xP_int_xM_max1_3 _jessie_46 _jessie_43 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 45 20 33#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) )
                 ) (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max2_4 max2 ) ) ))
               then
                (let _jessie_33 = (shift_  a (Unsafe_uint32.to_int  !i ) ) in
                (let _jessie_34 = max2 in
                (let _jessie_35 = (0) in
                (let _jessie_36 = _jessie_34 in
                (upd  int_xP_int_xM_max2_4 _jessie_36 _jessie_33 )))))
               else ()));
              (i :=
               (Unsafe_uint32.(+)  !i
                (#"max_max.jc" 184 53 66# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
         end end end with Goto_while_0_break_exc _jessie_1 ->
       'While_0_break: 'While_0_break: () end else ()); (raise Return) end);
     (raise Return) end with Return -> () end
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_voidP

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP)) = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_charP

  use import Struct_voidP 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

module Struct_intP_unsafe

  use import Struct_intP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_intP
  (p : (pointer intP)) 
   (intP_alloc_table : ref (alloc_table intP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !intP_alloc_table p))
      }
    writes { intP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !intP_alloc_table (old !intP_alloc_table))) \/
      ((frame_free_struct_intP p (old !intP_alloc_table) !intP_alloc_table)
      /\ (fresh_alloc_struct_intP p !intP_alloc_table))) }
  
  val allocate_struct_intP_requires
  (n : int) 
   (intP_alloc_table : ref (alloc_table intP)) 
    (intP_tag_table : ref (tag_table intP)) : (pointer intP)
     requires { ((>=) n (0)) } writes { intP_alloc_table, intP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !intP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !intP_alloc_table)
        !intP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (old !intP_alloc_table)) /\
       ((fresh_tag_struct_intP result (old !intP_tag_table)) /\
       ((typeof_struct_intP result (0) n !intP_tag_table) /\
       (container_of_struct_intP result (0) n !intP_tag_table))))))) }
  
end

module Struct_intP_safe

  use import Struct_intP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_intP
  (p : (pointer intP)) 
   (intP_alloc_table : ref (alloc_table intP)) : unit
    requires { true } writes { intP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !intP_alloc_table (old !intP_alloc_table))) \/
      ((frame_free_struct_intP p (old !intP_alloc_table) !intP_alloc_table)
      /\ (fresh_alloc_struct_intP p !intP_alloc_table))) }
  
  val allocate_struct_intP
  (n : int) 
   (intP_alloc_table : ref (alloc_table intP)) 
    (intP_tag_table : ref (tag_table intP)) : (pointer intP)
     requires { true } writes { intP_alloc_table, intP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !intP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !intP_alloc_table)
        !intP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (old !intP_alloc_table)) /\
       ((fresh_tag_struct_intP result (old !intP_tag_table)) /\
       ((typeof_struct_intP result (0) n !intP_tag_table) /\
       (container_of_struct_intP result (0) n !intP_tag_table))))))) }
  
  val allocate_singleton_struct_intP
  (intP_alloc_table : ref (alloc_table intP)) 
   (intP_tag_table : ref (tag_table intP)) : (pointer intP)
    requires { true } writes { intP_alloc_table, intP_tag_table }
    ensures {
      ((strict_valid_struct_intP result (0) (0) !intP_alloc_table) /\
      ((frame_alloc_struct_intP result (1) (old !intP_alloc_table)
       !intP_alloc_table)
      /\
      ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
      /\
      ((fresh_alloc_struct_intP result (old !intP_alloc_table)) /\
      ((fresh_tag_struct_intP result (old !intP_tag_table)) /\
      ((typeof_singleton_struct_intP result !intP_tag_table) /\
      (container_of_singleton_struct_intP result !intP_tag_table))))))) }
  
end

theory Struct_int_xP

  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function int_xP_tag  : (tag_id int_xP)
  
  axiom Int_xP_parenttag_bottom :
  (parenttag int_xP_tag bottom_tag)
  
  axiom Int_xP_is_final :
  (forall int_xP_tag_table : (tag_table int_xP).
   (forall p : (pointer int_xP).
    ((instanceof int_xP_tag_table p int_xP_tag) ->
     ((=) (typeof int_xP_tag_table p) int_xP_tag))))
  
  predicate frame_tag_struct_int_xP (p : (pointer int_xP))
  (old_int_xP_tag_table : (tag_table int_xP)) (int_xP_tag_table : (tag_table
  int_xP))
  =
     ((tag_extends old_int_xP_tag_table int_xP_tag_table) /\
     (alloc_tag_block old_int_xP_tag_table int_xP_tag_table p))
  
  predicate frame_free_struct_int_xP (p : (pointer int_xP))
  (old_int_xP_alloc_table : (alloc_table int_xP)) (int_xP_alloc_table :
  (alloc_table int_xP))
  =
     ((free_extends old_int_xP_alloc_table int_xP_alloc_table) /\
     (free_block old_int_xP_alloc_table int_xP_alloc_table p))
  
  predicate frame_alloc_struct_int_xP (p : (pointer int_xP)) (n : int)
  (old_int_xP_alloc_table : (alloc_table int_xP)) (int_xP_alloc_table :
  (alloc_table int_xP))
  =
     ((alloc_extends old_int_xP_alloc_table int_xP_alloc_table) /\
     (alloc_block old_int_xP_alloc_table int_xP_alloc_table p n))
  
  predicate fresh_tag_struct_int_xP (p : (pointer int_xP)) (int_xP_tag_table
  : (tag_table int_xP)) = (tag_fresh int_xP_tag_table p)
  
  predicate fresh_alloc_struct_int_xP (p : (pointer int_xP))
  (int_xP_alloc_table : (alloc_table int_xP))
  = (alloc_fresh int_xP_alloc_table p)
  
  predicate container_of_singleton_struct_int_xP (p : (pointer int_xP))
  (int_xP_tag_table : (tag_table int_xP)) = true
  
  predicate container_of_struct_int_xP (p : (pointer int_xP)) (l : int) (r :
  int) (int_xP_tag_table : (tag_table int_xP)) = true
  
  predicate typeof_singleton_struct_int_xP (p : (pointer int_xP))
  (int_xP_tag_table : (tag_table int_xP))
  = ((=) (typeof int_xP_tag_table p) int_xP_tag)
  
  predicate typeof_struct_int_xP (p : (pointer int_xP)) (l : int) (r : int)
  (int_xP_tag_table : (tag_table int_xP))
  =
     (((=) (typeof int_xP_tag_table p) int_xP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof int_xP_tag_table (shift p i)) int_xP_tag))))
  
  predicate instanceof_singleton_struct_int_xP (p : (pointer int_xP))
  (int_xP_tag_table : (tag_table int_xP))
  = (instanceof int_xP_tag_table p int_xP_tag)
  
  predicate instanceof_struct_int_xP (p : (pointer int_xP)) (l : int) (r :
  int) (int_xP_tag_table : (tag_table int_xP))
  =
     ((instanceof int_xP_tag_table p int_xP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof int_xP_tag_table (shift p i) int_xP_tag))))
  
  predicate right_valid_struct_int_xP (p : (pointer int_xP)) (b : int)
  (int_xP_alloc_table : (alloc_table int_xP))
  = ((>=) (offset_max int_xP_alloc_table p) b)
  
  predicate left_valid_struct_int_xP (p : (pointer int_xP)) (a : int)
  (int_xP_alloc_table : (alloc_table int_xP))
  = ((<=) (offset_min int_xP_alloc_table p) a)
  
  predicate valid_struct_int_xP (p : (pointer int_xP)) (a : int) (b : int)
  (int_xP_alloc_table : (alloc_table int_xP))
  =
     (((<=) (offset_min int_xP_alloc_table p) a) /\
     ((>=) (offset_max int_xP_alloc_table p) b))
  
  predicate strict_valid_struct_int_xP (p : (pointer int_xP)) (a : int) (b :
  int) (int_xP_alloc_table : (alloc_table int_xP))
  =
     (((=) (offset_min int_xP_alloc_table p) a) /\
     ((=) (offset_max int_xP_alloc_table p) b))
  
  axiom Int_xP_int : ((=) (int_of_tag int_xP_tag) (5))
  
end

module Struct_int_xP_unsafe

  use import Struct_int_xP 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_int_xP
  (p : (pointer int_xP)) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !int_xP_alloc_table p)) }
    writes { int_xP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !int_xP_alloc_table (old !int_xP_alloc_table)))
      \/
      ((frame_free_struct_int_xP p (old !int_xP_alloc_table)
       !int_xP_alloc_table)
      /\ (fresh_alloc_struct_int_xP p !int_xP_alloc_table))) }
  
  val allocate_struct_int_xP_requires
  (n : int) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) 
    (int_xP_tag_table : ref (tag_table int_xP)) : (pointer int_xP)
     requires { ((>=) n (0)) } writes { int_xP_alloc_table, int_xP_tag_table
     }
     ensures {
       ((strict_valid_struct_int_xP result (0) (Int.(-) n (1))
        !int_xP_alloc_table)
       /\
       ((frame_alloc_struct_int_xP result n (old !int_xP_alloc_table)
        !int_xP_alloc_table)
       /\
       ((frame_tag_struct_int_xP result (old !int_xP_tag_table)
        !int_xP_tag_table)
       /\
       ((fresh_alloc_struct_int_xP result (old !int_xP_alloc_table)) /\
       ((fresh_tag_struct_int_xP result (old !int_xP_tag_table)) /\
       ((typeof_struct_int_xP result (0) n !int_xP_tag_table) /\
       (container_of_struct_int_xP result (0) n !int_xP_tag_table))))))) }
  
end

module Struct_int_xP_safe

  use import Struct_int_xP 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_int_xP
  (p : (pointer int_xP)) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) : unit
    requires { true } writes { int_xP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !int_xP_alloc_table (old !int_xP_alloc_table)))
      \/
      ((frame_free_struct_int_xP p (old !int_xP_alloc_table)
       !int_xP_alloc_table)
      /\ (fresh_alloc_struct_int_xP p !int_xP_alloc_table))) }
  
  val allocate_struct_int_xP
  (n : int) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) 
    (int_xP_tag_table : ref (tag_table int_xP)) : (pointer int_xP)
     requires { true } writes { int_xP_alloc_table, int_xP_tag_table }
     ensures {
       ((strict_valid_struct_int_xP result (0) (Int.(-) n (1))
        !int_xP_alloc_table)
       /\
       ((frame_alloc_struct_int_xP result n (old !int_xP_alloc_table)
        !int_xP_alloc_table)
       /\
       ((frame_tag_struct_int_xP result (old !int_xP_tag_table)
        !int_xP_tag_table)
       /\
       ((fresh_alloc_struct_int_xP result (old !int_xP_alloc_table)) /\
       ((fresh_tag_struct_int_xP result (old !int_xP_tag_table)) /\
       ((typeof_struct_int_xP result (0) n !int_xP_tag_table) /\
       (container_of_struct_int_xP result (0) n !int_xP_tag_table))))))) }
  
  val allocate_singleton_struct_int_xP
  (int_xP_alloc_table : ref (alloc_table int_xP)) 
   (int_xP_tag_table : ref (tag_table int_xP)) : (pointer int_xP)
    requires { true } writes { int_xP_alloc_table, int_xP_tag_table }
    ensures {
      ((strict_valid_struct_int_xP result (0) (0) !int_xP_alloc_table) /\
      ((frame_alloc_struct_int_xP result (1) (old !int_xP_alloc_table)
       !int_xP_alloc_table)
      /\
      ((frame_tag_struct_int_xP result (old !int_xP_tag_table)
       !int_xP_tag_table)
      /\
      ((fresh_alloc_struct_int_xP result (old !int_xP_alloc_table)) /\
      ((fresh_tag_struct_int_xP result (old !int_xP_tag_table)) /\
      ((typeof_singleton_struct_int_xP result !int_xP_tag_table) /\
      (container_of_singleton_struct_int_xP result !int_xP_tag_table))))))) }
  
end

theory Root_unsigned_charP

  use why3.Bool.Bool 
  
  type unsigned_charP 
  
end

theory Struct_unsigned_charP

  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function unsigned_charP_tag  : (tag_id
  unsigned_charP)
  
  axiom Unsigned_charP_parenttag_bottom :
  (parenttag unsigned_charP_tag bottom_tag)
  
  axiom Unsigned_charP_is_final :
  (forall unsigned_charP_tag_table : (tag_table unsigned_charP).
   (forall p : (pointer unsigned_charP).
    ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) ->
     ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag))))
  
  predicate frame_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_tag_table : (tag_table unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((tag_extends old_unsigned_charP_tag_table unsigned_charP_tag_table) /\
     (alloc_tag_block old_unsigned_charP_tag_table unsigned_charP_tag_table
     p))
  
  predicate frame_free_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((free_extends old_unsigned_charP_alloc_table unsigned_charP_alloc_table)
     /\
     (free_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p))
  
  predicate frame_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (n : int) (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((alloc_extends old_unsigned_charP_alloc_table
      unsigned_charP_alloc_table)
     /\
     (alloc_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p
     n))
  
  predicate fresh_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (tag_fresh unsigned_charP_tag_table p)
  
  predicate fresh_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = (alloc_fresh unsigned_charP_alloc_table p)
  
  predicate container_of_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate container_of_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate typeof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag)
  
  predicate typeof_struct_unsigned_charP (p : (pointer unsigned_charP)) (l :
  int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     (((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof unsigned_charP_tag_table (shift p i)) unsigned_charP_tag))))
  
  predicate instanceof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (instanceof unsigned_charP_tag_table p unsigned_charP_tag)
  
  predicate instanceof_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof unsigned_charP_tag_table (shift p i) unsigned_charP_tag))))
  
  predicate right_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((>=) (offset_max unsigned_charP_alloc_table p) b)
  
  predicate left_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((<=) (offset_min unsigned_charP_alloc_table p) a)
  
  predicate valid_struct_unsigned_charP (p : (pointer unsigned_charP)) (a :
  int) (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     (((<=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((>=) (offset_max unsigned_charP_alloc_table p) b))
  
  predicate strict_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (b : int) (unsigned_charP_alloc_table : (alloc_table
  unsigned_charP))
  =
     (((=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((=) (offset_max unsigned_charP_alloc_table p) b))
  
  axiom Unsigned_charP_int : ((=) (int_of_tag unsigned_charP_tag) (6))
  
end

module Struct_unsigned_charP_unsafe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !unsigned_charP_alloc_table p)) }
    writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP_requires
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { ((>=) n (0)) } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
end

module Struct_unsigned_charP_safe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires { true } writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { true } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
  val allocate_singleton_struct_unsigned_charP
  (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
   (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
    unsigned_charP)
    requires { true } writes { unsigned_charP_alloc_table,
    unsigned_charP_tag_table }
    ensures {
      ((strict_valid_struct_unsigned_charP result (0) (0)
       !unsigned_charP_alloc_table)
      /\
      ((frame_alloc_struct_unsigned_charP result (1) (old
       !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
      /\
      ((frame_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table) !unsigned_charP_tag_table)
      /\
      ((fresh_alloc_struct_unsigned_charP result (old
       !unsigned_charP_alloc_table))
      /\
      ((fresh_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table))
      /\
      ((typeof_singleton_struct_unsigned_charP result
       !unsigned_charP_tag_table)
      /\
      (container_of_singleton_struct_unsigned_charP result
      !unsigned_charP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Function_max_max

  use enum.Uint32 
  
  use import Root_int_xP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val max_max
  (a : (pointer intP)) 
   (size_2 : Uint32.t) 
    (max1 : (pointer int_xP)) 
     (max2 : (pointer int_xP)) 
      (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP))) 
       (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer intP))) 
        (int_xP_max2_4_alloc_table : (alloc_table int_xP)) 
         (int_xP_max1_3_alloc_table : (alloc_table int_xP)) 
          (intP_a_2_alloc_table : (alloc_table intP)) 
           (intP_a_2_tag_table : (tag_table intP)) 
            (intP_intM_a_2 : (memory intP Int32.t)) : unit
             requires { true } reads { int_xP_int_xM_max1_3,
             int_xP_int_xM_max2_4 } writes { int_xP_int_xM_max1_3,
             int_xP_int_xM_max2_4 }
             ensures {
               ((((>) (Uint32.to_int size_2) (0)) ->
                 (((#"max_max.jc" 65 10 36# "expl:Assigns clause"
                   (not_assigns int_xP_max1_3_alloc_table
                   int_xP_max1_3_alloc_table (old !int_xP_int_xM_max1_3)
                   !int_xP_int_xM_max1_3 (pset_singleton max1)))
                  /\
                  (#"max_max.jc" 65 10 36# "expl:Assigns clause"
                  (not_assigns int_xP_max2_4_alloc_table
                  int_xP_max2_4_alloc_table (old !int_xP_int_xM_max2_4)
                  !int_xP_int_xM_max2_4 (pset_singleton max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 27#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 31 43#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 12 15 67#
                  "expl:Ensures clause"
                  (exists i_1 : int.
                   (((<=) (0) i_1) /\
                   (((<) i_1 (Uint32.to_int size_2)) /\
                   ((=) (shift a i_1) (select !int_xP_int_xM_max1_3 max1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 67#
                  "expl:Ensures clause"
                  (exists i_2 : int.
                   (((<=) (0) i_2) /\
                   (((<) i_2 (Uint32.to_int size_2)) /\
                   ((=) (shift a i_2) (select !int_xP_int_xM_max2_4 max2))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 14 15 31#
                  "expl:Ensures clause"
                  (Int32.(>=)
                  (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 15 15 66#
                  "expl:Ensures clause"
                  (forall i_3 : int.
                   ((((<=) (0) i_3) /\ ((<) i_3 (Uint32.to_int size_2))) ->
                    (Int32.(<=) (select intP_intM_a_2 (shift a i_3))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max1_3 max1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 16 15 83#
                  "expl:Ensures clause"
                  (exists i_4 : int.
                   (((<=) (0) i_4) /\
                   (((<) i_4 (Uint32.to_int size_2)) /\
                   ((Int32.(>=) (select intP_intM_a_2 (shift a i_4))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   (Int32.(=) (select intP_intM_a_2 (shift a i_4))
                   (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 17 15 131#
                 "expl:Ensures clause"
                 (not
                 (exists i_5 : int.
                  (exists j_5 : int.
                   (((<=) (0) i_5) /\
                   (((<) i_5 (Uint32.to_int size_2)) /\
                   (((<=) (0) j_5) /\
                   (((<) j_5 (Uint32.to_int size_2)) /\
                   (((<>) i_5 j_5) /\
                   ((Int32.(>) (select intP_intM_a_2 (shift a i_5))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   ((Int32.(>) (select intP_intM_a_2 (shift a j_5))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   (Int32.(>) (select intP_intM_a_2 (shift a i_5))
                   (select intP_intM_a_2 (shift a j_5)))))))))))))))))))))))))))))))
               /\
               (((=) (Uint32.to_int size_2) (0)) ->
                (((#"max_max.jc" 60 10 18# "expl:Assigns clause"
                  (not_assigns int_xP_max1_3_alloc_table
                  int_xP_max1_3_alloc_table (old !int_xP_int_xM_max1_3)
                  !int_xP_int_xM_max1_3 pset_empty))
                 /\
                 (#"max_max.jc" 60 10 18# "expl:Assigns clause"
                 (not_assigns int_xP_max2_4_alloc_table
                 int_xP_max2_4_alloc_table (old !int_xP_int_xM_max2_4)
                 !int_xP_int_xM_max2_4 pset_empty)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                "expl:Ensures clause"
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                "expl:Ensures clause"
                ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                 "expl:Ensures clause" ((=) max1 max1))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 7 15 33#
                "expl:Ensures clause" ((=) max2 max2)))))))) }
  
end

module Function_max_max_safe

  use enum.Uint32 
  
  use import Root_int_xP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val max_max
  (a : (pointer intP)) 
   (size_2 : Uint32.t) 
    (max1 : (pointer int_xP)) 
     (max2 : (pointer int_xP)) 
      (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP))) 
       (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer intP))) 
        (int_xP_max2_4_alloc_table : (alloc_table int_xP)) 
         (int_xP_max1_3_alloc_table : (alloc_table int_xP)) 
          (intP_a_2_alloc_table : (alloc_table intP)) 
           (intP_a_2_tag_table : (tag_table intP)) 
            (intP_intM_a_2 : (memory intP Int32.t)) : unit
             requires {
               ("expl:Internal"
               (#"max_max.jc" 36 12 1250# "expl:Requires clause"
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 1 13 34#
                "expl:Requires clause"
                (if ((<=) (0) (Int.(-) (Uint32.to_int size_2) (1))) then
                 (((<=) (offset_min intP_a_2_alloc_table a) (0)) /\
                 (((>=) (offset_max intP_a_2_alloc_table a)
                  (Int.(-) (Uint32.to_int size_2) (1)))
                 /\
                 (forall __framac_tmp3 : int.
                  ((((<=) (0) __framac_tmp3) /\
                   ((<=) __framac_tmp3 (Int.(-) (Uint32.to_int size_2) (1))))
                   -> ((=) true true))))) else ((=) true true)))
               /\
               (#"max_max.jc" 36 12 1250# "expl:Requires clause"
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 13 25#
                "expl:Requires clause"
                (#"max_max.jc" 36 12 1250# "expl:Requires clause"
                ((#"max_max.jc" 36 12 1250# "expl:Requires clause"
                 ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
                /\
                (#"max_max.jc" 36 12 1250# "expl:Requires clause"
                ((#"max_max.jc" 36 12 1250# "expl:Requires clause"
                 ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
                /\
                (#"max_max.jc" 36 12 1250# "expl:Requires clause"
                ((=) true true)))))))
               /\
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 2 29 41#
               "expl:Requires clause"
               (#"max_max.jc" 36 12 1250# "expl:Requires clause"
               ((#"max_max.jc" 36 12 1250# "expl:Requires clause"
                ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
               /\
               (#"max_max.jc" 36 12 1250# "expl:Requires clause"
               ((#"max_max.jc" 36 12 1250# "expl:Requires clause"
                ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
               /\
               (#"max_max.jc" 36 12 1250# "expl:Requires clause"
               ((=) true true)))))))))))) }
             reads { int_xP_int_xM_max1_3, int_xP_int_xM_max2_4 } writes {
             int_xP_int_xM_max1_3, int_xP_int_xM_max2_4 }
             ensures {
               ((((>) (Uint32.to_int size_2) (0)) ->
                 (((#"max_max.jc" 65 10 36# "expl:Assigns clause"
                   (not_assigns int_xP_max1_3_alloc_table
                   int_xP_max1_3_alloc_table (old !int_xP_int_xM_max1_3)
                   !int_xP_int_xM_max1_3 (pset_singleton max1)))
                  /\
                  (#"max_max.jc" 65 10 36# "expl:Assigns clause"
                  (not_assigns int_xP_max2_4_alloc_table
                  int_xP_max2_4_alloc_table (old !int_xP_int_xM_max2_4)
                  !int_xP_int_xM_max2_4 (pset_singleton max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 27#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 31 43#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 12 15 67#
                  "expl:Ensures clause"
                  (exists i_1 : int.
                   (((<=) (0) i_1) /\
                   (((<) i_1 (Uint32.to_int size_2)) /\
                   ((=) (shift a i_1) (select !int_xP_int_xM_max1_3 max1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 67#
                  "expl:Ensures clause"
                  (exists i_2 : int.
                   (((<=) (0) i_2) /\
                   (((<) i_2 (Uint32.to_int size_2)) /\
                   ((=) (shift a i_2) (select !int_xP_int_xM_max2_4 max2))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 14 15 31#
                  "expl:Ensures clause"
                  (Int32.(>=)
                  (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 15 15 66#
                  "expl:Ensures clause"
                  (forall i_3 : int.
                   ((((<=) (0) i_3) /\ ((<) i_3 (Uint32.to_int size_2))) ->
                    (Int32.(<=) (select intP_intM_a_2 (shift a i_3))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max1_3 max1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 11 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 16 15 83#
                  "expl:Ensures clause"
                  (exists i_4 : int.
                   (((<=) (0) i_4) /\
                   (((<) i_4 (Uint32.to_int size_2)) /\
                   ((Int32.(>=) (select intP_intM_a_2 (shift a i_4))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   (Int32.(=) (select intP_intM_a_2 (shift a i_4))
                   (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 17 15 131#
                 "expl:Ensures clause"
                 (not
                 (exists i_5 : int.
                  (exists j_5 : int.
                   (((<=) (0) i_5) /\
                   (((<) i_5 (Uint32.to_int size_2)) /\
                   (((<=) (0) j_5) /\
                   (((<) j_5 (Uint32.to_int size_2)) /\
                   (((<>) i_5 j_5) /\
                   ((Int32.(>) (select intP_intM_a_2 (shift a i_5))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   ((Int32.(>) (select intP_intM_a_2 (shift a j_5))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   (Int32.(>) (select intP_intM_a_2 (shift a i_5))
                   (select intP_intM_a_2 (shift a j_5)))))))))))))))))))))))))))))))
               /\
               (((=) (Uint32.to_int size_2) (0)) ->
                (((#"max_max.jc" 60 10 18# "expl:Assigns clause"
                  (not_assigns int_xP_max1_3_alloc_table
                  int_xP_max1_3_alloc_table (old !int_xP_int_xM_max1_3)
                  !int_xP_int_xM_max1_3 pset_empty))
                 /\
                 (#"max_max.jc" 60 10 18# "expl:Assigns clause"
                 (not_assigns int_xP_max2_4_alloc_table
                 int_xP_max2_4_alloc_table (old !int_xP_int_xM_max2_4)
                 !int_xP_int_xM_max2_4 pset_empty)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                "expl:Ensures clause"
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                "expl:Ensures clause"
                ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 6 15 33#
                 "expl:Ensures clause" ((=) max1 max1))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 7 15 33#
                "expl:Ensures clause" ((=) max2 max2)))))))) }
  
end
