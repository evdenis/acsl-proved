
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Jessie_voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_safe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_unsafe

  use why3.Bool.Bool 
  
end

module Root_int_xP_safe

  use why3.Bool.Bool 
  
end

module Root_int_xP_unsafe

  use why3.Bool.Bool 
  
end

module Root_intP_safe

  use why3.Bool.Bool 
  
end

module Root_intP_unsafe

  use why3.Bool.Bool 
  
end

theory Root_intP

  use why3.Bool.Bool 
  
  type intP 
  
end

theory Root_int_xP

  use why3.Bool.Bool 
  
  type int_xP 
  
end

theory Struct_intP

  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function intP_tag  : (tag_id intP)
  
  axiom IntP_parenttag_bottom :
  (parenttag intP_tag bottom_tag)
  
  axiom IntP_is_final :
  (forall intP_tag_table : (tag_table intP).
   (forall p : (pointer intP).
    ((instanceof intP_tag_table p intP_tag) ->
     ((=) (typeof intP_tag_table p) intP_tag))))
  
  predicate frame_tag_struct_intP (p : (pointer intP)) (old_intP_tag_table :
  (tag_table intP)) (intP_tag_table : (tag_table intP))
  =
     ((tag_extends old_intP_tag_table intP_tag_table) /\
     (alloc_tag_block old_intP_tag_table intP_tag_table p))
  
  predicate frame_free_struct_intP (p : (pointer intP)) (old_intP_alloc_table
  : (alloc_table intP)) (intP_alloc_table : (alloc_table intP))
  =
     ((free_extends old_intP_alloc_table intP_alloc_table) /\
     (free_block old_intP_alloc_table intP_alloc_table p))
  
  predicate frame_alloc_struct_intP (p : (pointer intP)) (n : int)
  (old_intP_alloc_table : (alloc_table intP)) (intP_alloc_table :
  (alloc_table intP))
  =
     ((alloc_extends old_intP_alloc_table intP_alloc_table) /\
     (alloc_block old_intP_alloc_table intP_alloc_table p n))
  
  predicate fresh_tag_struct_intP (p : (pointer intP)) (intP_tag_table :
  (tag_table intP)) = (tag_fresh intP_tag_table p)
  
  predicate fresh_alloc_struct_intP (p : (pointer intP)) (intP_alloc_table :
  (alloc_table intP)) = (alloc_fresh intP_alloc_table p)
  
  predicate container_of_singleton_struct_intP (p : (pointer intP))
  (intP_tag_table : (tag_table intP)) = true
  
  predicate container_of_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP)) = true
  
  predicate typeof_singleton_struct_intP (p : (pointer intP)) (intP_tag_table
  : (tag_table intP)) = ((=) (typeof intP_tag_table p) intP_tag)
  
  predicate typeof_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP))
  =
     (((=) (typeof intP_tag_table p) intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof intP_tag_table (shift p i)) intP_tag))))
  
  predicate instanceof_singleton_struct_intP (p : (pointer intP))
  (intP_tag_table : (tag_table intP))
  = (instanceof intP_tag_table p intP_tag)
  
  predicate instanceof_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP))
  =
     ((instanceof intP_tag_table p intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof intP_tag_table (shift p i) intP_tag))))
  
  predicate right_valid_struct_intP (p : (pointer intP)) (b : int)
  (intP_alloc_table : (alloc_table intP))
  = ((>=) (offset_max intP_alloc_table p) b)
  
  predicate left_valid_struct_intP (p : (pointer intP)) (a : int)
  (intP_alloc_table : (alloc_table intP))
  = ((<=) (offset_min intP_alloc_table p) a)
  
  predicate valid_struct_intP (p : (pointer intP)) (a : int) (b : int)
  (intP_alloc_table : (alloc_table intP))
  =
     (((<=) (offset_min intP_alloc_table p) a) /\
     ((>=) (offset_max intP_alloc_table p) b))
  
  predicate strict_valid_struct_intP (p : (pointer intP)) (a : int) (b : int)
  (intP_alloc_table : (alloc_table intP))
  =
     (((=) (offset_min intP_alloc_table p) a) /\
     ((=) (offset_max intP_alloc_table p) b))
  
  axiom IntP_int : ((=) (int_of_tag intP_tag) (4))
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Goto_while_0_break_exc unit
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Function_max_max_safety

  use enum.Uint32 
  
  use import Struct_intP 
  
  use Safe_uint32 
  
  use Safe_int32 
  
  use import Root_int_xP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_upd_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  let max_max
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 28 5 59#
  "expl:Function max_max, safety" =
  fun
   (a : (pointer intP)) (size_2 : Uint32.t) (max1 : (pointer int_xP)) (max2 :
   (pointer int_xP)) (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer
   intP))) (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP)))
   (intP_a_2_alloc_table : (alloc_table intP)) (int_xP_max1_3_alloc_table :
   (alloc_table int_xP)) (int_xP_max2_4_alloc_table : (alloc_table int_xP))
   (intP_a_2_tag_table : (tag_table intP)) (intP_intM_a_2 : (memory intP
   Int32.t)) 
   requires {
   (((allocated intP_a_2_alloc_table a) ->
     (((=) (typeof intP_a_2_tag_table a) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_2_alloc_table a) i) /\
       ((<) i (offset_max intP_a_2_alloc_table a))) ->
       ((=) (typeof intP_a_2_tag_table (shift a i)) intP_tag)))))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 3 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_2) (1))) then
     (((<=) (offset_min intP_a_2_alloc_table a) (0)) /\
     (((>=) (offset_max intP_a_2_alloc_table a)
      (Int.(-) (Uint32.to_int size_2) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Uint32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 13 25#
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
    /\
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
    /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 29 41#
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
   /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (); (); (); ();
     (let i = ref (Safe_uint32.any_  () ) in
     (let x = ref (Safe_uint32.any_  () ) in
     (let y = ref (Safe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 7 16#
     (Safe_uint32.(=)  size_2
      (#"max_max.jc" 149 30 43# "expl:Integer cast" (Safe_uint32.of_int (1)))
      ))
     then
      begin
      (let _jessie_200 =
      (let _jessie_199 =
      (shift_typesafe  a
       (Safe_int32.to_int 
        (#"max_max.jc" 150 57 69# "expl:Integer cast"
        (Safe_int32.of_int (0))) ) ) in
      begin
      (assert {
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 32 6 19#
      "expl:Pointer index bounds" true) }); _jessie_199 end) in
      (let _jessie_201 = max1 in
      (let _jessie_202 = (0) in
      (let _jessie_203 = _jessie_201 in
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 32 6 19#
      "expl:Pointer dereference"
      (upd  int_xP_max1_3_alloc_table int_xP_int_xM_max1_3 _jessie_201
       _jessie_200 ))))));
       (let _jessie_205 =
       (let _jessie_204 =
       (shift_typesafe  a
        (Safe_int32.to_int 
         (#"max_max.jc" 151 57 69# "expl:Integer cast"
         (Safe_int32.of_int (0))) ) ) in
       begin
       (assert {
       (#"/home/work/workspace/education/acsl-exam/./max_max.c" 33 6 19#
       "expl:Pointer index bounds" true) }); _jessie_204 end) in
       (let _jessie_206 = max2 in
       (let _jessie_207 = (0) in
       (let _jessie_208 = _jessie_206 in
       (#"/home/work/workspace/education/acsl-exam/./max_max.c" 33 6 19#
       "expl:Pointer dereference"
       (upd  int_xP_max2_4_alloc_table int_xP_int_xM_max2_4 _jessie_206
        _jessie_205 )))))) end
     else
      (if
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 14 22#
      (Safe_uint32.(>)  size_2
       (#"max_max.jc" 152 36 49# "expl:Integer cast"
       (Safe_uint32.of_int (1))) ))
      then
       try
        begin
        begin
        (if
        (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 10 21#
        (Safe_int32.(>) 
         (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 10 14#
         "expl:Pointer dereference"
         (acc  intP_a_2_alloc_table intP_intM_a_2 a ))
         (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 17 21#
         "expl:Pointer dereference"
         (acc_offset_typesafe  intP_a_2_alloc_table intP_intM_a_2 a (1) )) ))
        then
         begin
         (x :=
          (let _jessie_170 =
          (#"max_max.jc" 156 35 48# "expl:Integer cast"
          (Safe_uint32.of_int (0))) in
          begin
          (assert {
          (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 26 31#
          "expl:Pointer index bounds" true) }); _jessie_170 end));
          begin
          (y :=
           (let _jessie_171 =
           (#"max_max.jc" 157 35 48# "expl:Integer cast"
           (Safe_uint32.of_int (1))) in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 33 38#
           "expl:Pointer index bounds" true) }); _jessie_171 end));
           (if
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 33 38#
           (Safe_uint32.(<>)  !y
            (#"max_max.jc" 158 52 65# "expl:Integer cast"
            (Safe_uint32.of_int (0))) )) then () else ()) end end
        else
         begin
         (x :=
          (let _jessie_168 =
          (#"max_max.jc" 160 35 48# "expl:Integer cast"
          (Safe_uint32.of_int (1))) in
          begin
          (assert {
          (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 43 48#
          "expl:Pointer index bounds" true) }); _jessie_168 end));
          begin
          (y :=
           (let _jessie_169 =
           (#"max_max.jc" 161 35 48# "expl:Integer cast"
           (Safe_uint32.of_int (0))) in
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 50 55#
           "expl:Pointer index bounds" true) }); _jessie_169 end));
           (if
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 50 55#
           (Safe_uint32.(<>)  !y
            (#"max_max.jc" 162 52 65# "expl:Integer cast"
            (Safe_uint32.of_int (0))) )) then () else ()) end end);
         begin
         any unit
         requires { true } reads { a }
         ensures {
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 40 20 32#
           (Int32.(>=) (select intP_intM_a_2 (shift a (Uint32.to_int !x)))
           (select intP_intM_a_2 (shift a (Uint32.to_int !y))))) } ; () end;
         begin
         (let _jessie_173 =
         (let _jessie_172 = (shift_typesafe  a (Safe_uint32.to_int  !x ) ) in
         begin
         (assert {
         (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 9 22#
         "expl:Pointer index bounds" true) }); _jessie_172 end) in
         (let _jessie_174 = max1 in
         (let _jessie_175 = (0) in
         (let _jessie_176 = _jessie_174 in
         (#"/home/work/workspace/education/acsl-exam/./max_max.c" 41 9 22#
         "expl:Pointer dereference"
         (upd  int_xP_max1_3_alloc_table int_xP_int_xM_max1_3 _jessie_174
          _jessie_173 ))))));
          begin
          (let _jessie_178 =
          (let _jessie_177 = (shift_typesafe  a (Safe_uint32.to_int  !y ) )
          in
          begin
          (assert {
          (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 9 22#
          "expl:Pointer index bounds" true) }); _jessie_177 end) in
          (let _jessie_179 = max2 in
          (let _jessie_180 = (0) in
          (let _jessie_181 = _jessie_179 in
          (#"/home/work/workspace/education/acsl-exam/./max_max.c" 42 9 22#
          "expl:Pointer dereference"
          (upd  int_xP_max2_4_alloc_table int_xP_int_xM_max2_4 _jessie_179
           _jessie_178 ))))));
           begin
           any unit
           requires { true } reads { int_xP_int_xM_max1_3,
           int_xP_int_xM_max2_4, max1, max2 }
           ensures {
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 43 20 36#
             (Int32.(>=)
             (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
             (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))) } ;
            () end end end end;
         begin
         (i :=
          (let _jessie_182 =
          (#"max_max.jc" 181 30 43# "expl:Integer cast"
          (Safe_uint32.of_int (2))) in
          begin
          (assert {
          (#"/home/work/workspace/education/acsl-exam/./max_max.c" 57 10 15#
          "expl:Pointer index bounds" true) }); _jessie_182 end));
          'Loop_5:
          loop
          invariant { (#"max_max.jc" 183 16 4025# true) }
            variant {
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 55 23 31#
              (Int.(-) (Uint32.to_int size_2) (Uint32.to_int !i))) }
           begin
           any unit
           requires { true } reads { a, int_xP_int_xM_max1_3,
           int_xP_int_xM_max2_4, max1, max2, size_2 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 53 25 135#
              (not
              (exists j_4 : int.
               (exists k_1 : int.
                (((<=) (0) j_4) /\
                (((<) j_4 (Uint32.to_int !i)) /\
                (((<=) (0) k_1) /\
                (((<) k_1 (Uint32.to_int !i)) /\
                (((<>) j_4 k_1) /\
                ((Int32.(>) (select intP_intM_a_2 (shift a j_4))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                ((Int32.(>) (select intP_intM_a_2 (shift a k_1))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                (Int32.(>) (select intP_intM_a_2 (shift a k_1))
                (select intP_intM_a_2 (shift a j_4))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 52 25 90#
              (exists j_3 : int.
               (((<=) (0) j_3) /\
               (((<) j_3 (Uint32.to_int !i)) /\
               ((Int32.(>=) (select intP_intM_a_2 (shift a j_3))
                (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
               /\
               (Int32.(=) (select intP_intM_a_2 (shift a j_3))
               (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 51 25 41#
              (Int32.(>=)
              (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
              (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 50 25 73#
              (forall j_2 : int.
               ((((<=) (0) j_2) /\ ((<) j_2 (Uint32.to_int !i))) ->
                (Int32.(<=) (select intP_intM_a_2 (shift a j_2))
                (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 49 25 39#
              ((<>) (select !int_xP_int_xM_max1_3 max1)
              (select !int_xP_int_xM_max2_4 max2)))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 48 25 74#
              (exists j_1 : int.
               (((<=) (0) j_1) /\
               (((<) j_1 (Uint32.to_int !i)) /\
               ((=) (shift a j_1) (select !int_xP_int_xM_max2_4 max2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 47 25 74#
              (exists j_0 : int.
               (((<=) (0) j_0) /\
               (((<) j_0 (Uint32.to_int !i)) /\
               ((=) (shift a j_0) (select !int_xP_int_xM_max1_3 max1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 39#
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 39#
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 31#
              ((<=) (2) (Uint32.to_int !i)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 30 39#
             (Uint32.(<=) !i size_2)))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 57 17 25#
             (Safe_uint32.(<)  !i size_2 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 58 13 26#
              (Safe_int32.(>) 
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 58 13 17#
               "expl:Pointer dereference"
               (acc_offset_typesafe  intP_a_2_alloc_table intP_intM_a_2 a
                (Safe_uint32.to_int  !i ) ))
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 58 20 26#
               "expl:Pointer dereference"
               (acc  intP_a_2_alloc_table intP_intM_a_2
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 58 21 26#
                "expl:Pointer dereference"
                (acc  int_xP_max1_3_alloc_table !int_xP_int_xM_max1_3 max1 ))
                )) ))
              then
               begin
               (let _jessie_189 =
               (let _jessie_188 =
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 59 20 25#
               "expl:Pointer dereference"
               (acc  int_xP_max1_3_alloc_table !int_xP_int_xM_max1_3 max1 ))
               in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 59 12 25#
               "expl:Pointer index bounds" true) }); _jessie_188 end) in
               (let _jessie_190 = max2 in
               (let _jessie_191 = (0) in
               (let _jessie_192 = _jessie_190 in
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 59 12 25#
               "expl:Pointer dereference"
               (upd  int_xP_max2_4_alloc_table int_xP_int_xM_max2_4
                _jessie_190 _jessie_189 ))))));
                (let _jessie_194 =
                (let _jessie_193 =
                (shift_typesafe  a (Safe_uint32.to_int  !i ) ) in
                begin
                (assert {
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 60 12 25#
                "expl:Pointer index bounds" true) }); _jessie_193 end) in
                (let _jessie_195 = max1 in
                (let _jessie_196 = (0) in
                (let _jessie_197 = _jessie_195 in
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 60 12 25#
                "expl:Pointer dereference"
                (upd  int_xP_max1_3_alloc_table int_xP_int_xM_max1_3
                 _jessie_195 _jessie_194 )))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 61 20 33#
               (Safe_int32.(>) 
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 61 20 24#
                "expl:Pointer dereference"
                (acc_offset_typesafe  intP_a_2_alloc_table intP_intM_a_2 a
                 (Safe_uint32.to_int  !i ) ))
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 61 27 33#
                "expl:Pointer dereference"
                (acc  intP_a_2_alloc_table intP_intM_a_2
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 61 28 33#
                 "expl:Pointer dereference"
                 (acc  int_xP_max2_4_alloc_table !int_xP_int_xM_max2_4 max2 ))
                 )) ))
               then
                (let _jessie_184 =
                (let _jessie_183 =
                (shift_typesafe  a (Safe_uint32.to_int  !i ) ) in
                begin
                (assert {
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 62 12 25#
                "expl:Pointer index bounds" true) }); _jessie_183 end) in
                (let _jessie_185 = max2 in
                (let _jessie_186 = (0) in
                (let _jessie_187 = _jessie_185 in
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 62 12 25#
                "expl:Pointer dereference"
                (upd  int_xP_max2_4_alloc_table int_xP_int_xM_max2_4
                 _jessie_185 _jessie_184 )))))) else ()));
              (i :=
               (let _jessie_198 =
               (Safe_uint32.(+)  !i
                (#"max_max.jc" 249 60 73# "expl:Integer cast"
                (Safe_uint32.of_int (1))) ) in
               begin
               (assert {
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 57 27 30#
               "expl:Pointer index bounds" true) }); _jessie_198 end)) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
         end end with Goto_while_0_break_exc _jessie_1 ->
        'While_0_break: 'While_0_break: () end else ())); (raise Return) end)));
     (raise Return) end with Return -> () end
  
end

module Function_max_max_behaviors

  use Unsafe_uint32 
  
  use Unsafe_int32 
  
  use enum.Uint32 
  
  use import Struct_intP 
  
  use import Root_int_xP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use why3.Bool.Bool 
  
  let max_max_ensures_default
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 28 5 59#
  "expl:Function max_max, default behavior" =
  fun
   (a : (pointer intP)) (size_2 : Uint32.t) (max1 : (pointer int_xP)) (max2 :
   (pointer int_xP)) (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer
   intP))) (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP)))
   (intP_a_2_alloc_table : (alloc_table intP)) (int_xP_max1_3_alloc_table :
   (alloc_table int_xP)) (int_xP_max2_4_alloc_table : (alloc_table int_xP))
   (intP_a_2_tag_table : (tag_table intP)) (intP_intM_a_2 : (memory intP
   Int32.t)) 
   requires {
   (((allocated intP_a_2_alloc_table a) ->
     (((=) (typeof intP_a_2_tag_table a) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_2_alloc_table a) i) /\
       ((<) i (offset_max intP_a_2_alloc_table a))) ->
       ((=) (typeof intP_a_2_tag_table (shift a i)) intP_tag)))))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 3 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_2) (1))) then
     (((<=) (offset_min intP_a_2_alloc_table a) (0)) /\
     (((>=) (offset_max intP_a_2_alloc_table a)
      (Int.(-) (Uint32.to_int size_2) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Uint32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 13 25#
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
    /\
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
    /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 29 41#
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
   /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))))))) }
   ensures { ("expl:Postcondition" ("expl:Ensures clause" true)) } diverges 
   ->
   'Init:
   try
    begin
    (check {
    (#"max_max.jc" 130 10 131# "expl:Behavior disjointness check"
    (not
    (((=) (Uint32.to_int size_2) (1)) /\ ((>) (Uint32.to_int size_2) (1)))))
    });
     (check {
     (#"max_max.jc" 133 10 132# "expl:Behavior disjointness check"
     (not
     (((=) (Uint32.to_int size_2) (0)) /\ ((=) (Uint32.to_int size_2) (1)))))
     });
     (check {
     (#"max_max.jc" 136 10 131# "expl:Behavior disjointness check"
     (not
     (((=) (Uint32.to_int size_2) (0)) /\ ((>) (Uint32.to_int size_2) (1)))))
     });
     (check {
     (#"max_max.jc" 139 10 192# "expl:Behavior completeness check"
     (((>) (Uint32.to_int size_2) (1)) \/
     (((=) (Uint32.to_int size_2) (1)) \/ ((=) (Uint32.to_int size_2) (0)))))
     });
     (let i = ref (Unsafe_uint32.any_  () ) in
     (let x = ref (Unsafe_uint32.any_  () ) in
     (let y = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 7 16#
     (Unsafe_uint32.(=)  size_2
      (#"max_max.jc" 149 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (1))) ))
     then
      begin
      (let _jessie_36 =
      (shift_  a
       (Unsafe_int32.to_int 
        (#"max_max.jc" 150 57 69# "expl:Integer cast"
        (Unsafe_int32.of_int (0))) ) ) in
      (let _jessie_37 = max1 in
      (let _jessie_38 = (0) in
      (let _jessie_39 = _jessie_37 in
      (upd  int_xP_int_xM_max1_3 _jessie_39 _jessie_36 )))));
       (let _jessie_41 =
       (shift_  a
        (Unsafe_int32.to_int 
         (#"max_max.jc" 151 57 69# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_42 = max2 in
       (let _jessie_43 = (0) in
       (let _jessie_44 = _jessie_42 in
       (upd  int_xP_int_xM_max2_4 _jessie_44 _jessie_41 ))))) end
     else
      (if
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 14 22#
      (Unsafe_uint32.(>)  size_2
       (#"max_max.jc" 152 36 49# "expl:Integer cast"
       (Unsafe_uint32.of_int (1))) ))
      then
       try
        begin
        begin
        (if
        (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 10 21#
        (Unsafe_int32.(>) 
         (acc  intP_intM_a_2
          (shift_  a
           (Unsafe_int32.to_int 
            (#"max_max.jc" 154 55 67# "expl:Integer cast"
            (Unsafe_int32.of_int (0))) ) ) )
         (acc  intP_intM_a_2
          (shift_  a
           (Unsafe_int32.to_int 
            (#"max_max.jc" 155 55 67# "expl:Integer cast"
            (Unsafe_int32.of_int (1))) ) ) ) ))
        then
         begin
         (x :=
          (#"max_max.jc" 156 35 48# "expl:Integer cast"
          (Unsafe_uint32.of_int (0))));
          begin
          (y :=
           (#"max_max.jc" 157 35 48# "expl:Integer cast"
           (Unsafe_uint32.of_int (1))));
           (if
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 33 38#
           (Unsafe_uint32.(<>)  !y
            (#"max_max.jc" 158 52 65# "expl:Integer cast"
            (Unsafe_uint32.of_int (0))) )) then () else ()) end end
        else
         begin
         (x :=
          (#"max_max.jc" 160 35 48# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          begin
          (y :=
           (#"max_max.jc" 161 35 48# "expl:Integer cast"
           (Unsafe_uint32.of_int (0))));
           (if
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 50 55#
           (Unsafe_uint32.(<>)  !y
            (#"max_max.jc" 162 52 65# "expl:Integer cast"
            (Unsafe_uint32.of_int (0))) )) then () else ()) end end);
         begin
         (assert {
         (#"/home/work/workspace/education/acsl-exam/./max_max.c" 40 20 32#
         "expl:Assertion in line 40"
         (Int32.(>=) (select intP_intM_a_2 (shift a (Uint32.to_int !x)))
         (select intP_intM_a_2 (shift a (Uint32.to_int !y))))) }); () end;
         begin
         (let _jessie_9 = (shift_  a (Unsafe_uint32.to_int  !x ) ) in
         (let _jessie_10 = max1 in
         (let _jessie_11 = (0) in
         (let _jessie_12 = _jessie_10 in
         (upd  int_xP_int_xM_max1_3 _jessie_12 _jessie_9 )))));
          begin
          (let _jessie_14 = (shift_  a (Unsafe_uint32.to_int  !y ) ) in
          (let _jessie_15 = max2 in
          (let _jessie_16 = (0) in
          (let _jessie_17 = _jessie_15 in
          (upd  int_xP_int_xM_max2_4 _jessie_17 _jessie_14 )))));
           begin
           (assert {
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 43 20 36#
           "expl:Assertion in line 43"
           (Int32.(>=)
           (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
           (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))) });
            () end end end end;
         begin
         (i :=
          (#"max_max.jc" 181 30 43# "expl:Integer cast"
          (Unsafe_uint32.of_int (2))));
          'Loop_1:
          loop
          invariant
            { (((#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 39#
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 39#
                ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 31#
                 ((<=) (2) (Uint32.to_int !i)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 30 39#
                (Uint32.(<=) !i size_2)))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 47 25 74#
                (exists j_0 : int.
                 (((<=) (0) j_0) /\
                 (((<) j_0 (Uint32.to_int !i)) /\
                 ((=) (shift a j_0) (select !int_xP_int_xM_max1_3 max1))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 48 25 74#
                (exists j_1 : int.
                 (((<=) (0) j_1) /\
                 (((<) j_1 (Uint32.to_int !i)) /\
                 ((=) (shift a j_1) (select !int_xP_int_xM_max2_4 max2))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 49 25 39#
                ((<>) (select !int_xP_int_xM_max1_3 max1)
                (select !int_xP_int_xM_max2_4 max2)))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 50 25 73#
                (forall j_2 : int.
                 ((((<=) (0) j_2) /\ ((<) j_2 (Uint32.to_int !i))) ->
                  (Int32.(<=) (select intP_intM_a_2 (shift a j_2))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 51 25 41#
                (Int32.(>=)
                (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
                (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
               &&
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 52 25 90#
                (exists j_3 : int.
                 (((<=) (0) j_3) /\
                 (((<) j_3 (Uint32.to_int !i)) /\
                 ((Int32.(>=) (select intP_intM_a_2 (shift a j_3))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                 /\
                 (Int32.(=) (select intP_intM_a_2 (shift a j_3))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
               &&
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 53 25 135#
               (not
               (exists j_4 : int.
                (exists k_1 : int.
                 (((<=) (0) j_4) /\
                 (((<) j_4 (Uint32.to_int !i)) /\
                 (((<=) (0) k_1) /\
                 (((<) k_1 (Uint32.to_int !i)) /\
                 (((<>) j_4 k_1) /\
                 ((Int32.(>) (select intP_intM_a_2 (shift a j_4))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                 /\
                 ((Int32.(>) (select intP_intM_a_2 (shift a k_1))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                 /\
                 (Int32.(>) (select intP_intM_a_2 (shift a k_1))
                 (select intP_intM_a_2 (shift a j_4)))))))))))))))))))))
              /\
              (#"max_max.jc" 183 16 4025#
              ((#"max_max.jc" 183 16 4025# "expl:Assigns clause"
               (not_assigns int_xP_max1_3_alloc_table
               int_xP_max1_3_alloc_table (at !int_xP_int_xM_max1_3 'Loop_1)
               !int_xP_int_xM_max1_3 (pset_singleton max1)))
              /\
              (#"max_max.jc" 183 16 4025# "expl:Assigns clause"
              (not_assigns int_xP_max2_4_alloc_table
              int_xP_max2_4_alloc_table (at !int_xP_int_xM_max2_4 'Loop_1)
              !int_xP_int_xM_max2_4 (pset_singleton max2)))))) } 
           begin
           any unit requires { true } ensures { true } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 57 17 25#
             (Unsafe_uint32.(<)  !i size_2 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 58 13 26#
              (Unsafe_int32.(>) 
               (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) ) )
               (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max1_3 max1 ) ) ))
              then
               begin
               (let _jessie_25 = (acc  !int_xP_int_xM_max1_3 max1 ) in
               (let _jessie_26 = max2 in
               (let _jessie_27 = (0) in
               (let _jessie_28 = _jessie_26 in
               (upd  int_xP_int_xM_max2_4 _jessie_28 _jessie_25 )))));
                (let _jessie_30 = (shift_  a (Unsafe_uint32.to_int  !i ) ) in
                (let _jessie_31 = max1 in
                (let _jessie_32 = (0) in
                (let _jessie_33 = _jessie_31 in
                (upd  int_xP_int_xM_max1_3 _jessie_33 _jessie_30 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 61 20 33#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) )
                 ) (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max2_4 max2 ) ) ))
               then
                (let _jessie_20 = (shift_  a (Unsafe_uint32.to_int  !i ) ) in
                (let _jessie_21 = max2 in
                (let _jessie_22 = (0) in
                (let _jessie_23 = _jessie_21 in
                (upd  int_xP_int_xM_max2_4 _jessie_23 _jessie_20 )))))
               else ()));
              (i :=
               (Unsafe_uint32.(+)  !i
                (#"max_max.jc" 249 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
         end end with Goto_while_0_break_exc _jessie_1 ->
        'While_0_break: 'While_0_break: () end else ())); (raise Return) end)));
     (raise Return) end with Return -> () end
  
  let max_max_ensures_one_size
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 28 5 59#
  "expl:Function max_max, behavior one_size" =
  fun
   (a : (pointer intP)) (size_2 : Uint32.t) (max1 : (pointer int_xP)) (max2 :
   (pointer int_xP)) (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer
   intP))) (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP)))
   (intP_a_2_alloc_table : (alloc_table intP)) (int_xP_max1_3_alloc_table :
   (alloc_table int_xP)) (int_xP_max2_4_alloc_table : (alloc_table int_xP))
   (intP_a_2_tag_table : (tag_table intP)) (intP_intM_a_2 : (memory intP
   Int32.t)) 
   requires {
   (((=) (Uint32.to_int size_2) (1)) /\
   (((allocated intP_a_2_alloc_table a) ->
     (((=) (typeof intP_a_2_tag_table a) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_2_alloc_table a) i) /\
       ((<) i (offset_max intP_a_2_alloc_table a))) ->
       ((=) (typeof intP_a_2_tag_table (shift a i)) intP_tag)))))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 3 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_2) (1))) then
     (((<=) (offset_min intP_a_2_alloc_table a) (0)) /\
     (((>=) (offset_max intP_a_2_alloc_table a)
      (Int.(-) (Uint32.to_int size_2) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Uint32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 13 25#
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
    /\
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
    /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 29 41#
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
   /\ (#"max_max.jc" 36 12 1250# ((=) true true))))))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"max_max.jc" 65 10 36# "expl:Assigns clause"
       (not_assigns int_xP_max1_3_alloc_table int_xP_max1_3_alloc_table (old
       !int_xP_int_xM_max1_3) !int_xP_int_xM_max1_3 (pset_singleton max1)))
      /\
      (#"max_max.jc" 65 10 36# "expl:Assigns clause"
      (not_assigns int_xP_max2_4_alloc_table int_xP_max2_4_alloc_table (old
      !int_xP_int_xM_max2_4) !int_xP_int_xM_max2_4 (pset_singleton max2))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
      "expl:Ensures clause"
      (Int32.(=) (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
      (select intP_intM_a_2 (shift a (0)))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 14 15 31#
      "expl:Ensures clause"
      (Int32.(=) (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
      (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 15 15 29#
     "expl:Ensures clause"
     ((=) (select !int_xP_int_xM_max1_3 max1)
     (select !int_xP_int_xM_max2_4 max2)))))))))) } diverges  ->
   'Init:
   try
    begin
    (); (); (); ();
     (let i = ref (Unsafe_uint32.any_  () ) in
     (let x = ref (Unsafe_uint32.any_  () ) in
     (let y = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 7 16#
     (Unsafe_uint32.(=)  size_2
      (#"max_max.jc" 149 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (1))) ))
     then
      begin
      (let _jessie_118 =
      (shift_  a
       (Unsafe_int32.to_int 
        (#"max_max.jc" 150 57 69# "expl:Integer cast"
        (Unsafe_int32.of_int (0))) ) ) in
      (let _jessie_119 = max1 in
      (let _jessie_120 = (0) in
      (let _jessie_121 = _jessie_119 in
      (upd  int_xP_int_xM_max1_3 _jessie_121 _jessie_118 )))));
       (let _jessie_123 =
       (shift_  a
        (Unsafe_int32.to_int 
         (#"max_max.jc" 151 57 69# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_124 = max2 in
       (let _jessie_125 = (0) in
       (let _jessie_126 = _jessie_124 in
       (upd  int_xP_int_xM_max2_4 _jessie_126 _jessie_123 ))))) end
     else
      (if
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 14 22#
      (Unsafe_uint32.(>)  size_2
       (#"max_max.jc" 152 36 49# "expl:Integer cast"
       (Unsafe_uint32.of_int (1))) ))
      then
       try
        begin
        begin
        (if
        (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 10 21#
        (Unsafe_int32.(>) 
         (acc  intP_intM_a_2
          (shift_  a
           (Unsafe_int32.to_int 
            (#"max_max.jc" 154 55 67# "expl:Integer cast"
            (Unsafe_int32.of_int (0))) ) ) )
         (acc  intP_intM_a_2
          (shift_  a
           (Unsafe_int32.to_int 
            (#"max_max.jc" 155 55 67# "expl:Integer cast"
            (Unsafe_int32.of_int (1))) ) ) ) ))
        then
         begin
         (x :=
          (#"max_max.jc" 156 35 48# "expl:Integer cast"
          (Unsafe_uint32.of_int (0))));
          begin
          (y :=
           (#"max_max.jc" 157 35 48# "expl:Integer cast"
           (Unsafe_uint32.of_int (1))));
           (if
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 33 38#
           (Unsafe_uint32.(<>)  !y
            (#"max_max.jc" 158 52 65# "expl:Integer cast"
            (Unsafe_uint32.of_int (0))) )) then () else ()) end end
        else
         begin
         (x :=
          (#"max_max.jc" 160 35 48# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          begin
          (y :=
           (#"max_max.jc" 161 35 48# "expl:Integer cast"
           (Unsafe_uint32.of_int (0))));
           (if
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 50 55#
           (Unsafe_uint32.(<>)  !y
            (#"max_max.jc" 162 52 65# "expl:Integer cast"
            (Unsafe_uint32.of_int (0))) )) then () else ()) end end);
         begin
         any unit
         requires { true } reads { a }
         ensures {
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 40 20 32#
           (Int32.(>=) (select intP_intM_a_2 (shift a (Uint32.to_int !x)))
           (select intP_intM_a_2 (shift a (Uint32.to_int !y))))) } ; () end;
         begin
         (let _jessie_91 = (shift_  a (Unsafe_uint32.to_int  !x ) ) in
         (let _jessie_92 = max1 in
         (let _jessie_93 = (0) in
         (let _jessie_94 = _jessie_92 in
         (upd  int_xP_int_xM_max1_3 _jessie_94 _jessie_91 )))));
          begin
          (let _jessie_96 = (shift_  a (Unsafe_uint32.to_int  !y ) ) in
          (let _jessie_97 = max2 in
          (let _jessie_98 = (0) in
          (let _jessie_99 = _jessie_97 in
          (upd  int_xP_int_xM_max2_4 _jessie_99 _jessie_96 )))));
           begin
           any unit
           requires { true } reads { int_xP_int_xM_max1_3,
           int_xP_int_xM_max2_4, max1, max2 }
           ensures {
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 43 20 36#
             (Int32.(>=)
             (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
             (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))) } ;
            () end end end end;
         begin
         (i :=
          (#"max_max.jc" 181 30 43# "expl:Integer cast"
          (Unsafe_uint32.of_int (2))));
          'Loop_3:
          loop
          invariant
            { (#"max_max.jc" 183 16 4025#
              ((#"max_max.jc" 65 10 36# "expl:Assigns clause"
               (not_assigns int_xP_max1_3_alloc_table
               int_xP_max1_3_alloc_table (at !int_xP_int_xM_max1_3 'Init)
               !int_xP_int_xM_max1_3 (pset_singleton max1)))
              /\
              (#"max_max.jc" 65 10 36# "expl:Assigns clause"
              (not_assigns int_xP_max2_4_alloc_table
              int_xP_max2_4_alloc_table (at !int_xP_int_xM_max2_4 'Init)
              !int_xP_int_xM_max2_4 (pset_singleton max2))))) } 
           begin
           any unit
           requires { true } reads { a, int_xP_int_xM_max1_3,
           int_xP_int_xM_max2_4, max1, max2, size_2 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 53 25 135#
              (not
              (exists j_4 : int.
               (exists k_1 : int.
                (((<=) (0) j_4) /\
                (((<) j_4 (Uint32.to_int !i)) /\
                (((<=) (0) k_1) /\
                (((<) k_1 (Uint32.to_int !i)) /\
                (((<>) j_4 k_1) /\
                ((Int32.(>) (select intP_intM_a_2 (shift a j_4))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                ((Int32.(>) (select intP_intM_a_2 (shift a k_1))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                (Int32.(>) (select intP_intM_a_2 (shift a k_1))
                (select intP_intM_a_2 (shift a j_4))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 52 25 90#
              (exists j_3 : int.
               (((<=) (0) j_3) /\
               (((<) j_3 (Uint32.to_int !i)) /\
               ((Int32.(>=) (select intP_intM_a_2 (shift a j_3))
                (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
               /\
               (Int32.(=) (select intP_intM_a_2 (shift a j_3))
               (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 51 25 41#
              (Int32.(>=)
              (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
              (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 50 25 73#
              (forall j_2 : int.
               ((((<=) (0) j_2) /\ ((<) j_2 (Uint32.to_int !i))) ->
                (Int32.(<=) (select intP_intM_a_2 (shift a j_2))
                (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 49 25 39#
              ((<>) (select !int_xP_int_xM_max1_3 max1)
              (select !int_xP_int_xM_max2_4 max2)))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 48 25 74#
              (exists j_1 : int.
               (((<=) (0) j_1) /\
               (((<) j_1 (Uint32.to_int !i)) /\
               ((=) (shift a j_1) (select !int_xP_int_xM_max2_4 max2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 47 25 74#
              (exists j_0 : int.
               (((<=) (0) j_0) /\
               (((<) j_0 (Uint32.to_int !i)) /\
               ((=) (shift a j_0) (select !int_xP_int_xM_max1_3 max1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 39#
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 39#
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 31#
              ((<=) (2) (Uint32.to_int !i)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 30 39#
             (Uint32.(<=) !i size_2)))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 57 17 25#
             (Unsafe_uint32.(<)  !i size_2 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 58 13 26#
              (Unsafe_int32.(>) 
               (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) ) )
               (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max1_3 max1 ) ) ))
              then
               begin
               (let _jessie_107 = (acc  !int_xP_int_xM_max1_3 max1 ) in
               (let _jessie_108 = max2 in
               (let _jessie_109 = (0) in
               (let _jessie_110 = _jessie_108 in
               (upd  int_xP_int_xM_max2_4 _jessie_110 _jessie_107 )))));
                (let _jessie_112 = (shift_  a (Unsafe_uint32.to_int  !i ) )
                in
                (let _jessie_113 = max1 in
                (let _jessie_114 = (0) in
                (let _jessie_115 = _jessie_113 in
                (upd  int_xP_int_xM_max1_3 _jessie_115 _jessie_112 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 61 20 33#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) )
                 ) (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max2_4 max2 ) ) ))
               then
                (let _jessie_102 = (shift_  a (Unsafe_uint32.to_int  !i ) )
                in
                (let _jessie_103 = max2 in
                (let _jessie_104 = (0) in
                (let _jessie_105 = _jessie_103 in
                (upd  int_xP_int_xM_max2_4 _jessie_105 _jessie_102 )))))
               else ()));
              (i :=
               (Unsafe_uint32.(+)  !i
                (#"max_max.jc" 249 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
         end end with Goto_while_0_break_exc _jessie_1 ->
        'While_0_break: 'While_0_break: () end else ())); (raise Return) end)));
     (raise Return) end with Return -> () end
  
  let max_max_ensures_size
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 28 5 59#
  "expl:Function max_max, behavior size" =
  fun
   (a : (pointer intP)) (size_2 : Uint32.t) (max1 : (pointer int_xP)) (max2 :
   (pointer int_xP)) (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer
   intP))) (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP)))
   (intP_a_2_alloc_table : (alloc_table intP)) (int_xP_max1_3_alloc_table :
   (alloc_table int_xP)) (int_xP_max2_4_alloc_table : (alloc_table int_xP))
   (intP_a_2_tag_table : (tag_table intP)) (intP_intM_a_2 : (memory intP
   Int32.t)) 
   requires {
   (((>) (Uint32.to_int size_2) (1)) /\
   (((allocated intP_a_2_alloc_table a) ->
     (((=) (typeof intP_a_2_tag_table a) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_2_alloc_table a) i) /\
       ((<) i (offset_max intP_a_2_alloc_table a))) ->
       ((=) (typeof intP_a_2_tag_table (shift a i)) intP_tag)))))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 3 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_2) (1))) then
     (((<=) (offset_min intP_a_2_alloc_table a) (0)) /\
     (((>=) (offset_max intP_a_2_alloc_table a)
      (Int.(-) (Uint32.to_int size_2) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Uint32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 13 25#
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
    /\
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
    /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 29 41#
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
   /\ (#"max_max.jc" 36 12 1250# ((=) true true))))))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"max_max.jc" 75 10 36# "expl:Assigns clause"
       (not_assigns int_xP_max1_3_alloc_table int_xP_max1_3_alloc_table (old
       !int_xP_int_xM_max1_3) !int_xP_int_xM_max1_3 (pset_singleton max1)))
      /\
      (#"max_max.jc" 75 10 36# "expl:Assigns clause"
      (not_assigns int_xP_max2_4_alloc_table int_xP_max2_4_alloc_table (old
      !int_xP_int_xM_max2_4) !int_xP_int_xM_max2_4 (pset_singleton max2))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 27#
      "expl:Ensures clause"
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
       "expl:Ensures clause"
       ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
       "expl:Ensures clause"
       ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
      "expl:Ensures clause" ((=) true true)))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 31 43#
      "expl:Ensures clause"
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
       "expl:Ensures clause"
       ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
      "expl:Ensures clause"
      ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
       "expl:Ensures clause"
       ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
      /\
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
      "expl:Ensures clause" ((=) true true)))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 20 15 117#
      "expl:Ensures clause"
      (exists i_1 : int.
       (exists j_5 : int.
        (((<=) (0) i_1) /\
        (((<) i_1 (Uint32.to_int size_2)) /\
        (((<=) (0) j_5) /\
        (((<) j_5 (Uint32.to_int size_2)) /\
        (((<>) i_1 j_5) /\
        (((=) (shift a i_1) (select !int_xP_int_xM_max1_3 max1)) /\
        ((=) (shift a j_5) (select !int_xP_int_xM_max2_4 max2)))))))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 21 15 31#
      "expl:Ensures clause"
      (Int32.(>=) (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
      (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 22 15 66#
      "expl:Ensures clause"
      (forall i_2 : int.
       ((((<=) (0) i_2) /\ ((<) i_2 (Uint32.to_int size_2))) ->
        (Int32.(<=) (select intP_intM_a_2 (shift a i_2))
        (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 23 15 83#
      "expl:Ensures clause"
      (exists i_3 : int.
       (((<=) (0) i_3) /\
       (((<) i_3 (Uint32.to_int size_2)) /\
       ((Int32.(>=) (select intP_intM_a_2 (shift a i_3))
        (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
       /\
       (Int32.(=) (select intP_intM_a_2 (shift a i_3))
       (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 24 15 131#
     "expl:Ensures clause"
     (not
     (exists i_4 : int.
      (exists j_6 : int.
       (((<=) (0) i_4) /\
       (((<) i_4 (Uint32.to_int size_2)) /\
       (((<=) (0) j_6) /\
       (((<) j_6 (Uint32.to_int size_2)) /\
       (((<>) i_4 j_6) /\
       ((Int32.(>) (select intP_intM_a_2 (shift a i_4))
        (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
       /\
       ((Int32.(>) (select intP_intM_a_2 (shift a j_6))
        (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
       /\
       (Int32.(>) (select intP_intM_a_2 (shift a i_4))
       (select intP_intM_a_2 (shift a j_6))))))))))))))))))))))))))))) }
   diverges  ->
   'Init:
   try
    begin
    (); (); (); ();
     (let i = ref (Unsafe_uint32.any_  () ) in
     (let x = ref (Unsafe_uint32.any_  () ) in
     (let y = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 7 16#
     (Unsafe_uint32.(=)  size_2
      (#"max_max.jc" 149 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (1))) ))
     then
      begin
      (let _jessie_159 =
      (shift_  a
       (Unsafe_int32.to_int 
        (#"max_max.jc" 150 57 69# "expl:Integer cast"
        (Unsafe_int32.of_int (0))) ) ) in
      (let _jessie_160 = max1 in
      (let _jessie_161 = (0) in
      (let _jessie_162 = _jessie_160 in
      (upd  int_xP_int_xM_max1_3 _jessie_162 _jessie_159 )))));
       (let _jessie_164 =
       (shift_  a
        (Unsafe_int32.to_int 
         (#"max_max.jc" 151 57 69# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_165 = max2 in
       (let _jessie_166 = (0) in
       (let _jessie_167 = _jessie_165 in
       (upd  int_xP_int_xM_max2_4 _jessie_167 _jessie_164 ))))) end
     else
      (if
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 14 22#
      (Unsafe_uint32.(>)  size_2
       (#"max_max.jc" 152 36 49# "expl:Integer cast"
       (Unsafe_uint32.of_int (1))) ))
      then
       try
        begin
        begin
        (if
        (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 10 21#
        (Unsafe_int32.(>) 
         (acc  intP_intM_a_2
          (shift_  a
           (Unsafe_int32.to_int 
            (#"max_max.jc" 154 55 67# "expl:Integer cast"
            (Unsafe_int32.of_int (0))) ) ) )
         (acc  intP_intM_a_2
          (shift_  a
           (Unsafe_int32.to_int 
            (#"max_max.jc" 155 55 67# "expl:Integer cast"
            (Unsafe_int32.of_int (1))) ) ) ) ))
        then
         begin
         (x :=
          (#"max_max.jc" 156 35 48# "expl:Integer cast"
          (Unsafe_uint32.of_int (0))));
          begin
          (y :=
           (#"max_max.jc" 157 35 48# "expl:Integer cast"
           (Unsafe_uint32.of_int (1))));
           (if
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 33 38#
           (Unsafe_uint32.(<>)  !y
            (#"max_max.jc" 158 52 65# "expl:Integer cast"
            (Unsafe_uint32.of_int (0))) )) then () else ()) end end
        else
         begin
         (x :=
          (#"max_max.jc" 160 35 48# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          begin
          (y :=
           (#"max_max.jc" 161 35 48# "expl:Integer cast"
           (Unsafe_uint32.of_int (0))));
           (if
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 50 55#
           (Unsafe_uint32.(<>)  !y
            (#"max_max.jc" 162 52 65# "expl:Integer cast"
            (Unsafe_uint32.of_int (0))) )) then () else ()) end end);
         begin
         any unit
         requires { true } reads { a }
         ensures {
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 40 20 32#
           (Int32.(>=) (select intP_intM_a_2 (shift a (Uint32.to_int !x)))
           (select intP_intM_a_2 (shift a (Uint32.to_int !y))))) } ; () end;
         begin
         (let _jessie_132 = (shift_  a (Unsafe_uint32.to_int  !x ) ) in
         (let _jessie_133 = max1 in
         (let _jessie_134 = (0) in
         (let _jessie_135 = _jessie_133 in
         (upd  int_xP_int_xM_max1_3 _jessie_135 _jessie_132 )))));
          begin
          (let _jessie_137 = (shift_  a (Unsafe_uint32.to_int  !y ) ) in
          (let _jessie_138 = max2 in
          (let _jessie_139 = (0) in
          (let _jessie_140 = _jessie_138 in
          (upd  int_xP_int_xM_max2_4 _jessie_140 _jessie_137 )))));
           begin
           any unit
           requires { true } reads { int_xP_int_xM_max1_3,
           int_xP_int_xM_max2_4, max1, max2 }
           ensures {
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 43 20 36#
             (Int32.(>=)
             (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
             (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))) } ;
            () end end end end;
         begin
         (i :=
          (#"max_max.jc" 181 30 43# "expl:Integer cast"
          (Unsafe_uint32.of_int (2))));
          'Loop_4:
          loop
          invariant
            { (#"max_max.jc" 183 16 4025#
              ((#"max_max.jc" 75 10 36# "expl:Assigns clause"
               (not_assigns int_xP_max1_3_alloc_table
               int_xP_max1_3_alloc_table (at !int_xP_int_xM_max1_3 'Init)
               !int_xP_int_xM_max1_3 (pset_singleton max1)))
              /\
              (#"max_max.jc" 75 10 36# "expl:Assigns clause"
              (not_assigns int_xP_max2_4_alloc_table
              int_xP_max2_4_alloc_table (at !int_xP_int_xM_max2_4 'Init)
              !int_xP_int_xM_max2_4 (pset_singleton max2))))) } 
           begin
           any unit
           requires { true } reads { a, int_xP_int_xM_max1_3,
           int_xP_int_xM_max2_4, max1, max2, size_2 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 53 25 135#
              (not
              (exists j_4 : int.
               (exists k_1 : int.
                (((<=) (0) j_4) /\
                (((<) j_4 (Uint32.to_int !i)) /\
                (((<=) (0) k_1) /\
                (((<) k_1 (Uint32.to_int !i)) /\
                (((<>) j_4 k_1) /\
                ((Int32.(>) (select intP_intM_a_2 (shift a j_4))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                ((Int32.(>) (select intP_intM_a_2 (shift a k_1))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                (Int32.(>) (select intP_intM_a_2 (shift a k_1))
                (select intP_intM_a_2 (shift a j_4))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 52 25 90#
              (exists j_3 : int.
               (((<=) (0) j_3) /\
               (((<) j_3 (Uint32.to_int !i)) /\
               ((Int32.(>=) (select intP_intM_a_2 (shift a j_3))
                (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
               /\
               (Int32.(=) (select intP_intM_a_2 (shift a j_3))
               (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 51 25 41#
              (Int32.(>=)
              (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
              (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 50 25 73#
              (forall j_2 : int.
               ((((<=) (0) j_2) /\ ((<) j_2 (Uint32.to_int !i))) ->
                (Int32.(<=) (select intP_intM_a_2 (shift a j_2))
                (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 49 25 39#
              ((<>) (select !int_xP_int_xM_max1_3 max1)
              (select !int_xP_int_xM_max2_4 max2)))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 48 25 74#
              (exists j_1 : int.
               (((<=) (0) j_1) /\
               (((<) j_1 (Uint32.to_int !i)) /\
               ((=) (shift a j_1) (select !int_xP_int_xM_max2_4 max2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 47 25 74#
              (exists j_0 : int.
               (((<=) (0) j_0) /\
               (((<) j_0 (Uint32.to_int !i)) /\
               ((=) (shift a j_0) (select !int_xP_int_xM_max1_3 max1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 39#
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 39#
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 31#
              ((<=) (2) (Uint32.to_int !i)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 30 39#
             (Uint32.(<=) !i size_2)))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 57 17 25#
             (Unsafe_uint32.(<)  !i size_2 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 58 13 26#
              (Unsafe_int32.(>) 
               (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) ) )
               (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max1_3 max1 ) ) ))
              then
               begin
               (let _jessie_148 = (acc  !int_xP_int_xM_max1_3 max1 ) in
               (let _jessie_149 = max2 in
               (let _jessie_150 = (0) in
               (let _jessie_151 = _jessie_149 in
               (upd  int_xP_int_xM_max2_4 _jessie_151 _jessie_148 )))));
                (let _jessie_153 = (shift_  a (Unsafe_uint32.to_int  !i ) )
                in
                (let _jessie_154 = max1 in
                (let _jessie_155 = (0) in
                (let _jessie_156 = _jessie_154 in
                (upd  int_xP_int_xM_max1_3 _jessie_156 _jessie_153 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 61 20 33#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) )
                 ) (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max2_4 max2 ) ) ))
               then
                (let _jessie_143 = (shift_  a (Unsafe_uint32.to_int  !i ) )
                in
                (let _jessie_144 = max2 in
                (let _jessie_145 = (0) in
                (let _jessie_146 = _jessie_144 in
                (upd  int_xP_int_xM_max2_4 _jessie_146 _jessie_143 )))))
               else ()));
              (i :=
               (Unsafe_uint32.(+)  !i
                (#"max_max.jc" 249 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
         end end with Goto_while_0_break_exc _jessie_1 ->
        'While_0_break: 'While_0_break: () end else ())); (raise Return) end)));
     (raise Return) end with Return -> () end
  
  let max_max_ensures_zero_size
  #"/home/work/workspace/education/acsl-exam/./max_max.c" 28 5 59#
  "expl:Function max_max, behavior zero_size" =
  fun
   (a : (pointer intP)) (size_2 : Uint32.t) (max1 : (pointer int_xP)) (max2 :
   (pointer int_xP)) (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer
   intP))) (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP)))
   (intP_a_2_alloc_table : (alloc_table intP)) (int_xP_max1_3_alloc_table :
   (alloc_table int_xP)) (int_xP_max2_4_alloc_table : (alloc_table int_xP))
   (intP_a_2_tag_table : (tag_table intP)) (intP_intM_a_2 : (memory intP
   Int32.t)) 
   requires {
   (((=) (Uint32.to_int size_2) (0)) /\
   (((allocated intP_a_2_alloc_table a) ->
     (((=) (typeof intP_a_2_tag_table a) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_2_alloc_table a) i) /\
       ((<) i (offset_max intP_a_2_alloc_table a))) ->
       ((=) (typeof intP_a_2_tag_table (shift a i)) intP_tag)))))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 3 13 34#
    (if ((<=) (0) (Int.(-) (Uint32.to_int size_2) (1))) then
     (((<=) (offset_min intP_a_2_alloc_table a) (0)) /\
     (((>=) (offset_max intP_a_2_alloc_table a)
      (Int.(-) (Uint32.to_int size_2) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Uint32.to_int size_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 13 25#
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
    /\
    (#"max_max.jc" 36 12 1250#
    ((#"max_max.jc" 36 12 1250#
     ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
    /\ (#"max_max.jc" 36 12 1250# ((=) true true)))))))
   /\
   (#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 29 41#
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
   /\
   (#"max_max.jc" 36 12 1250#
   ((#"max_max.jc" 36 12 1250#
    ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
   /\ (#"max_max.jc" 36 12 1250# ((=) true true))))))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"max_max.jc" 60 10 18# "expl:Assigns clause"
       (not_assigns int_xP_max1_3_alloc_table int_xP_max1_3_alloc_table (old
       !int_xP_int_xM_max1_3) !int_xP_int_xM_max1_3 pset_empty))
      /\
      (#"max_max.jc" 60 10 18# "expl:Assigns clause"
      (not_assigns int_xP_max2_4_alloc_table int_xP_max2_4_alloc_table (old
      !int_xP_int_xM_max2_4) !int_xP_int_xM_max2_4 pset_empty)))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 8 15 33#
     "expl:Ensures clause"
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 8 15 33#
     "expl:Ensures clause"
     ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 8 15 33#
      "expl:Ensures clause" ((=) max1 max1))
     /\
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 9 15 33#
     "expl:Ensures clause" ((=) max2 max2))))))) } diverges  ->
   'Init:
   try
    begin
    (); (); (); ();
     (let i = ref (Unsafe_uint32.any_  () ) in
     (let x = ref (Unsafe_uint32.any_  () ) in
     (let y = ref (Unsafe_uint32.any_  () ) in
     begin
     (if
     (#"/home/work/workspace/education/acsl-exam/./max_max.c" 31 7 16#
     (Unsafe_uint32.(=)  size_2
      (#"max_max.jc" 149 30 43# "expl:Integer cast"
      (Unsafe_uint32.of_int (1))) ))
     then
      begin
      (let _jessie_77 =
      (shift_  a
       (Unsafe_int32.to_int 
        (#"max_max.jc" 150 57 69# "expl:Integer cast"
        (Unsafe_int32.of_int (0))) ) ) in
      (let _jessie_78 = max1 in
      (let _jessie_79 = (0) in
      (let _jessie_80 = _jessie_78 in
      (upd  int_xP_int_xM_max1_3 _jessie_80 _jessie_77 )))));
       (let _jessie_82 =
       (shift_  a
        (Unsafe_int32.to_int 
         (#"max_max.jc" 151 57 69# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) in
       (let _jessie_83 = max2 in
       (let _jessie_84 = (0) in
       (let _jessie_85 = _jessie_83 in
       (upd  int_xP_int_xM_max2_4 _jessie_85 _jessie_82 ))))) end
     else
      (if
      (#"/home/work/workspace/education/acsl-exam/./max_max.c" 34 14 22#
      (Unsafe_uint32.(>)  size_2
       (#"max_max.jc" 152 36 49# "expl:Integer cast"
       (Unsafe_uint32.of_int (1))) ))
      then
       try
        begin
        begin
        (if
        (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 10 21#
        (Unsafe_int32.(>) 
         (acc  intP_intM_a_2
          (shift_  a
           (Unsafe_int32.to_int 
            (#"max_max.jc" 154 55 67# "expl:Integer cast"
            (Unsafe_int32.of_int (0))) ) ) )
         (acc  intP_intM_a_2
          (shift_  a
           (Unsafe_int32.to_int 
            (#"max_max.jc" 155 55 67# "expl:Integer cast"
            (Unsafe_int32.of_int (1))) ) ) ) ))
        then
         begin
         (x :=
          (#"max_max.jc" 156 35 48# "expl:Integer cast"
          (Unsafe_uint32.of_int (0))));
          begin
          (y :=
           (#"max_max.jc" 157 35 48# "expl:Integer cast"
           (Unsafe_uint32.of_int (1))));
           (if
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 33 38#
           (Unsafe_uint32.(<>)  !y
            (#"max_max.jc" 158 52 65# "expl:Integer cast"
            (Unsafe_uint32.of_int (0))) )) then () else ()) end end
        else
         begin
         (x :=
          (#"max_max.jc" 160 35 48# "expl:Integer cast"
          (Unsafe_uint32.of_int (1))));
          begin
          (y :=
           (#"max_max.jc" 161 35 48# "expl:Integer cast"
           (Unsafe_uint32.of_int (0))));
           (if
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 39 50 55#
           (Unsafe_uint32.(<>)  !y
            (#"max_max.jc" 162 52 65# "expl:Integer cast"
            (Unsafe_uint32.of_int (0))) )) then () else ()) end end);
         begin
         any unit
         requires { true } reads { a }
         ensures {
           (#"/home/work/workspace/education/acsl-exam/./max_max.c" 40 20 32#
           (Int32.(>=) (select intP_intM_a_2 (shift a (Uint32.to_int !x)))
           (select intP_intM_a_2 (shift a (Uint32.to_int !y))))) } ; () end;
         begin
         (let _jessie_50 = (shift_  a (Unsafe_uint32.to_int  !x ) ) in
         (let _jessie_51 = max1 in
         (let _jessie_52 = (0) in
         (let _jessie_53 = _jessie_51 in
         (upd  int_xP_int_xM_max1_3 _jessie_53 _jessie_50 )))));
          begin
          (let _jessie_55 = (shift_  a (Unsafe_uint32.to_int  !y ) ) in
          (let _jessie_56 = max2 in
          (let _jessie_57 = (0) in
          (let _jessie_58 = _jessie_56 in
          (upd  int_xP_int_xM_max2_4 _jessie_58 _jessie_55 )))));
           begin
           any unit
           requires { true } reads { int_xP_int_xM_max1_3,
           int_xP_int_xM_max2_4, max1, max2 }
           ensures {
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 43 20 36#
             (Int32.(>=)
             (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
             (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))) } ;
            () end end end end;
         begin
         (i :=
          (#"max_max.jc" 181 30 43# "expl:Integer cast"
          (Unsafe_uint32.of_int (2))));
          'Loop_2:
          loop
          invariant
            { (#"max_max.jc" 183 16 4025#
              ((#"max_max.jc" 60 10 18# "expl:Assigns clause"
               (not_assigns int_xP_max1_3_alloc_table
               int_xP_max1_3_alloc_table (at !int_xP_int_xM_max1_3 'Init)
               !int_xP_int_xM_max1_3 pset_empty))
              /\
              (#"max_max.jc" 60 10 18# "expl:Assigns clause"
              (not_assigns int_xP_max2_4_alloc_table
              int_xP_max2_4_alloc_table (at !int_xP_int_xM_max2_4 'Init)
              !int_xP_int_xM_max2_4 pset_empty)))) } 
           begin
           any unit
           requires { true } reads { a, int_xP_int_xM_max1_3,
           int_xP_int_xM_max2_4, max1, max2, size_2 }
           ensures {
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 53 25 135#
              (not
              (exists j_4 : int.
               (exists k_1 : int.
                (((<=) (0) j_4) /\
                (((<) j_4 (Uint32.to_int !i)) /\
                (((<=) (0) k_1) /\
                (((<) k_1 (Uint32.to_int !i)) /\
                (((<>) j_4 k_1) /\
                ((Int32.(>) (select intP_intM_a_2 (shift a j_4))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                ((Int32.(>) (select intP_intM_a_2 (shift a k_1))
                 (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
                /\
                (Int32.(>) (select intP_intM_a_2 (shift a k_1))
                (select intP_intM_a_2 (shift a j_4))))))))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 52 25 90#
              (exists j_3 : int.
               (((<=) (0) j_3) /\
               (((<) j_3 (Uint32.to_int !i)) /\
               ((Int32.(>=) (select intP_intM_a_2 (shift a j_3))
                (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2)))
               /\
               (Int32.(=) (select intP_intM_a_2 (shift a j_3))
               (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 51 25 41#
              (Int32.(>=)
              (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
              (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 50 25 73#
              (forall j_2 : int.
               ((((<=) (0) j_2) /\ ((<) j_2 (Uint32.to_int !i))) ->
                (Int32.(<=) (select intP_intM_a_2 (shift a j_2))
                (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 49 25 39#
              ((<>) (select !int_xP_int_xM_max1_3 max1)
              (select !int_xP_int_xM_max2_4 max2)))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 48 25 74#
              (exists j_1 : int.
               (((<=) (0) j_1) /\
               (((<) j_1 (Uint32.to_int !i)) /\
               ((=) (shift a j_1) (select !int_xP_int_xM_max2_4 max2))))))
             /\
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 47 25 74#
              (exists j_0 : int.
               (((<=) (0) j_0) /\
               (((<) j_0 (Uint32.to_int !i)) /\
               ((=) (shift a j_0) (select !int_xP_int_xM_max1_3 max1))))))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 39#
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 39#
             ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 25 31#
              ((<=) (2) (Uint32.to_int !i)))
             /\
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 46 30 39#
             (Uint32.(<=) !i size_2)))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workspace/education/acsl-exam/./max_max.c" 57 17 25#
             (Unsafe_uint32.(<)  !i size_2 )) then ()
             else (raise (Goto_while_0_break_exc ())));
              (if
              (#"/home/work/workspace/education/acsl-exam/./max_max.c" 58 13 26#
              (Unsafe_int32.(>) 
               (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) ) )
               (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max1_3 max1 ) ) ))
              then
               begin
               (let _jessie_66 = (acc  !int_xP_int_xM_max1_3 max1 ) in
               (let _jessie_67 = max2 in
               (let _jessie_68 = (0) in
               (let _jessie_69 = _jessie_67 in
               (upd  int_xP_int_xM_max2_4 _jessie_69 _jessie_66 )))));
                (let _jessie_71 = (shift_  a (Unsafe_uint32.to_int  !i ) ) in
                (let _jessie_72 = max1 in
                (let _jessie_73 = (0) in
                (let _jessie_74 = _jessie_72 in
                (upd  int_xP_int_xM_max1_3 _jessie_74 _jessie_71 ))))) end
              else
               (if
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 61 20 33#
               (Unsafe_int32.(>) 
                (acc  intP_intM_a_2 (shift_  a (Unsafe_uint32.to_int  !i ) )
                 ) (acc  intP_intM_a_2 (acc  !int_xP_int_xM_max2_4 max2 ) ) ))
               then
                (let _jessie_61 = (shift_  a (Unsafe_uint32.to_int  !i ) ) in
                (let _jessie_62 = max2 in
                (let _jessie_63 = (0) in
                (let _jessie_64 = _jessie_62 in
                (upd  int_xP_int_xM_max2_4 _jessie_64 _jessie_61 )))))
               else ()));
              (i :=
               (Unsafe_uint32.(+)  !i
                (#"max_max.jc" 249 60 73# "expl:Integer cast"
                (Unsafe_uint32.of_int (1))) )) end;
              (raise (Loop_continue_exc ())) end with Loop_continue_exc
             _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
         end end with Goto_while_0_break_exc _jessie_1 ->
        'While_0_break: 'While_0_break: () end else ())); (raise Return) end)));
     (raise Return) end with Return -> () end
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_voidP

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP)) = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_charP

  use import Struct_voidP 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

module Struct_intP_unsafe

  use import Struct_intP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_intP
  (p : (pointer intP)) 
   (intP_alloc_table : ref (alloc_table intP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !intP_alloc_table p))
      }
    writes { intP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !intP_alloc_table (old !intP_alloc_table))) \/
      ((frame_free_struct_intP p (old !intP_alloc_table) !intP_alloc_table)
      /\ (fresh_alloc_struct_intP p !intP_alloc_table))) }
  
  val allocate_struct_intP_requires
  (n : int) 
   (intP_alloc_table : ref (alloc_table intP)) 
    (intP_tag_table : ref (tag_table intP)) : (pointer intP)
     requires { ((>=) n (0)) } writes { intP_alloc_table, intP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !intP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !intP_alloc_table)
        !intP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (old !intP_alloc_table)) /\
       ((fresh_tag_struct_intP result (old !intP_tag_table)) /\
       ((typeof_struct_intP result (0) n !intP_tag_table) /\
       (container_of_struct_intP result (0) n !intP_tag_table))))))) }
  
end

module Struct_intP_safe

  use import Struct_intP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_intP
  (p : (pointer intP)) 
   (intP_alloc_table : ref (alloc_table intP)) : unit
    requires { true } writes { intP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !intP_alloc_table (old !intP_alloc_table))) \/
      ((frame_free_struct_intP p (old !intP_alloc_table) !intP_alloc_table)
      /\ (fresh_alloc_struct_intP p !intP_alloc_table))) }
  
  val allocate_struct_intP
  (n : int) 
   (intP_alloc_table : ref (alloc_table intP)) 
    (intP_tag_table : ref (tag_table intP)) : (pointer intP)
     requires { true } writes { intP_alloc_table, intP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !intP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !intP_alloc_table)
        !intP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (old !intP_alloc_table)) /\
       ((fresh_tag_struct_intP result (old !intP_tag_table)) /\
       ((typeof_struct_intP result (0) n !intP_tag_table) /\
       (container_of_struct_intP result (0) n !intP_tag_table))))))) }
  
  val allocate_singleton_struct_intP
  (intP_alloc_table : ref (alloc_table intP)) 
   (intP_tag_table : ref (tag_table intP)) : (pointer intP)
    requires { true } writes { intP_alloc_table, intP_tag_table }
    ensures {
      ((strict_valid_struct_intP result (0) (0) !intP_alloc_table) /\
      ((frame_alloc_struct_intP result (1) (old !intP_alloc_table)
       !intP_alloc_table)
      /\
      ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
      /\
      ((fresh_alloc_struct_intP result (old !intP_alloc_table)) /\
      ((fresh_tag_struct_intP result (old !intP_tag_table)) /\
      ((typeof_singleton_struct_intP result !intP_tag_table) /\
      (container_of_singleton_struct_intP result !intP_tag_table))))))) }
  
end

theory Struct_int_xP

  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function int_xP_tag  : (tag_id int_xP)
  
  axiom Int_xP_parenttag_bottom :
  (parenttag int_xP_tag bottom_tag)
  
  axiom Int_xP_is_final :
  (forall int_xP_tag_table : (tag_table int_xP).
   (forall p : (pointer int_xP).
    ((instanceof int_xP_tag_table p int_xP_tag) ->
     ((=) (typeof int_xP_tag_table p) int_xP_tag))))
  
  predicate frame_tag_struct_int_xP (p : (pointer int_xP))
  (old_int_xP_tag_table : (tag_table int_xP)) (int_xP_tag_table : (tag_table
  int_xP))
  =
     ((tag_extends old_int_xP_tag_table int_xP_tag_table) /\
     (alloc_tag_block old_int_xP_tag_table int_xP_tag_table p))
  
  predicate frame_free_struct_int_xP (p : (pointer int_xP))
  (old_int_xP_alloc_table : (alloc_table int_xP)) (int_xP_alloc_table :
  (alloc_table int_xP))
  =
     ((free_extends old_int_xP_alloc_table int_xP_alloc_table) /\
     (free_block old_int_xP_alloc_table int_xP_alloc_table p))
  
  predicate frame_alloc_struct_int_xP (p : (pointer int_xP)) (n : int)
  (old_int_xP_alloc_table : (alloc_table int_xP)) (int_xP_alloc_table :
  (alloc_table int_xP))
  =
     ((alloc_extends old_int_xP_alloc_table int_xP_alloc_table) /\
     (alloc_block old_int_xP_alloc_table int_xP_alloc_table p n))
  
  predicate fresh_tag_struct_int_xP (p : (pointer int_xP)) (int_xP_tag_table
  : (tag_table int_xP)) = (tag_fresh int_xP_tag_table p)
  
  predicate fresh_alloc_struct_int_xP (p : (pointer int_xP))
  (int_xP_alloc_table : (alloc_table int_xP))
  = (alloc_fresh int_xP_alloc_table p)
  
  predicate container_of_singleton_struct_int_xP (p : (pointer int_xP))
  (int_xP_tag_table : (tag_table int_xP)) = true
  
  predicate container_of_struct_int_xP (p : (pointer int_xP)) (l : int) (r :
  int) (int_xP_tag_table : (tag_table int_xP)) = true
  
  predicate typeof_singleton_struct_int_xP (p : (pointer int_xP))
  (int_xP_tag_table : (tag_table int_xP))
  = ((=) (typeof int_xP_tag_table p) int_xP_tag)
  
  predicate typeof_struct_int_xP (p : (pointer int_xP)) (l : int) (r : int)
  (int_xP_tag_table : (tag_table int_xP))
  =
     (((=) (typeof int_xP_tag_table p) int_xP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof int_xP_tag_table (shift p i)) int_xP_tag))))
  
  predicate instanceof_singleton_struct_int_xP (p : (pointer int_xP))
  (int_xP_tag_table : (tag_table int_xP))
  = (instanceof int_xP_tag_table p int_xP_tag)
  
  predicate instanceof_struct_int_xP (p : (pointer int_xP)) (l : int) (r :
  int) (int_xP_tag_table : (tag_table int_xP))
  =
     ((instanceof int_xP_tag_table p int_xP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof int_xP_tag_table (shift p i) int_xP_tag))))
  
  predicate right_valid_struct_int_xP (p : (pointer int_xP)) (b : int)
  (int_xP_alloc_table : (alloc_table int_xP))
  = ((>=) (offset_max int_xP_alloc_table p) b)
  
  predicate left_valid_struct_int_xP (p : (pointer int_xP)) (a : int)
  (int_xP_alloc_table : (alloc_table int_xP))
  = ((<=) (offset_min int_xP_alloc_table p) a)
  
  predicate valid_struct_int_xP (p : (pointer int_xP)) (a : int) (b : int)
  (int_xP_alloc_table : (alloc_table int_xP))
  =
     (((<=) (offset_min int_xP_alloc_table p) a) /\
     ((>=) (offset_max int_xP_alloc_table p) b))
  
  predicate strict_valid_struct_int_xP (p : (pointer int_xP)) (a : int) (b :
  int) (int_xP_alloc_table : (alloc_table int_xP))
  =
     (((=) (offset_min int_xP_alloc_table p) a) /\
     ((=) (offset_max int_xP_alloc_table p) b))
  
  axiom Int_xP_int : ((=) (int_of_tag int_xP_tag) (5))
  
end

module Struct_int_xP_unsafe

  use import Struct_int_xP 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_int_xP
  (p : (pointer int_xP)) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !int_xP_alloc_table p)) }
    writes { int_xP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !int_xP_alloc_table (old !int_xP_alloc_table)))
      \/
      ((frame_free_struct_int_xP p (old !int_xP_alloc_table)
       !int_xP_alloc_table)
      /\ (fresh_alloc_struct_int_xP p !int_xP_alloc_table))) }
  
  val allocate_struct_int_xP_requires
  (n : int) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) 
    (int_xP_tag_table : ref (tag_table int_xP)) : (pointer int_xP)
     requires { ((>=) n (0)) } writes { int_xP_alloc_table, int_xP_tag_table
     }
     ensures {
       ((strict_valid_struct_int_xP result (0) (Int.(-) n (1))
        !int_xP_alloc_table)
       /\
       ((frame_alloc_struct_int_xP result n (old !int_xP_alloc_table)
        !int_xP_alloc_table)
       /\
       ((frame_tag_struct_int_xP result (old !int_xP_tag_table)
        !int_xP_tag_table)
       /\
       ((fresh_alloc_struct_int_xP result (old !int_xP_alloc_table)) /\
       ((fresh_tag_struct_int_xP result (old !int_xP_tag_table)) /\
       ((typeof_struct_int_xP result (0) n !int_xP_tag_table) /\
       (container_of_struct_int_xP result (0) n !int_xP_tag_table))))))) }
  
end

module Struct_int_xP_safe

  use import Struct_int_xP 
  
  use import Root_int_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_int_xP
  (p : (pointer int_xP)) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) : unit
    requires { true } writes { int_xP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !int_xP_alloc_table (old !int_xP_alloc_table)))
      \/
      ((frame_free_struct_int_xP p (old !int_xP_alloc_table)
       !int_xP_alloc_table)
      /\ (fresh_alloc_struct_int_xP p !int_xP_alloc_table))) }
  
  val allocate_struct_int_xP
  (n : int) 
   (int_xP_alloc_table : ref (alloc_table int_xP)) 
    (int_xP_tag_table : ref (tag_table int_xP)) : (pointer int_xP)
     requires { true } writes { int_xP_alloc_table, int_xP_tag_table }
     ensures {
       ((strict_valid_struct_int_xP result (0) (Int.(-) n (1))
        !int_xP_alloc_table)
       /\
       ((frame_alloc_struct_int_xP result n (old !int_xP_alloc_table)
        !int_xP_alloc_table)
       /\
       ((frame_tag_struct_int_xP result (old !int_xP_tag_table)
        !int_xP_tag_table)
       /\
       ((fresh_alloc_struct_int_xP result (old !int_xP_alloc_table)) /\
       ((fresh_tag_struct_int_xP result (old !int_xP_tag_table)) /\
       ((typeof_struct_int_xP result (0) n !int_xP_tag_table) /\
       (container_of_struct_int_xP result (0) n !int_xP_tag_table))))))) }
  
  val allocate_singleton_struct_int_xP
  (int_xP_alloc_table : ref (alloc_table int_xP)) 
   (int_xP_tag_table : ref (tag_table int_xP)) : (pointer int_xP)
    requires { true } writes { int_xP_alloc_table, int_xP_tag_table }
    ensures {
      ((strict_valid_struct_int_xP result (0) (0) !int_xP_alloc_table) /\
      ((frame_alloc_struct_int_xP result (1) (old !int_xP_alloc_table)
       !int_xP_alloc_table)
      /\
      ((frame_tag_struct_int_xP result (old !int_xP_tag_table)
       !int_xP_tag_table)
      /\
      ((fresh_alloc_struct_int_xP result (old !int_xP_alloc_table)) /\
      ((fresh_tag_struct_int_xP result (old !int_xP_tag_table)) /\
      ((typeof_singleton_struct_int_xP result !int_xP_tag_table) /\
      (container_of_singleton_struct_int_xP result !int_xP_tag_table))))))) }
  
end

theory Root_unsigned_charP

  use why3.Bool.Bool 
  
  type unsigned_charP 
  
end

theory Struct_unsigned_charP

  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function unsigned_charP_tag  : (tag_id
  unsigned_charP)
  
  axiom Unsigned_charP_parenttag_bottom :
  (parenttag unsigned_charP_tag bottom_tag)
  
  axiom Unsigned_charP_is_final :
  (forall unsigned_charP_tag_table : (tag_table unsigned_charP).
   (forall p : (pointer unsigned_charP).
    ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) ->
     ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag))))
  
  predicate frame_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_tag_table : (tag_table unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((tag_extends old_unsigned_charP_tag_table unsigned_charP_tag_table) /\
     (alloc_tag_block old_unsigned_charP_tag_table unsigned_charP_tag_table
     p))
  
  predicate frame_free_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((free_extends old_unsigned_charP_alloc_table unsigned_charP_alloc_table)
     /\
     (free_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p))
  
  predicate frame_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (n : int) (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((alloc_extends old_unsigned_charP_alloc_table
      unsigned_charP_alloc_table)
     /\
     (alloc_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p
     n))
  
  predicate fresh_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (tag_fresh unsigned_charP_tag_table p)
  
  predicate fresh_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = (alloc_fresh unsigned_charP_alloc_table p)
  
  predicate container_of_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate container_of_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate typeof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag)
  
  predicate typeof_struct_unsigned_charP (p : (pointer unsigned_charP)) (l :
  int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     (((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof unsigned_charP_tag_table (shift p i)) unsigned_charP_tag))))
  
  predicate instanceof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (instanceof unsigned_charP_tag_table p unsigned_charP_tag)
  
  predicate instanceof_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof unsigned_charP_tag_table (shift p i) unsigned_charP_tag))))
  
  predicate right_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((>=) (offset_max unsigned_charP_alloc_table p) b)
  
  predicate left_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((<=) (offset_min unsigned_charP_alloc_table p) a)
  
  predicate valid_struct_unsigned_charP (p : (pointer unsigned_charP)) (a :
  int) (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     (((<=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((>=) (offset_max unsigned_charP_alloc_table p) b))
  
  predicate strict_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (b : int) (unsigned_charP_alloc_table : (alloc_table
  unsigned_charP))
  =
     (((=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((=) (offset_max unsigned_charP_alloc_table p) b))
  
  axiom Unsigned_charP_int : ((=) (int_of_tag unsigned_charP_tag) (6))
  
end

module Struct_unsigned_charP_unsafe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !unsigned_charP_alloc_table p)) }
    writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP_requires
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { ((>=) n (0)) } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
end

module Struct_unsigned_charP_safe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires { true } writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { true } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
  val allocate_singleton_struct_unsigned_charP
  (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
   (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
    unsigned_charP)
    requires { true } writes { unsigned_charP_alloc_table,
    unsigned_charP_tag_table }
    ensures {
      ((strict_valid_struct_unsigned_charP result (0) (0)
       !unsigned_charP_alloc_table)
      /\
      ((frame_alloc_struct_unsigned_charP result (1) (old
       !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
      /\
      ((frame_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table) !unsigned_charP_tag_table)
      /\
      ((fresh_alloc_struct_unsigned_charP result (old
       !unsigned_charP_alloc_table))
      /\
      ((fresh_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table))
      /\
      ((typeof_singleton_struct_unsigned_charP result
       !unsigned_charP_tag_table)
      /\
      (container_of_singleton_struct_unsigned_charP result
      !unsigned_charP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Function_max_max

  use enum.Uint32 
  
  use import Root_int_xP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val max_max
  (a : (pointer intP)) 
   (size_2 : Uint32.t) 
    (max1 : (pointer int_xP)) 
     (max2 : (pointer int_xP)) 
      (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP))) 
       (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer intP))) 
        (int_xP_max2_4_alloc_table : (alloc_table int_xP)) 
         (int_xP_max1_3_alloc_table : (alloc_table int_xP)) 
          (intP_a_2_alloc_table : (alloc_table intP)) 
           (intP_a_2_tag_table : (tag_table intP)) 
            (intP_intM_a_2 : (memory intP Int32.t)) : unit
             requires { true } reads { int_xP_int_xM_max1_3,
             int_xP_int_xM_max2_4 } writes { int_xP_int_xM_max1_3,
             int_xP_int_xM_max2_4 }
             ensures {
               ((((>) (Uint32.to_int size_2) (1)) ->
                 (((#"max_max.jc" 75 10 36# "expl:Assigns clause"
                   (not_assigns int_xP_max1_3_alloc_table
                   int_xP_max1_3_alloc_table (old !int_xP_int_xM_max1_3)
                   !int_xP_int_xM_max1_3 (pset_singleton max1)))
                  /\
                  (#"max_max.jc" 75 10 36# "expl:Assigns clause"
                  (not_assigns int_xP_max2_4_alloc_table
                  int_xP_max2_4_alloc_table (old !int_xP_int_xM_max2_4)
                  !int_xP_int_xM_max2_4 (pset_singleton max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 27#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 31 43#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 20 15 117#
                  "expl:Ensures clause"
                  (exists i_1 : int.
                   (exists j_5 : int.
                    (((<=) (0) i_1) /\
                    (((<) i_1 (Uint32.to_int size_2)) /\
                    (((<=) (0) j_5) /\
                    (((<) j_5 (Uint32.to_int size_2)) /\
                    (((<>) i_1 j_5) /\
                    (((=) (shift a i_1) (select !int_xP_int_xM_max1_3 max1))
                    /\
                    ((=) (shift a j_5) (select !int_xP_int_xM_max2_4 max2)))))))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 21 15 31#
                  "expl:Ensures clause"
                  (Int32.(>=)
                  (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 22 15 66#
                  "expl:Ensures clause"
                  (forall i_2 : int.
                   ((((<=) (0) i_2) /\ ((<) i_2 (Uint32.to_int size_2))) ->
                    (Int32.(<=) (select intP_intM_a_2 (shift a i_2))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max1_3 max1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 23 15 83#
                  "expl:Ensures clause"
                  (exists i_3 : int.
                   (((<=) (0) i_3) /\
                   (((<) i_3 (Uint32.to_int size_2)) /\
                   ((Int32.(>=) (select intP_intM_a_2 (shift a i_3))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   (Int32.(=) (select intP_intM_a_2 (shift a i_3))
                   (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 24 15 131#
                 "expl:Ensures clause"
                 (not
                 (exists i_4 : int.
                  (exists j_6 : int.
                   (((<=) (0) i_4) /\
                   (((<) i_4 (Uint32.to_int size_2)) /\
                   (((<=) (0) j_6) /\
                   (((<) j_6 (Uint32.to_int size_2)) /\
                   (((<>) i_4 j_6) /\
                   ((Int32.(>) (select intP_intM_a_2 (shift a i_4))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   ((Int32.(>) (select intP_intM_a_2 (shift a j_6))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   (Int32.(>) (select intP_intM_a_2 (shift a i_4))
                   (select intP_intM_a_2 (shift a j_6)))))))))))))))))))))))))))))
               /\
               ((((=) (Uint32.to_int size_2) (1)) ->
                 (((#"max_max.jc" 65 10 36# "expl:Assigns clause"
                   (not_assigns int_xP_max1_3_alloc_table
                   int_xP_max1_3_alloc_table (old !int_xP_int_xM_max1_3)
                   !int_xP_int_xM_max1_3 (pset_singleton max1)))
                  /\
                  (#"max_max.jc" 65 10 36# "expl:Assigns clause"
                  (not_assigns int_xP_max2_4_alloc_table
                  int_xP_max2_4_alloc_table (old !int_xP_int_xM_max2_4)
                  !int_xP_int_xM_max2_4 (pset_singleton max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
                  "expl:Ensures clause"
                  (Int32.(=)
                  (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
                  (select intP_intM_a_2 (shift a (0)))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 14 15 31#
                  "expl:Ensures clause"
                  (Int32.(=)
                  (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 15 15 29#
                 "expl:Ensures clause"
                 ((=) (select !int_xP_int_xM_max1_3 max1)
                 (select !int_xP_int_xM_max2_4 max2))))))))))
               /\
               (((=) (Uint32.to_int size_2) (0)) ->
                (((#"max_max.jc" 60 10 18# "expl:Assigns clause"
                  (not_assigns int_xP_max1_3_alloc_table
                  int_xP_max1_3_alloc_table (old !int_xP_int_xM_max1_3)
                  !int_xP_int_xM_max1_3 pset_empty))
                 /\
                 (#"max_max.jc" 60 10 18# "expl:Assigns clause"
                 (not_assigns int_xP_max2_4_alloc_table
                 int_xP_max2_4_alloc_table (old !int_xP_int_xM_max2_4)
                 !int_xP_int_xM_max2_4 pset_empty)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 8 15 33#
                "expl:Ensures clause"
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 8 15 33#
                "expl:Ensures clause"
                ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 8 15 33#
                 "expl:Ensures clause" ((=) max1 max1))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 9 15 33#
                "expl:Ensures clause" ((=) max2 max2))))))))) }
  
end

module Function_max_max_safe

  use enum.Uint32 
  
  use import Root_int_xP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val max_max
  (a : (pointer intP)) 
   (size_2 : Uint32.t) 
    (max1 : (pointer int_xP)) 
     (max2 : (pointer int_xP)) 
      (int_xP_int_xM_max2_4 : ref (memory int_xP (pointer intP))) 
       (int_xP_int_xM_max1_3 : ref (memory int_xP (pointer intP))) 
        (int_xP_max2_4_alloc_table : (alloc_table int_xP)) 
         (int_xP_max1_3_alloc_table : (alloc_table int_xP)) 
          (intP_a_2_alloc_table : (alloc_table intP)) 
           (intP_a_2_tag_table : (tag_table intP)) 
            (intP_intM_a_2 : (memory intP Int32.t)) : unit
             requires {
               ("expl:Internal"
               (#"max_max.jc" 36 12 1250# "expl:Requires clause"
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 3 13 34#
                "expl:Requires clause"
                (if ((<=) (0) (Int.(-) (Uint32.to_int size_2) (1))) then
                 (((<=) (offset_min intP_a_2_alloc_table a) (0)) /\
                 (((>=) (offset_max intP_a_2_alloc_table a)
                  (Int.(-) (Uint32.to_int size_2) (1)))
                 /\
                 (forall __framac_tmp3 : int.
                  ((((<=) (0) __framac_tmp3) /\
                   ((<=) __framac_tmp3 (Int.(-) (Uint32.to_int size_2) (1))))
                   -> ((=) true true))))) else ((=) true true)))
               /\
               (#"max_max.jc" 36 12 1250# "expl:Requires clause"
               ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 13 25#
                "expl:Requires clause"
                (#"max_max.jc" 36 12 1250# "expl:Requires clause"
                ((#"max_max.jc" 36 12 1250# "expl:Requires clause"
                 ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
                /\
                (#"max_max.jc" 36 12 1250# "expl:Requires clause"
                ((#"max_max.jc" 36 12 1250# "expl:Requires clause"
                 ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
                /\
                (#"max_max.jc" 36 12 1250# "expl:Requires clause"
                ((=) true true)))))))
               /\
               (#"/home/work/workspace/education/acsl-exam/./max_max.c" 4 29 41#
               "expl:Requires clause"
               (#"max_max.jc" 36 12 1250# "expl:Requires clause"
               ((#"max_max.jc" 36 12 1250# "expl:Requires clause"
                ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
               /\
               (#"max_max.jc" 36 12 1250# "expl:Requires clause"
               ((#"max_max.jc" 36 12 1250# "expl:Requires clause"
                ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
               /\
               (#"max_max.jc" 36 12 1250# "expl:Requires clause"
               ((=) true true)))))))))))) }
             reads { int_xP_int_xM_max1_3, int_xP_int_xM_max2_4 } writes {
             int_xP_int_xM_max1_3, int_xP_int_xM_max2_4 }
             ensures {
               ((((>) (Uint32.to_int size_2) (1)) ->
                 (((#"max_max.jc" 75 10 36# "expl:Assigns clause"
                   (not_assigns int_xP_max1_3_alloc_table
                   int_xP_max1_3_alloc_table (old !int_xP_int_xM_max1_3)
                   !int_xP_int_xM_max1_3 (pset_singleton max1)))
                  /\
                  (#"max_max.jc" 75 10 36# "expl:Assigns clause"
                  (not_assigns int_xP_max2_4_alloc_table
                  int_xP_max2_4_alloc_table (old !int_xP_int_xM_max2_4)
                  !int_xP_int_xM_max2_4 (pset_singleton max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 27#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max1_3_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max1_3_alloc_table max1) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 31 43#
                  "expl:Ensures clause"
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                   "expl:Ensures clause"
                   ((<=) (offset_min int_xP_max2_4_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause"
                  ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                   "expl:Ensures clause"
                   ((>=) (offset_max int_xP_max2_4_alloc_table max2) (0)))
                  /\
                  (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                  "expl:Ensures clause" ((=) true true)))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 20 15 117#
                  "expl:Ensures clause"
                  (exists i_1 : int.
                   (exists j_5 : int.
                    (((<=) (0) i_1) /\
                    (((<) i_1 (Uint32.to_int size_2)) /\
                    (((<=) (0) j_5) /\
                    (((<) j_5 (Uint32.to_int size_2)) /\
                    (((<>) i_1 j_5) /\
                    (((=) (shift a i_1) (select !int_xP_int_xM_max1_3 max1))
                    /\
                    ((=) (shift a j_5) (select !int_xP_int_xM_max2_4 max2)))))))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 21 15 31#
                  "expl:Ensures clause"
                  (Int32.(>=)
                  (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 22 15 66#
                  "expl:Ensures clause"
                  (forall i_2 : int.
                   ((((<=) (0) i_2) /\ ((<) i_2 (Uint32.to_int size_2))) ->
                    (Int32.(<=) (select intP_intM_a_2 (shift a i_2))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max1_3 max1))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 19 15 43#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 23 15 83#
                  "expl:Ensures clause"
                  (exists i_3 : int.
                   (((<=) (0) i_3) /\
                   (((<) i_3 (Uint32.to_int size_2)) /\
                   ((Int32.(>=) (select intP_intM_a_2 (shift a i_3))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   (Int32.(=) (select intP_intM_a_2 (shift a i_3))
                   (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))))))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 24 15 131#
                 "expl:Ensures clause"
                 (not
                 (exists i_4 : int.
                  (exists j_6 : int.
                   (((<=) (0) i_4) /\
                   (((<) i_4 (Uint32.to_int size_2)) /\
                   (((<=) (0) j_6) /\
                   (((<) j_6 (Uint32.to_int size_2)) /\
                   (((<>) i_4 j_6) /\
                   ((Int32.(>) (select intP_intM_a_2 (shift a i_4))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   ((Int32.(>) (select intP_intM_a_2 (shift a j_6))
                    (select intP_intM_a_2
                    (select !int_xP_int_xM_max2_4 max2)))
                   /\
                   (Int32.(>) (select intP_intM_a_2 (shift a i_4))
                   (select intP_intM_a_2 (shift a j_6)))))))))))))))))))))))))))))
               /\
               ((((=) (Uint32.to_int size_2) (1)) ->
                 (((#"max_max.jc" 65 10 36# "expl:Assigns clause"
                   (not_assigns int_xP_max1_3_alloc_table
                   int_xP_max1_3_alloc_table (old !int_xP_int_xM_max1_3)
                   !int_xP_int_xM_max1_3 (pset_singleton max1)))
                  /\
                  (#"max_max.jc" 65 10 36# "expl:Assigns clause"
                  (not_assigns int_xP_max2_4_alloc_table
                  int_xP_max2_4_alloc_table (old !int_xP_int_xM_max2_4)
                  !int_xP_int_xM_max2_4 (pset_singleton max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
                 "expl:Ensures clause"
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
                  "expl:Ensures clause"
                  (Int32.(=)
                  (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
                  (select intP_intM_a_2 (shift a (0)))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 13 15 29#
                 "expl:Ensures clause"
                 ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 14 15 31#
                  "expl:Ensures clause"
                  (Int32.(=)
                  (select intP_intM_a_2 (select !int_xP_int_xM_max1_3 max1))
                  (select intP_intM_a_2 (select !int_xP_int_xM_max2_4 max2))))
                 /\
                 (#"/home/work/workspace/education/acsl-exam/./max_max.c" 15 15 29#
                 "expl:Ensures clause"
                 ((=) (select !int_xP_int_xM_max1_3 max1)
                 (select !int_xP_int_xM_max2_4 max2))))))))))
               /\
               (((=) (Uint32.to_int size_2) (0)) ->
                (((#"max_max.jc" 60 10 18# "expl:Assigns clause"
                  (not_assigns int_xP_max1_3_alloc_table
                  int_xP_max1_3_alloc_table (old !int_xP_int_xM_max1_3)
                  !int_xP_int_xM_max1_3 pset_empty))
                 /\
                 (#"max_max.jc" 60 10 18# "expl:Assigns clause"
                 (not_assigns int_xP_max2_4_alloc_table
                 int_xP_max2_4_alloc_table (old !int_xP_int_xM_max2_4)
                 !int_xP_int_xM_max2_4 pset_empty)))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 8 15 33#
                "expl:Ensures clause"
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 8 15 33#
                "expl:Ensures clause"
                ((#"/home/work/workspace/education/acsl-exam/./max_max.c" 8 15 33#
                 "expl:Ensures clause" ((=) max1 max1))
                /\
                (#"/home/work/workspace/education/acsl-exam/./max_max.c" 9 15 33#
                "expl:Ensures clause" ((=) max2 max2))))))))) }
  
end
